<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/myjs/loadscripts.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/myjs/jump-1.2.js"></script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/resources/resources.js"></script>
    <script src="/myjs/scriptlist.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg">🚀</button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <div id="homepage-center">
            <div id="slogan">
                <i id="wolf-logo" style="font-style: normal;" class="mr-4">🌑</i><span id="slogan-text"></span>
            </div>
            <div id="homepage-btn">
                <div id="showmore"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; About Me & This Blog</div>
                <div id="showhacknical"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; My Github Analysis</div>
                <div id="toarticles"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; My Tech Articles</div>
            </div>
        </div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Online:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Chars:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Categories:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tags:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Last update:</td>
                    <td style="text-align:left" id="stat_last_update"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn btn-light" type="button" title="clear search">cls</button>
                <button id="categories" class="btn btn-light" type="button">cates</button>
                <button id="tags" class="btn btn-light" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn btn-light" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-前言" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            前言
          </h3><p>本<strong>系列</strong>文章主要是为Java并发入门做铺垫，集中清点：</p>
<ul>
<li><strong>Thread的基本概念</strong></li>
<li><strong>生命周期</strong></li>
<li><strong>创建和使用</strong></li>
<li><strong>线程的魅力所在</strong><ul>
<li><strong>从线程不同步到线程安全</strong><ul>
<li><strong>锁</strong></li>
<li><strong>死锁情况</strong></li>
</ul>
</li>
<li><strong>从线程各自独立到线程通信</strong><ul>
<li><strong>停止线程</strong></li>
<li><strong>唤醒线程</strong></li>
<li><strong>通信</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>Java中的并发编程</strong></li>
<li><strong>并发和单例模式的那些事</strong></li>
</ul>
<p>本系列除了参考<em>《Java并发编程的艺术》</em>和<em>《Java多线程编程核心技术》</em>这两本书之外，还会参考JDK的源码和<a href="https://docs.oracle.com/javase/8/docs/api/">API文档</a>，<strong>会翻译文档中部分重要的说明，比如过期方法为什么过期和官方解决办法等等</strong></p>
<p>本篇主要介绍一下三部分</p>
<ul>
<li><strong>Thread的基本概念：</strong>线程是什么，什么是线程，Java的线程优先级</li>
<li><strong>生命周期：</strong>生命周期的状态、转换、相关方法</li>
<li><strong>创建和使用：</strong>线程的创建的两种方法、常用方法如sleep，yield，状态获取等</li>
</ul>
<hr>

          <h3>
            <a name="_root-Thread基本概念" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Thread基本概念
          </h3><p><strong>程序(program)：</strong>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象</p>
<p><strong>进程(process)：</strong>是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。程序是静态的，进程是动态的</p>
<p><strong>线程(thread)：</strong>进程可进一步细化为线程，是一个程序内部的一条执行路径。若一个程序可同一时间执行多个线程，就是支持多线程的</p>
<p>Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。</p>

          <h4>
            <a name="_root-进程和线程的区别" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            进程和线程的区别
          </h4><p>一个进程包含多个线程，线程是进程的一个子任务</p>

          <h4>
            <a name="_root-Java的线程优先级" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Java的线程优先级
          </h4><p>优先级的意义就是优先级越高，越有可能先获得CPU资源，或者更多的CPU资源</p>
<p>特点：</p>
<ul>
<li><strong>继承性：</strong>子线程持有和父线程一样的优先级</li>
<li><strong>概率性：</strong>高优先级仅仅是提高获取资源的概率，而不是绝对优先，换句话说，JVM只是把你设置的优先级作为参考，实际执行还是看JVM自己的选择，大部分情况下JVM都会参考你的优先级</li>
</ul>

          <h4>
            <a name="_root-守护线程（Daemon Thread）" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            守护线程（Daemon Thread）
          </h4><p>从我的理解来看，线程的分类可以根据线程的服务对象来分为：</p>
<ul>
<li><strong>用户线程：</strong>直接为业务服务的线程</li>
<li><strong>守护线程：</strong>直接为线程服务的线程或者间接为业务服务的线程</li>
</ul>
<p>守护线程的意义在于<strong>“守护”</strong>，当线程中不存在用户线程了，守护线程就自动销毁，对于守护线程，<em>《Java多线程编程核心技术》</em>一书说了一个很好的比喻：</p>
<blockquote>
<p>任何一个守护线程就想一个保姆一样守护着整个JVM中所有的用户线程（原话是非守护线程），只要当前JVM里面还有一个用户线程没有结束，守护线程就得一直工作。只有当最后一个用户线程结束的时候，守护线程才自动随着JVM一同结束工作。Daemon线程的作用就是为其他线程的运行提供便利。</p>
<p>守护线程典型的代表就是GC，当程序里面没有用户线程了，也就没有垃圾回收的必要了，执行GC的线程自动销毁。</p>
</blockquote>

          <h3>
            <a name="_root-生命周期" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            生命周期
          </h3><table>
<thead>
<tr>
<th align="left">状态名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NEW</td>
<td align="left">初试状态，刚刚new出线程，但是还没有调用start方法</td>
</tr>
<tr>
<td align="left">RUNNABLE</td>
<td align="left">运行状态，Java线程中将操作系统中的“RUNNING”和“READY”两个状态统称为“RUNNABLE”</td>
</tr>
<tr>
<td align="left">BLOCKED</td>
<td align="left">阻塞状态，线程阻塞于锁</td>
</tr>
<tr>
<td align="left">WAITING</td>
<td align="left">等待状态，表示线程进入无时间限制的等待，线程需要其他线程做一些通知或者中断动作</td>
</tr>
<tr>
<td align="left">TIMED_WAITING</td>
<td align="left">超时等待状态，表示线程进入有时间限制的等待，在时间限制内可以进行中断或者通知操作，超时则自行返回</td>
</tr>
<tr>
<td align="left">TERMINATED</td>
<td align="left">终止状态，线程已经执行完毕</td>
</tr>
</tbody></table>
<p>
        <div id="_showpic_776bfe38" class="showpicbtn">正在显示图片 >></div>
        <img id="_pic_776bfe38" href=https://image.youyinnn.top/TIM%E5%9B%BE%E7%89%8720180710172525.png class="hidepic" ></img>
        <script>
            let imgself776bfe38 = document.getElementById('_pic_776bfe38')
            let isInViewPortOfTwo776bfe38 = function () {
                const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
                const top = imgself776bfe38.getBoundingClientRect() && imgself776bfe38.getBoundingClientRect().top
                if (top  <= viewPortHeight + 300) {
                    document.getElementById('_pic_776bfe38').src = document.getElementById('_pic_776bfe38').getAttribute('href')
                    document.getElementById('_pic_776bfe38').classList = ['showpic']
                    document.getElementById('_showpic_776bfe38').style.display = 'none'
                    window.removeEventListener('scroll', isInViewPortOfTwo776bfe38)
                    isInViewPortOfTwo776bfe38 = null
                }
            }
            isInViewPortOfTwo776bfe38 ()
            window.addEventListener('scroll', isInViewPortOfTwo776bfe38)
        </script>
    </p>

          <h3>
            <a name="_root-线程创建与使用" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            线程创建与使用
          </h3>
          <h4>
            <a name="_root-创建" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            创建
          </h4><p><strong>线程的实现方法：</strong></p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口并实现run()方法</li>
</ol>

          <h5>
            <a name="_root-方式1：继承Thread类" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            方式1：继承Thread类
          </h5><pre><code class="language-java">public class testThread {
    public static void main(String[] args) {
        //3、创建子类独对象
        SubThread subThread = new SubThread();
        //4、调用线程start方法 启动线程 调用run方法
        //5、run方法 并不启动线程
        subThread.start();
    }
}

//1、创建一个继承Thread类的子类
class SubThread extends Thread{
    //2、重写Thread类的run方法，方法内实现这个线程需要做的功能。
    @Override
    public void run() {
        super.setName(&quot;子线程&quot;);
        for (int i = 0; i&lt; 10 ; ++i){
            System.out.println(Thread.currentThread().getName()+&quot;:线程方法&quot;);
        }
    }
}</code></pre>

          <h5>
            <a name="_root-方式2：实现Runnable接口" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            方式2：实现Runnable接口
          </h5><pre><code class="language-java">public class testImplRunnable {
    public static void main(String[] args) {
        PrintNumber printNumber = new PrintNumber();
        //启动线程 执行Thread对象构造时传入的对象的run方法
        Thread thread = new Thread(printNumber);
        thread.start();

        Thread thread2 = new Thread(printNumber);
        thread2.start();
    }
}

class PrintNumber implements Runnable{

    @Override
    public void run() {
        for (int i = 0 ; i &lt; 10 ; ++i){
            System.out.println(i);
        }
    }
}</code></pre>

          <h5>
            <a name="_root-两种方式的对比" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            两种方式的对比
          </h5><ul>
<li><strong>继承方式</strong>让类在继承上面的选择受限，<strong>接口实现方式</strong>则很随意</li>
<li><strong>继承方式</strong>让类拥有一些<strong>线程内建的方法</strong>例如<code>yield()</code>，<strong>接口实现方式</strong>则没有</li>
</ul>

          <h4>
            <a name="_root-使用" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            使用
          </h4>
          <h5>
            <a name="_root-currentThread()方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            currentThread()方法
          </h5><p>这个方法获取正在调用当前代码段的线程的<strong>线程对象</strong>，获取到线程对象，我们可以获取线程的<strong>名字、状态、ID号、线程优先级、是否处于终端、是否处于活动状态</strong>等信息，这些API在后面我们会一个个讲到</p>
<pre><code class="language-java">@Test
public void testCurr(){
    System.out.println(Thread.currentThread().getName()); //main
    System.out.println(Thread.currentThread().isAlive()); //true
    System.out.println(Thread.currentThread().getState()); //RUNNABLE
    System.out.println(Thread.currentThread().getPriority()); //5
}</code></pre>

          <h5>
            <a name="_root-isAlive()方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            isAlive()方法
          </h5><p>作用是判断当前线程是否<strong>存活</strong>，这个存活的界定是：<strong>如果线程处于正在运行或者准备开始运行的状态，则判定线程存活</strong></p>

          <h5>
            <a name="_root-sleep()方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            sleep()方法
          </h5><p>让当前线程睡上<strong>n毫秒</strong></p>
<pre><code class="language-java">@Test
public void testSleep() throws InterruptedException {
    Runnable sleep = () -&gt; {
        try {
            System.out.println(Thread.currentThread().getName() + &quot; sleep&quot;);
            Thread.sleep(10 * 1000);
            System.out.println(&quot;sleep done&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    };
    Thread t = new Thread(sleep, &quot;sleepThread&quot;);
    t.start();
    //t.run();
    Thread.sleep(1000);
    System.out.println(t.getState() + &quot;  &quot; + t.getName());
}</code></pre>
<p>在<strong>line：13-14</strong>，我们需要注意：</p>
<ul>
<li>t.<strong>start()方法</strong>是以<strong>新开一个线程</strong>的方式运行<strong>sleep.run()</strong></li>
<li>start.<strong>run()方法</strong>是直接在<strong>当前线程</strong>中运行<strong>sleep.run()</strong></li>
</ul>
<p>所以当我们以<strong>start方式</strong>去启动程序的时候，输出结果为：</p>
<pre><code class="language-console">sleepThread sleep
TIMED_WAITING  sleepThread</code></pre>
<p>可以看到线程名字为<strong>sleepThread</strong>，需要注意的是：</p>
<ul>
<li>这个程序还有另外一个目的就是为了<strong>检测睡眠中的线程到底是处于什么状态</strong>，从结果得知，是<strong>TIMED_WAITING状态</strong></li>
<li>为了可以检测到睡眠线程，我们<strong>在main线程中也睡了1秒</strong>，原因是<strong>sleepThread</strong>只是<strong>main线程</strong>的一个<strong>子线程</strong>，<strong>如果main线程挂了，则其子线程也就跟着挂</strong>，所以理论上来说，整个程序并不会看到<strong>line：7</strong>所输出的语句</li>
</ul>
<p>当我们以<strong>run方式</strong>启动线程的时候，输出为：</p>
<pre><code class="language-console">main sleep
sleep done
NEW  sleepThread</code></pre>
<p>可以看到，执行<strong>sleep.run</strong>方法的确实是<strong>main线程</strong>，而且整个程序在输出第一行的时候，是睡了10秒再输出接下来的，然后我们的<strong>sleepThread</strong>也是没有运行，还是处于<strong>NEW状态</strong></p>

          <h6>
            <a name="_root-注意" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            注意
          </h6><blockquote>
<p>在线程的<strong>sleep</strong>的过程中，如果调用了线程的中断方法<code>interrupt()</code>，则在sleep代码处会抛出<code>InterruptedException</code>异常，这个异常会<strong>清除线程的中断标识</strong>，所以你之前调用<code>interrupt()</code>方法设置的中断标识可能没用了，也就是说，如果要在有<strong>sleep</strong>代码的线程中使用中断标识去有效地进行终端操作的话，那么<code>catch(){}</code>语句块里就不能什么也不做，必须在<code>catch(){}</code>中有中断的逻辑，否则可能达不到中断的效果。</p>
</blockquote>

          <h5>
            <a name="_root-join()方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            join()方法
          </h5><p>在当前线程中调用<code>someThread.join()</code>方法，就是暂停当前线程，启动someThread，只有当someThread执行完毕或者这个方法会被<code>interrupt()</code>打断，而抛出中断异常。</p>
<p><code>join()</code>还有<code>join(long timeout)</code>，其内部实现如：</p>
<pre><code class="language-java">public final synchronized void join(long millis) throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;
    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }
    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay &lt;= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}</code></pre>
<p>可以看到，join方法就是如果本线程还存活，就无限等待自己，给别的线程让出机会</p>

          <h5>
            <a name="_root-yield()方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            yield()方法
          </h5><p>这个方法的作用是<strong>放弃当前的CPU资源</strong>，将它让给其他的任务去占用CPU执行，<strong>但是放弃的时间不确定，有可能刚一放弃，马上就抢回来了，有点不要脸！</strong></p>

          <h5>
            <a name="_root-getState()方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            getState()方法
          </h5><p>获取一个State对象，表示当前线程的生命周期</p>

          <h3>
            <a name="_root-Object方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Object方法
          </h3>
          <h4>
            <a name="_root-wait(long timeout)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            wait(long timeout)
          </h4><p>作用是使当前执行代码的<strong>线程（as T）</strong>进入等待状态，由于<code>wait()</code>方法是Object类的方法，用来将<strong>当前线程（T）</strong>置入“等待队列”中。所以需要显式地使用<strong>synchronized</strong>块包裹起来，在synchronized块中再次获取<strong>该锁（调用<code>wait()</code>的对象的对象锁，as OL）</strong>，才能调用<code>wait()</code>方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>异常</p>
<p>调用<code>wait()</code>方法之后，当前线程<strong>马上（从wait那一行开始马上放锁，而不是直到退出sync块）</strong>释放<strong>该锁（OL）</strong>，并进入等待队列<strong>（对象锁对应对象的等待队列）</strong>，此时线程进入suspend状态</p>
<p>如果timeout设置为0的话则没有超时时间，一直等到notify</p>
<p>若要<strong>线程T</strong>从<code>wait()</code>中返回：</p>
<ul>
<li><strong>其他线程</strong>，获取到<strong>OL</strong>，并且调用该对象的<code>notify()</code>方法，并且<strong>线程T</strong>，在等待队列中<strong>随机地（arbitrarily）</strong>被选中唤醒</li>
<li><strong>其他线程</strong>，获取到<strong>OL</strong>，并且调用该对象的<code>notifyAll()</code>方法</li>
<li><strong>其他线程</strong>，调用了<strong>线程T</strong>的<code>interrupt()</code>方法，所以需要处理中断异常</li>
<li>除非timeout不是0，到期超时自己返回</li>
</ul>
<p><strong>线程T</strong>被<strong>唤醒（notify）</strong>之后，仍然和其他线程在通常的情况下，再次竞争<strong>OL</strong>，以获取进入同步的权力，一旦获取到权力，<strong>线程T</strong>就会恢复到wait时候完全一样的状态，继续工作。</p>
<p>等待状态中的线程也可以不必被其他线程唤醒、打断、或者等待超时，我们可以自行<strong>检测</strong>唤醒的条件，满足条件就不再等待，换句话说，我们推荐你在使用<code>wait()</code>的时候使用以下这样的loop：</p>
<pre><code class="language-java">synchronized (obj) {
 while (&lt;condition does not hold&gt;)
     obj.wait(timeout);
 ... // Perform action appropriate to condition
}</code></pre>
<p>需要注意的是，<strong>线程T</strong>在<code>wait()</code>的过程中，仅释放<strong>OL</strong>锁，线程原来持有的锁仍会随着线程进入wait状态，我们可以做个简单的测试：</p>
<pre><code class="language-java">public class WaitTest {

    private static String lockA = &quot;la&quot;;
    private static String lockB = &quot;lb&quot;;

    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (lockA) {
                System.out.println(&quot;T1 got locak A&quot;);
                synchronized (lockB) {
                    System.out.println(&quot;T1 got locak B&quot;);
                    try {
                        System.out.println(&quot;T1 wait, released lockA for now&quot;);
                        lockA.wait(5000);
                        System.out.println(&quot;T1 come back from wait, and got lockA again&quot;);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(&quot;T1 released lockB&quot;);
            }
            System.out.println(&quot;T1 released lockA finally&quot;);
        }).start();
        new Thread(() -&gt; {
            System.out.println(&quot;T2 sleep 3 seconds&quot;);
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockA) {
                System.out.println(&quot;T2 got lockA, and sleep 6 sec&quot;);
                try {
                    Thread.sleep(6000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;T2 released lockA&quot;);
        }).start();
        new Thread(() -&gt; {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;T3 wanna get lockB&quot;);
            synchronized (lockB) {
                System.out.println(&quot;T3 got lockB&quot;);
            }
            System.out.println(&quot;T3 released lockB&quot;);
        }).start();
    }
}</code></pre>
<p>输出：</p>
<pre><code class="language-con">T1 got locak A
T2 sleep 3 seconds
T1 got locak B
T1 wait, released lockA for now
T3 wanna get lockB
T2 got lockA, and sleep 6 sec
T2 released lockA
T1 come back from wait, and got lockA again
T1 released lockB
T1 released lockA finally
T3 got lockB
T3 released lockB</code></pre>
<p>我们需要注意2点：</p>
<ol>
<li>在14行虽然设置了超时时间是5秒，但是仍旧等待了6秒，因为t2占有了lockA6秒之久</li>
<li>虽然t1在某时刻释放了lockA，但是t1持有的lockB还没释放，最后t3还是得等到t1释放了lockB之后才能获取到lockB</li>
</ol>
<p>总结一下时间线，按照绝对时间来说：</p>
<ul>
<li><p>0秒开始不久：</p>
<ul>
<li><p>T1拿到A锁，随后拿到B锁，然后在A锁上wait，并且超时5秒；</p>
</li>
<li><p>T2开始沉睡3秒</p>
</li>
<li><p>T3开始沉睡1秒</p>
<blockquote>
<p>这时A锁已经释放，B锁被T1抓住</p>
</blockquote>
</li>
</ul>
</li>
<li><p>1秒时：</p>
<ul>
<li>T3醒来，在B锁的门前BLOCK住，因为这时候B锁被T1抓住着；</li>
<li>T2还在睡，还有2秒；</li>
<li>T1在等待A锁超时，还剩4秒；</li>
</ul>
</li>
<li><p>2秒时：</p>
<ul>
<li>T1在等待A锁超时，还剩3秒；</li>
<li>T2还在睡，还有1秒；</li>
<li>T3仍在等B锁；</li>
</ul>
</li>
<li><p>3秒时：</p>
<ul>
<li>T2醒来，拿到A锁，并沉睡6秒；</li>
<li>T1在等待A锁超时，还剩2秒；</li>
<li>T3仍在等B锁；</li>
</ul>
</li>
<li><p>5秒时：</p>
<ul>
<li>T1等待A锁超时结束，但是A锁被T2抓住睡觉了，还剩1秒，所以T1 BLOCK住；</li>
<li>T2还有1秒苏醒；</li>
<li>T3快哭了；</li>
</ul>
</li>
<li><p>6秒时：</p>
<ul>
<li>T2醒来，放开A锁；</li>
<li>T1拿到A锁，没事干了，放开B锁，放开A锁；</li>
<li>T3终于拿到B锁了；</li>
</ul>
</li>
</ul>

          <h4>
            <a name="_root-notify()" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            notify()
          </h4><p>唤醒在该对象<strong>等待队列</strong>中的一个等待线程，在队列中等待的线程是被<strong>随机选取</strong>唤醒的，且必须是由调用该对象<code>wait()</code>方法而进入的等待队列</p>
<p>被唤醒的线程会和其他线程一样，在同样的情况下一起竞争该<strong>对象的同步锁（as OL）</strong></p>
<blockquote>
<p>细节说明：</p>
<ol>
<li>被notify通知的对象，并不是马上就获取<strong>OL</strong>，而是还需要积极竞争</li>
<li>notify之后，和wait不一样的是，并不是马上放锁，而是直到退出sync区域之后才释放锁</li>
</ol>
</blockquote>
<p>本方法只能在当前线程<strong>持有该对象锁的时候，才能调用该对象的<code>notify()</code>方法</strong>：</p>
<ul>
<li>By executing a synchronized instance method of that object.</li>
<li>By executing the body of a <code>synchronized</code> statement that synchronizes on the object.</li>
<li>For objects of type <code>Class,</code> by executing a synchronized static method of that class.</li>
</ul>
<p>否则会抛出<code>java.lang.IllegalMonitorStateException</code>异常</p>

          <h4>
            <a name="_root-notifyAll()" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            notifyAll()
          </h4><p>唤醒在该对象<strong>等待队列</strong>中的所有等待线程，且必须是由调用该对象<code>wait()</code>方法而进入的等待队列</p>
<p>被唤醒的所有线程会和其他线程一样，在同样的情况下一起竞争该<strong>对象的同步锁（as OL）</strong></p>

          <h4>
            <a name="_root-讨论一下wait的风险" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            讨论一下wait的风险
          </h4><p>这是在几个月前顺丰科技面试的时候，一面面试官问我的问题，当时我没答上，因为当时准备的很不充分，连wait和sleep的区别都没看，估计是因为这个原因，面试官以为又摸到我的上限了，顺丰科技还是挺想去的</p>
<p>今天看了一下wait和notify之后，感觉能回答出这个问题了</p>
<ol>
<li>因为wait并<strong>不会释放线程占有的其他锁</strong>，如果忽略掉这个问题的话，会隐形地制造一些<strong>死锁</strong></li>
<li>因为wait的唤醒机制还是重新去竞争锁，如果竞争不顺利的话，会一直返回不了<strong>等待前的状态</strong>，导致这个线程进入<strong>饥饿状态</strong></li>
<li>同样的notify的唤醒是随机的，如果运气不好的话，线程会一直在等待队列中没有被选中，也进入了一种<strong>饥饿状态</strong></li>
</ol>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>