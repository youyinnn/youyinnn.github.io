<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="http://pv.sohu.com/cityjson?ie=utf-8"></script>
    <script>
        if (location.hostname === 'youyinnn.github.io' && returnCitySN.cname === 'CHINA') {
            location.href = 'https://youyinnn.gitee.io' + location.pathname
        }
    </script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">


    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn" type="button" title="clear search">cls</button>
                <button id="categories" class="btn" type="button">cates</button>
                <button id="tags" class="btn" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-26. Remove Duplicated From Sorted Array(Easy)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            26. Remove Duplicated From Sorted Array(Easy)
          </h3><p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn&#39;t matter what you leave beyond the returned length.</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn&#39;t matter what values are set beyond the returned length.</code></pre><p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<pre><code class="language-java">// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}</code></pre>

          <h4>
            <a name="_root-Brute Force" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Brute Force
          </h4><pre><code class="language-java">public int removeDuplicates(int[] nums) {
    int len = 0;
    int range = 0, set = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        if (range &lt; nums.length - 1 &amp;&amp;
            nums[range] == nums[range + 1]) {
            range++;
        } else {
            nums[set] = nums[range];
            set++;
            range++;
            len++;
        }
    }
    return len;
}</code></pre>

          <h3>
            <a name="_root-27. Remove Element(Easy)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            27. Remove Element(Easy)
          </h3><p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn&#39;t matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn&#39;t matter what you leave beyond the returned length.</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn&#39;t matter what values are set beyond the returned length.</code></pre><p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>

          <h4>
            <a name="_root-Brute Force" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Brute Force
          </h4><pre><code class="language-java">public int removeElement(int[] nums, int val) {
    int len = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        if (nums[i] != val) {
            nums[len++] = nums[i];   
        }
    }
    return len;
}</code></pre>

          <h3>
            <a name="_root-28. Implement strStr() (Easy)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            28. Implement strStr() (Easy)
          </h3><p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/">strStr()</a>.</p>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
Output: 2</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
Output: -1</code></pre><p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C&#39;s <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java&#39;s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a>.</p>
<p>这题其实就是字符串匹配，所以没什么多说的，要么暴力解要么kmp，比较遗憾的是，Leetcode的case不够多，于是暴力解的Runtime居然比KMP解的Runtime还要快</p>

          <h4>
            <a name="_root-Brute Force - O(n * m)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Brute Force - O(n * m)
          </h4><pre><code class="language-java">public int strStr(String haystack, String needle) {
    if (needle.isEmpty()) {
        return 0;
    }
    char[] t = haystack.toCharArray();
    char[] p = needle.toCharArray();
    int n = t.length;
    int m = p.length;
    for (int i = 0; i &lt;= n - m; i++){
        int j = 0;
        while(j &lt; m &amp;&amp; p[j] == t[i + j]){
            j++;
            if (j == m) return i;
        }
    }
    return -1;
}</code></pre>

          <h4>
            <a name="_root-KMP - O(n + m)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            KMP - O(n + m)
          </h4><pre><code class="language-java">public int strStr(String haystack, String needle) {
    if (needle.isEmpty()) {
        return 0;
    }
    return kmp(haystack.toCharArray(), needle.toCharArray());
}

private int kmp(char[] t, char[] p) {
    int[] next = nextVal(p);
    int i = 0;
    int j = 0;
    while (i &lt; t.length &amp;&amp; j &lt; p.length) {
        if (j == -1 || t[i] == p[j]) {
            // 有匹配就++
            i++;
            j++;
        } else {
            // 否则就按照next去移位j
            j = next[j];
        }
    }
    if (j == p.length) {
        return i - j;
    } else {
        return -1;
    }
}

public int[] nextVal(char[] p) {
    int[] nextVal = new int[p.length];
    int j = 0;
    int k = -1;
    nextVal[0] = -1;
    while (j &lt; p.length - 1) {
        if (k == -1 || p[j] == p[k]) {
            j++;
            k++;
            if (p[j] != p[k]) {
                nextVal[j] = k;
            } else {
                nextVal[j] = nextVal[k];
            }
        } else {
            k = nextVal[k];
        }
    }
    return nextVal;
}</code></pre>

          <h3>
            <a name="_root-29. Divide Two Integer (Medium)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            29. Divide Two Integer (Medium)
          </h3><p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p>
<p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p>
<p>The integer division should truncate toward zero.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: dividend = 10, divisor = 3
Output: 3</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: dividend = 7, divisor = -3
Output: -2</code></pre><p><strong>Note:</strong></p>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</li>
</ul>
<p>不能用乘除符号、不能用Long，行吧，用位运算试试，两倍两倍地运算，总比暴力一个一个的减要快多了</p>
<p>但是怎么说，这题也是垃圾题，500+👍，2700+的👎</p>

          <h4>
            <a name="_root-Bit operation (Beat 100%)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Bit operation (Beat 100%)
          </h4><pre><code class="language-java">public int divide(int dividend, int divisor) {       
    if(dividend ==  Integer.MIN_VALUE &amp;&amp; divisor == -1){
        return Integer.MAX_VALUE;
    }

    boolean isNeg = (dividend &lt; 0) ^ (divisor &lt; 0);
    if(dividend &gt; 0) dividend = -dividend;
    if(divisor &gt; 0) divisor = -divisor;

    return isNeg? -div(dividend, divisor) : div(dividend, divisor);
}
public int div(int divid, int divis){
    if(divid &gt; divis) return 0;
    int curSum = divis &lt;&lt; 1, prevSum = divis, q = 1;

    while(divid &lt;= curSum &amp;&amp; curSum &lt; prevSum){
        prevSum = curSum;
        curSum &lt;&lt;= 1; q &lt;&lt;= 1;
    }
    return q + div(divid - prevSum, divis);
}</code></pre>

          <h3>
            <a name="_root-30. Substring with Concatenation of All Words(Hard !!)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            30. Substring with Concatenation of All Words(Hard !!)
          </h3><p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input:
  s = &quot;barfoothefoobarman&quot;,
  words = [&quot;foo&quot;,&quot;bar&quot;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.
The output order does not matter, returning [9,0] is fine too.</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input:
  s = &quot;wordgoodgoodgoodbestword&quot;,
  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]
Output: []</code></pre><p>这题，变态难，首先words能全排列出n！种pattern，如果这题用全排列去做，然后每个排列去indexOf，那肯定TLE，先不说indexOf的效率，就是非递归的全排列，一时半会也写不出来，递归全排列绝壁TLE</p>
<p>不用全排列，那么我们从概率的角度来思考一下，假如我们把全排列的一个解称为一个<strong>pattern</strong></p>
<p>从第二个例子我们可以知道，一个可能的<strong>pattern</strong>必然包含所有单词出现的频数；这是第一个关键点；</p>
<p>第二个点就是，我们处理字符串匹配的时候，不免会具象化一个滑动窗口出来，这个滑动窗口阔着s串中的一个和<strong>pattern</strong>一样长的子串；</p>
<p>那么一个明显的思路是：我们知道words中的单词都是一样长的，假如说窗口中的子串，从头开始每个一个word长度，都有一个单词匹配到words中的word，而且我们可以维护一个临时的words频数计数器，每匹配到一个单词就增加这个频数计数</p>
<p>于是到最后就只会有三种可能：</p>
<ol>
<li>窗口中的某个word并没有在words中记过频数；</li>
<li>窗口中的某个word临时出现的频数超过words中记过频数；</li>
<li>窗口中最后一个word都没有出现上面两个可能；那么这就是一个解！</li>
</ol>
<p>于是我们处理问题的关键就在于，如何<strong>避免重复的单词对比而滑动窗口</strong></p>
<p>其实我自己想是已经想到了频数记录，然后滑动窗口了，但是我只能i++地滑动窗口，效率慢了许多，先放上我的解</p>

          <h4>
            <a name="_root-My Solution (550+ms Beat 9.0%)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            My Solution (550+ms Beat 9.0%)
          </h4><pre><code class="language-java">public List&lt;Integer&gt; findSubstring(String s, String[] words) {
    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();
    if (words.length == 0) {
        return ans;
    }
    int wordLength = words[0].length();
    HashMap&lt;String, Integer&gt; countMap = new HashMap&lt;&gt;(words.length);
    int count = 0;
    for (String word : words) {
        Integer integer = countMap.get(word);
        if (integer != null) {
            countMap.put(word, ++integer);
        } else {
            countMap.put(word, 1);
        }
        count++;
    }

    for (int i = 0; i &lt; s.length() - wordLength + 1; i++) {
        String first = s.substring(i, i + wordLength);
        Integer firstCount = countMap.get(first);
        int tmpCount = count;
        if (firstCount != null) {
            HashMap&lt;String, Integer&gt; tmp = (HashMap&lt;String, Integer&gt;) countMap.clone();
            tmp.put(first, --firstCount);
            tmpCount--;
            int tmpI = i;
            do {
                if (tmpCount == 0) {
                    ans.add(i);
                    break;
                } else {
                    tmpI = tmpI + wordLength;
                    if (tmpI &lt;= s.length() - wordLength) {
                        String next = s.substring(tmpI, tmpI + wordLength);
                        Integer nextCount = tmp.get(next);
                        if (nextCount != null &amp;&amp; nextCount != 0) {
                            tmp.put(next, --nextCount);
                            tmpCount--;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
            } while (true);
        }
    }
    return ans;
}</code></pre>

          <h4>
            <a name="_root-Elegant Solution (9ms Beat 99.6%)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Elegant Solution (9ms Beat 99.6%)
          </h4><p>leetcode上效率最快的解，用一种难以想象的方式去滑动窗口，优雅而晦涩</p>
<pre><code class="language-java">public List&lt;Integer&gt; findSubstring2(String s, String[] words) {
    List&lt;Integer&gt; indexes = new ArrayList&lt;&gt;();
    if (words.length == 0) {
        return indexes;
    }
    int wordLength = words[0].length();
    int patternLength = wordLength * words.length;
    if (patternLength &gt; s.length()) {
        return indexes;
    }

    Map&lt;String, Integer&gt; strings = new HashMap&lt;&gt;(words.length);
    for (int i = 0; i &lt; words.length; ++i) {
        strings.put(words[i], strings.getOrDefault(words[i], 0) + 1);
    }

    Map&lt;String, Integer&gt; temp = new HashMap&lt;&gt;();
    for (int k = 0; k &lt; wordLength; ++k) {
        for (int i = k; i &lt;= s.length() - patternLength; i += wordLength) {
            int j = i + patternLength;
            for (; j &gt; i; j -= wordLength) {
                String word = s.substring(j - wordLength, j);
                if (temp.getOrDefault(word, 0) + 1
                        &gt; strings.getOrDefault(word, 0)) {
                    i = j - wordLength;
                    break;
                }
                temp.put(word, temp.getOrDefault(word, 0) + 1);
            }
            if (j == i) {
                indexes.add(i);
            }
            temp.clear();
        }
    }
    return indexes;
}</code></pre>
<p>假如我们一个单词的长度是<code>wordLength</code>，一个pattern的长度是<code>patternLength</code></p>
<p>18行开始是精髓，用了3个for去做滑动窗口，其中：</p>
<ul>
<li><p>第一个for长度是单词的长度，它可以处理偏差，可以理解为滑动窗口的出发点，因为我们<strong>滑动窗口的长度总是单词长度的倍数（<code>j = i + patternLength</code>），并且总是以单词长度的倍数为距离做滑动（<code>i += wordLength</code>）</strong>，想象一下就知道了，比如：</p>
<p>  <code>s = “aasosfoobar” words = [&quot;foo&quot;, &quot;bar&quot;]</code>的时候，第一个第一个循环表示只需要每次从<strong>第一个a</strong>或者<strong>第二个a</strong>或<strong>第三个s</strong>开始往后滑动窗口就行了，因为<strong>第四个o</strong>如果也需要滑动的话，它得到的结果会有一部分和<strong>第一个a</strong>重叠；再其次，如果要窗口滑动到解<code>foobar</code>处的话，必须从<strong>第三个s</strong>为起点，对比两次（<strong>滑动两个单词长度距离</strong>）才滑动到正解处；</p>
</li>
<li><p>第二个for循环是用于滑动窗口距离的；</p>
</li>
<li><p>第三个for循环也是精髓，是用于对比窗口里的单词出现的频数的，根据频数结果来<strong>记录解或者决定下一次滑动窗口的起点</strong></p>
<p>  为什么这里要决定下一次滑动窗口的起点？原因很简单，在处理的时候我们已经知道当前窗口<strong>尾部</strong>有几组<strong>连续</strong>单词是<strong>出现在words</strong>里的，而当前窗口<strong>头部</strong>可能有几组单词是<strong>不出现在words</strong>里的，如果有不出现在words中的单词，那么我们下一次滑动窗口的起点可以从当前窗口中<strong>尾部连续命中</strong>的地方开始继续对比窗口，因为这部分连续的命中单词在下一个窗口中可能是一个解；</p>
</li>
</ul>
<p>分析起来比较复杂，实现起来就更精妙了，我们从第三个for循环中可以看到，我们是从窗口的后面往前比较的（<code>j -= wordLength</code>），如果比较到没有命中的单词，那么<strong>当前的j</strong>，就是下一次窗口的起点，为什么要<code>i = j - wordLength</code> ？因为下一次i循环之前会执行一次<code>i += wordLength</code></p>
<p>然后30行处，如果j已经和i一样了，那么说明从窗口的最后到最前都命中了，并且符合频数限制，于是这是一组合法的解</p>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>