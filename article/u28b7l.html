<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="http://pv.sohu.com/cityjson?ie=utf-8"></script>
    <script>
        if (location.hostname === 'youyinnn.github.io' && returnCitySN.cname === 'CHINA') {
            location.href = 'https://youyinnn.gitee.io' + location.pathname
        }
    </script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">


    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn" type="button" title="clear search">cls</button>
                <button id="categories" class="btn" type="button">cates</button>
                <button id="tags" class="btn" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-前言" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            前言
          </h3><p>因为Intern Job的原因，要接触到kafka和Microservice，虽然目前接触的不是很多，对于kafka的场景还不是很熟悉，但是总觉得这个东西是必学的，也是很重要的一种趋势</p>
<p>于是前几天给帖老板写的Graduation Design里写的就是kafka+springboot+opentracing的tracing监控系统</p>
<p>难度还是有的，springboot刚上手，opentracing的api在前一个月的工作里面也算是熟悉了，关键就是kafka以及如何把这几个玩意整合起来</p>
<p>anyway，这篇是关于kafka的入门理论基础</p>
<p>绝大部分转自：<a href="http://orchome.com">http://orchome.com</a></p>
<hr>

          <h3>
            <a name="_root-简单说明什么是kafka" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            简单说明什么是kafka
          </h3><p>Apache kafka是消息中间件的一种，我发现很多人不知道消息中间件是什么，在开始学习之前，我这边就先简单的解释一下什么是消息中间件，只是粗略的讲解，目前kafka已经可以做<code>更多</code>的事情。</p>
<p>举个例子，生产者消费者，生产者生产鸡蛋，消费者消费鸡蛋，生产者生产一个鸡蛋，消费者就消费一个鸡蛋，假设消费者消费鸡蛋的时候噎住了（系统宕机了），生产者还在生产鸡蛋，那新生产的鸡蛋就丢失了。再比如生产者很强劲（大交易量的情况），生产者1秒钟生产100个鸡蛋，消费者1秒钟只能吃50个鸡蛋，那要不了一会，消费者就吃不消了（消息堵塞，最终导致系统超时），消费者拒绝再吃了，”鸡蛋“又丢失了，这个时候我们放个篮子在它们中间，生产出来的鸡蛋都放到篮子里，消费者去篮子里拿鸡蛋，这样鸡蛋就不会丢失了，都在篮子里，而这个篮子就是”kafka“。<br>鸡蛋其实就是“数据流”，系统之间的交互都是通过“数据流”来传输的（就是tcp、http什么的），也称为报文，也叫“消息”。<br>消息队列满了，其实就是篮子满了，”鸡蛋“ 放不下了，那赶紧多放几个篮子，其实就是kafka的扩容。<br>各位现在知道kafka是干什么的了吧，它就是那个&quot;篮子&quot;。</p>

          <h3>
            <a name="_root-kafka名词解释" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            kafka名词解释
          </h3><p>后面大家会看到一些关于kafka的名词，比如topic、producer、consumer、broker，我这边来简单说明一下。</p>
<ul>
<li><code>producer</code>：生产者，就是它来生产“鸡蛋”的。</li>
<li><code>consumer</code>：消费者，生出的“鸡蛋”它来消费。</li>
<li><code>topic</code>：你把它理解为标签，生产者每生产出来一个鸡蛋就贴上一个标签（topic），消费者可不是谁生产的“鸡蛋”都吃的，这样不同的生产者生产出来的“鸡蛋”，消费者就可以选择性的“吃”了。</li>
<li><code>broker</code>：就是篮子了。</li>
</ul>
<p>大家一定要学会抽象的去思考，上面只是属于业务的角度，如果从技术角度，topic标签实际就是队列，生产者把所有“鸡蛋（消息）”都放到对应的队列里了，消费者到指定的队列里取。</p>

          <h3>
            <a name="_root-Kafka作为一个分布式的流平台，这到底意味着什么？" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Kafka作为一个分布式的流平台，这到底意味着什么？
          </h3><p>我们认为，一个流处理平台具有三个关键能力：</p>
<ol>
<li>发布和订阅消息（流），在这方面，它类似于一个消息队列或企业消息系统。</li>
<li>以<code>容错</code>的方式存储消息（流）。</li>
<li>在消息流发生时处理它们。</li>
</ol>

          <h4>
            <a name="_root-什么是kakfa的优势？" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            什么是kakfa的优势？
          </h4><p>它应用于2大类应用：</p>
<ol>
<li>构建实时的流数据管道，可靠地获取系统和应用程序之间的数据。</li>
<li>构建实时流的应用程序，对数据流进行转换或反应。</li>
</ol>
<p>要了解kafka是如何做这些事情的，让我们从下到上深入探讨kafka的能力。</p>

          <h4>
            <a name="_root-首先几个概念：" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            首先几个概念：
          </h4><ol>
<li>kafka作为一个集群运行在一个或多个服务器上。</li>
<li>kafka集群存储的消息是以topic为类别记录的。</li>
<li>每个消息（也叫记录<strong>record</strong>，我习惯叫消息）是由一个key，一个value和时间戳构成。</li>
</ol>

          <h4>
            <a name="_root-kafka有四个核心API：" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            kafka有四个核心API：
          </h4><ul>
<li>应用程序使用 <code>Producer API</code> 发布消息到1个或多个topic（主题）。</li>
<li>应用程序使用 <code>Consumer API</code> 来订阅一个或多个topic，并处理产生的消息。</li>
<li>应用程序使用 <code>Streams API</code> 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。</li>
<li><code>Connector API</code>允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。</li>
</ul>
<p><img src="http://kafka.apache.org/20/images/kafka-apis.png" alt="img"></p>
<p>Client和Server之间的通讯，是通过一条简单、高性能并且和开发语言无关的<a href="https://kafka.apache.org/protocol.html">TCP协议</a>。并且该协议保持与老版本的兼容。Kafka提供了Java Client（客户端）。除了Java Client外，还有非常多的<a href="https://cwiki.apache.org/confluence/display/KAFKA/Clients">其它编程语言的Client</a>。</p>

          <h3>
            <a name="_root-首先来了解一下Kafka所使用的基本术语：" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            首先来了解一下Kafka所使用的基本术语：
          </h3>
          <h4>
            <a name="_root-Topic" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Topic
          </h4><p>Kafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic).</p>

          <h4>
            <a name="_root-Producer" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Producer
          </h4><p>发布消息的对象称之为主题生产者(Kafka topic producer)</p>

          <h4>
            <a name="_root-Consumer" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Consumer
          </h4><p>订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)</p>

          <h4>
            <a name="_root-Broker" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Broker
          </h4><p>已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p>

          <h3>
            <a name="_root-主题和日志  (Topic和Log)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            主题和日志  (Topic和Log)
          </h3><p>让我们更深入的了解Kafka中的Topic。</p>
<p>Topic是发布的消息的类别或者种子Feed名。对于每一个Topic，Kafka集群维护这一个分区（partition）的log，就像下图中的示例：</p>
<p><img src="http://kafka.apache.org/20/images/log_anatomy.png" alt="img"></p>
<p>每一个分区（partition）都是一个顺序的、不可变的消息队列， 并且可以持续的添加。分区（partition）中的消息都被分了一个序列号，称之为偏移量(offset)，在每个分区（partition）中此偏移量都是唯一的。</p>
<p>Kafka集群保持所有的消息，直到它们过期， 无论消息是否被消费了。 实际上消费者所持有的仅有的元数据就是这个偏移量，也就是消费者在这个log中的位置。 这个偏移量由消费者控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更老的一个偏移量，重新读取消息。 可以看到这种设计对消费者来说操作自如， 一个消费者的操作不会影响其它消费者对此log的处理。 再说说分区（partition）。Kafka中采用分区（partition）的设计有几个目的。一是可以处理更多的消息，不受单台服务器的限制。Topic拥有多个分区（partition）意味着它可以不受限的处理更多的数据。第二，分区（partition）可以作为并行处理的单元，稍后会谈到这一点。<br><img src="http://kafka.apache.org/20/images/log_consumer.png" alt="img"></p>

          <h3>
            <a name="_root-分布式(Distribution)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            分布式(Distribution)
          </h3><p>Log的分区（partition）被分布到集群中的多个服务器上。每个服务器处理它分到的分区（partition）。 根据配置每个分区（partition）还可以复制到其它服务器作为备份容错。 每个分区（partition）有一个leader，零或多个follower。Leader处理此分区（partition）的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区（partition）的leader，另一个分区（partition）的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。</p>

          <h3>
            <a name="_root-Geo-Replication(异地数据同步技术)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Geo-Replication(异地数据同步技术)
          </h3><p><strong>Kafka MirrorMaker</strong>为群集提供<code>geo-replication</code>支持。借助<code>MirrorMaker</code>，消息可以跨多个数据中心或云区域进行复制。 您可以在active/passive场景中用于备份和恢复; 或者在active/passive方案中将数据置于更接近用户的位置，或数据本地化。</p>

          <h3>
            <a name="_root-生产者(Producers)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            生产者(Producers)
          </h3><p>生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区（partition）。最简单的方式从分区（partition）列表中轮流选择。也可以根据某种算法依照权重选择分区（partition）。开发者负责如何选择分区（partition）的算法。</p>

          <h3>
            <a name="_root-消费者(Consumers)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            消费者(Consumers)
          </h3><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：<br><img src="http://kafka.apache.org/20/images/consumer-groups.png" alt="img"></p>
<p>2个kafka集群托管4个分区（partition）（P0-P3），2个消费者组，消费组A有2个消费者实例，消费组B有4个。</p>
<p>正像传统的消息系统一样，Kafka保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上Kafka做的更好，尽管并没有完全解决上述问题。 Kafka采用了一种分而治之的策略：分区（partition）。 因为Topic分区（partition）中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区（partition）顺序处理，不能保证跨分区（partition）的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区（partition）。</p>

          <h3>
            <a name="_root-Kafka的保证(Guarantees)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Kafka的保证(Guarantees)
          </h3><ul>
<li>生产者发送到一个特定的Topic的分区（partition）上，消息将会按照它们发送的顺序依次加入，也就是说，如果一个消息M1和M2使用相同的producer发送，M1先发送，那么M1将比M2的offset低，并且优先的出现在日志中。</li>
<li>消费者收到的消息也是此顺序。</li>
<li>如果一个Topic配置了复制因子（replication factor）为N， 那么可以允许N-1服务器宕机而不丢失任何已经提交（committed）的消息。</li>
</ul>
<p>有关这些保证的更多详细信息，请参见文档的设计部分。</p>

          <h3>
            <a name="_root-kafka作为一个消息系统" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            kafka作为一个消息系统
          </h3>
          <h4>
            <a name="_root-Kafka的流与传统企业消息系统相比的概念如何？" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Kafka的流与传统企业消息系统相比的概念如何？
          </h4><p>传统的消息有两种模式：<code>队列</code>和<code>发布订阅</code>。 在队列模式中，消费者池从服务器读取消息（每个消息只被其中一个读取）; 发布订阅模式：消息广播给所有的消费者。这两种模式都有优缺点，队列的优点是允许多个消费者瓜分处理数据，这样可以扩展处理。但是，队列不像多个订阅者，一旦消息者进程读取后故障了，那么消息就丢了。而<code>发布和订阅</code>允许你广播数据到多个消费者，由于每个订阅者都订阅了消息，所以没办法缩放处理。</p>
<p>kafka中消费者组有两个概念：<code>队列</code>：消费者组（consumer group）允许同名的消费者组成员瓜分处理。<code>发布订阅</code>：允许你广播消息给多个消费者组（不同名）。</p>
<p>kafka的每个topic都具有这两种模式。</p>

          <h4>
            <a name="_root-kafka有比传统的消息系统更强的顺序保证。" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            kafka有比传统的消息系统更强的顺序保证。
          </h4><p>传统的消息系统按顺序保存数据，如果多个消费者从队列消费，则服务器按存储的顺序发送消息，但是，尽管服务器按顺序发送，消息异步传递到消费者，因此消息可能乱序到达消费者。这意味着消息存在并行消费的情况，顺序就无法保证。消息系统常常通过仅设1个消费者来解决这个问题，但是这意味着没用到并行处理。</p>
<p>kafka做的更好。通过并行topic的parition —— kafka提供了顺序保证和负载均衡。每个partition仅由同一个消费者组中的一个消费者消费到。并确保消费者是该partition的唯一消费者，并按顺序消费数据。每个topic有多个分区（partition），则需要对多个消费者做负载均衡，但请注意，<code>相同的消费者组中不能有比分区（partition）更多的消费者，否则多出的消费者一直处于空等待，不会收到消息</code>。</p>

          <h3>
            <a name="_root-kafka作为一个存储系统" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            kafka作为一个存储系统
          </h3><p>所有发布消息到<code>消息队列</code>和消费分离的系统，实际上都充当了一个存储系统（发布的消息先存储起来）。Kafka比别的系统的优势是它是一个非常高性能的<code>存储系统</code>。</p>
<p>写入到kafka的数据将写到磁盘并复制到集群中保证容错性。并允许生产者等待消息应答，直到消息完全写入。</p>
<p>kafka的磁盘结构 - 无论你服务器上有50KB或50TB，执行是相同的。</p>
<p>client来控制读取数据的位置。你还可以认为kafka是一种专用于高性能，低延迟，提交日志存储，复制，和传播特殊用途的<code>分布式文件系统</code>。</p>

          <h3>
            <a name="_root-kafka的流处理" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            kafka的流处理
          </h3><p>仅仅读，写和存储是不够的，kafka的目标是实时的流处理。</p>
<p>在kafka中，流处理持续获取<code>输入topic</code>的数据，进行处理加工，然后写入<code>输出topic</code>。例如，一个零售APP，接收销售和出货的<code>输入流</code>，统计数量或调整价格后输出。</p>
<p>可以直接使用producer和consumer API进行简单的处理。对于复杂的转换，Kafka提供了更强大的Streams API。可构建<code>聚合计算</code>或<code>连接流到一起</code>的复杂应用程序。</p>
<p>此工具有助于解决此类应用程序面临的难题：处理无序数据，在代码更改时重新处理输入，执行有状态计算等。</p>
<p>Sterams API在Kafka中的核心：使用producer和consumer API作为输入，利用Kafka做状态存储，使用相同的<strong>组机制（group mechanism）</strong>在stream处理器实例之间进行容错保障。</p>

          <h3>
            <a name="_root-拼在一起" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            拼在一起
          </h3><p>消息传递，存储和流处理的组合看似反常，但对于Kafka作为流式处理平台的作用至关重要。</p>
<p>像HDFS这样的分布式文件系统允许存储静态文件来进行批处理。这样系统可以有效地存储和处理来自过去的历史数据。</p>
<p>传统企业的消息系统允许在你订阅之后处理未来的消息：在未来数据到达时处理它。</p>
<p>Kafka结合了这两种能力，这种组合对于kafka作为流处理应用和流数据管道平台是至关重要的。</p>
<p>批处理以及消息驱动应用程序的流处理的概念：通过组合存储和低延迟订阅，流处理应用可以用相同的方式对待过去和未来的数据。它是一个单一的应用程序，它可以处理历史的存储数据，当它处理到最后一个消息时，它进入等待未来的数据到达，而不是结束。</p>
<p>同样，对于流数据管道（pipeline），订阅实时事件的组合使得可以将Kafka用于非常低延迟的管道；但是，可靠地存储数据的能力使得它可以将其用于必须保证传递的关键数据，或与仅定期加载数据或长时间维护的离线系统集成在一起。流处理可以在数据到达时转换它。</p>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>