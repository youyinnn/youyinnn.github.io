<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script>
        if (location.hostname === 'youyinnn.github.io') {
            var xmlhttp = new XMLHttpRequest();
            xmlhttp.onreadystatechange = function() {
                if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                    if (xmlhttp.responseText.search('CHINA') > 0) {
                        location.href = 'https://youyinnn.gitee.io' + location.pathname
                    }
                }
            }
            xmlhttp.open("GET", "https://pv.sohu.com/cityjson?ie=utf-8", true);
            xmlhttp.send();
        }
    </script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
    <script>
        importJsBeforeLoad()
    </script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn" type="button" title="clear search">cls</button>
                <button id="categories" class="btn" type="button">cates</button>
                <button id="tags" class="btn" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-Introduction" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Introduction
          </h3><p>我们对Lock和AQS有了一定的了解了之后，可以尝试着接触一些Lock+AQS的基本实现了，本篇会了解到最基本的同步组件<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>，前者提供了排他锁的实现，并且支持重入，后者在前者的基础上，支持锁的分级，写锁排他读锁共享。特别的，重入锁的获取还有公平和非公平之分，我们先从这部分入手。</p>

          <h4>
            <a name="_root-Fair Lock &amp; Nonfair Lock" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Fair Lock &amp; Nonfair Lock
          </h4><p>公平锁：锁的获取次序和请求锁的时间顺序一致，即在绝对的时间里，等待时间越久的线程越先获取到锁。</p>
<p>非公平锁：锁的获取和瞬间的竞争有关，一瞬间谁运气好就能获取到锁，而且锁的获取即同步状态的获取，刚获取到同步状态的线程，再次获取到状态的机会比较大。</p>
<p>说明：虽然非公平锁可能会造成“饥饿”情况，但是大多数情况下还是非公平锁用的多，因为公平锁在释放锁又再获取锁的时候，总是会<strong>切换线程</strong>，而非公平锁一段时间内很可能总是那一个线程不停放锁持锁，<strong>线程切换的开销小就意味着——吞吐量大</strong></p>
<p>再说多一点，公平性和非公平性是<strong>“针对未入队结点”</strong>和<strong>“已入队结点”</strong>而言，上一篇文章已经提到过，队列中的结点都是公平获取锁的，遵从FIFO，至于具体的体现，继续往下读，读到FairSync的<code>tryAcquire</code>和<code>hasQueuedPredecessors</code>方法就知道了</p>

          <h4>
            <a name="_root-ReentrantLock" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            ReentrantLock
          </h4><p>重入锁可以通过构造器来决定公平机制，默认是非公平锁：</p>
<pre><code class="language-java">/**
 * Creates an instance of {@code ReentrantLock}.
 * This is equivalent to using {@code ReentrantLock(false)}.
 */
public ReentrantLock() {
    sync = new NonfairSync();
}

/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}</code></pre>
<p>ReentrantLock中有3个简单的内部类，<code>FairSync</code>/<code>NonfairSync</code>以及<code>Sync</code>，后者是前两个的父类，</p>
<pre><code class="language-java">/**
 * Base of synchronization control for this lock. Subclassed
 * into fair and nonfair versions below. Uses AQS state to
 * represent the number of holds on the lock.
 */
abstract static class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = -5179523762034025860L;

    /**
     * Performs {@link Lock#lock}. The main reason for subclassing
     * is to allow fast path for nonfair version.
     */
    abstract void lock();

    /**
     * Performs non-fair tryLock.  tryAcquire is implemented in
     * subclasses, but both need nonfair try for trylock method.
     */
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0) // overflow
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }

    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }

    // other method..
}</code></pre>
<p>一个抽象的lock方法，以及一个非公平的<code>tryAcquire</code>和<code>tryRelease</code>，可以在这看到，在重入锁中：<strong>state代表占锁的线程重入次数（用层数应该更好理解）</strong></p>
<p>观察<code>nonfairTryAcquire</code>方法，当state为0的时候，代表没有线程获取到锁，但是同时可能有多个线程在竞争同步状态，所以使用CAS来设置state，设置成功的线程会设置AQS的独占线程为当前线程，此时state为1；下次再来的时候，如果是自己获取自己，那么现在的state加上aquire数量，设置为新的state，并且此时没有竞争，所以常规设置state即可；</p>
<p>观察<code>tryRelease</code>方法，如果不是持锁线程掉用的话，则什么都不干，否则现在的state减去releases数量，直到为0的时候，才移除AQS的独占线程；</p>
<p>再来看看<code>NonfairSync</code></p>
<pre><code class="language-java">/**
 * Sync object for non-fair locks
 */
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    /**
     * Performs lock.  Try immediate barge, backing up to normal
     * acquire on failure.
     */
    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}</code></pre>
<p>非常简单的实现，并且在<code>lock</code>方法中会尝试一次快速地获取同步状态，获取到就贼赚，获取不到就乖乖<code>acquire</code> 去，<code>tryAcquire</code>则是直接调用父类提供的非公平<code>nonfairTryAcquire</code></p>
<p>最后是<code>FairSync</code></p>
<pre><code class="language-java">/**
 * Sync object for fair locks
 */
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);
    }

    /**
     * Fair version of tryAcquire.  Don&#39;t grant access unless
     * recursive call or no waiters or is first.
     */
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
}</code></pre>
<p>我们只需要注意到，它的<code>tryAcquire</code>方法和父类的非公平获取几乎如出一撤，仅是在CAS竞争之前，先要判断一下当前线程所在队列中的结点是否有前驱（<code>hasQueuedPredecessors</code>），如果没有就可以开始CAS获取，保证总是最早入队的结点有权获取同步状态；</p>
<p>我们再深入一下<code>hasQueuedPredcessors</code></p>
<pre><code class="language-java">public final boolean hasQueuedPredecessors() {
    // The correctness of this depends on head being initialized
    // before tail and on head.next being accurate if the current
    // thread is first in queue.
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &amp;&amp;
        ((s = h.next) == null || s.thread != Thread.currentThread());
}</code></pre>
<p>判断head是否等于tail：</p>
<ol>
<li><p>若等于，则条件结束，方法返回fasle</p>
<blockquote>
<p>等于的含义有2层，一是队列里没有任何结点的时候，head=tail=null，这时候方法返回false，代表进入方法的线程是整个系统第一次访问该锁的线程，则可以获取同步状态；</p>
<p>二是队列中只有一个结点，这个结点即是head又是tail；</p>
</blockquote>
</li>
<li><p>若不等于，则看head是否有后继：</p>
<ol>
<li>若没有后继，则条件结束，方法返回true，回到上层方法，<code>tryAcquire</code>返回false；</li>
<li>若有后继，如果head的后继不是当前线程的话，方法返回true，回到上层方法，<code>tryAcquire</code>返回false；</li>
<li>若有后继，且head后继是当前线程，则方法返回false，回到上层方法，当前线程可以尝试获取同步状态；</li>
</ol>
</li>
</ol>

          <h5>
            <a name="_root-Real meaning of &quot;fair&quot;" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Real meaning of &quot;fair&quot;
          </h5><p>读完上面的方法之后，接下来这句话非常重要：为什么之前说，公平性和非公平性是<strong>“针对未入队结点”</strong>和<strong>“已入队结点”</strong>而言？因为<strong>已入队的结点之间不存在竞争</strong>，竞争仅仅是队列前几个结点和未入队的新线程而言：</p>
<ul>
<li>如果是公平锁，未入队的新线程在<code>hasQueuePredecessors</code>方法之后，肯定是false，导致<code>tryAcquire</code>方法必定返回false，导致这个新线程必定组成结点然后入队排队，<strong>即不入队的线程没有参与同步资源竞争的权利</strong>；</li>
<li>如果是非公平锁，未入队的新线程有机会和已入队的一起竞争同步资源；所以才叫非公平！</li>
</ul>
<p>所以不要误解非公平锁的情况下，后排队的结点线程也能很<strong>“不公平”</strong>地比先排队的结点线程先获得同步状态，这是不可能的；</p>

          <h4>
            <a name="_root-ReentrantReadWriteLock" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            ReentrantReadWriteLock
          </h4><p>在Lock接口之前，我们使用等待通知的设计机制可以简单地实现一个读写场景，当写操作开始的时候，所有后续读写操作都进入等待，写操作完成之后，通知唤醒等待线程；基于这样的逻辑，才能避免脏读</p>
<p>所以读写锁的基本思想是：<strong>写锁的优先度高于读锁，可以多读，只能单写；</strong></p>
<p><strong>换句话说，写锁是独占锁，读锁是共享锁</strong></p>
<p>使用读写锁的时候，只需要在读操作的时候获取读锁，写操作的时候获取写锁就可以了，比<code>synchronized</code>关键字加等待通知方法更加简单明了</p>
<p><code>ReentrantReadWirteLock</code>是读写锁的一种，其特性如：</p>
<ul>
<li>可重入</li>
<li>公平性选择</li>
<li>遵循获取写锁、获取读锁再释放写锁的顺序，写锁可降级</li>
</ul>
<p>另外它还提供了外部监控内部锁状态的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>int getReadLockCount()</code></td>
<td><strong>返回当前读锁被获取到的次数</strong>，该次数不等于获取读锁的线程数，比如仅一个线程连续重入了n次，则返回n；该方法会返回<strong>所有线程持有的当前读锁的层数</strong>，比如线程A获取3次，释放1次，线程B获取5次释放2次，则该方法会返回3-1+5-2=<strong>5层</strong>；</td>
</tr>
<tr>
<td><code>int getReadHoldCount()</code></td>
<td><strong>返回当前线程获取到读锁的次数</strong>，该方法在Java6之后加入，通过<strong>ThreadLocal</strong>实现；该方法返回<strong>当前线程持有该锁的层数</strong>，比如线程A获取该锁5次释放<strong>2层</strong>，则在A锁该方法返回3，同时B线程获取该锁4次释放4次，则在B线程该方法返回<strong>0层</strong>；</td>
</tr>
<tr>
<td><code>boolean isWirteLocked()</code></td>
<td><strong>判断写锁是否被获取到；</strong></td>
</tr>
<tr>
<td><code>int getWriteHoldCount()</code></td>
<td><strong>判断当前写锁被获取的次数；</strong></td>
</tr>
</tbody></table>

          <h5>
            <a name="_root-Read Write State Design" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Read Write State Design
          </h5><p>我们来思考一下，对于一个读写锁来说，它应当将读写分离为2把锁，但是读写锁的排队应该排在同一队，所以读写锁的AQS应该是同一个实例，所以问题来了，如何在一个AQS实例上的一个state变量中表示读与写两种同步状态？老爷子给出了这样的答案：</p>
<pre class="nhi">
    int value
    |&lt;-----------------------------32------------------------------&gt;|
    ┌---------------------------------------------------------------┐
    |0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|
    └---------------------------------------------------------------┘
                    |                                 ↓
                    |                ┌-------------------------------┐
                    ↓                |0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|
    ┌-------------------------------┐└-------------------------------┘
    |0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|               低16位表示写状态 = 3
    └-------------------------------┘
                   高16位表示读状态 = 2
</pre>

<p>通过位运算，假设当前同步状态值为S，那么写状态就等于S &amp; 0x0000FFFF（高16位清零），读状态等于S &gt;&gt;&gt; 16（无符号补位0右移16位）</p>
<p>当写状态要增加1的时候，直接S + 1，当读状态要增加1的是，直接S + 0x00010000就行</p>

          <h5>
            <a name="_root-Structure" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Structure
          </h5><pre><code class="language-java">public class ReentrantReadWriteLock
        implements ReadWriteLock, java.io.Serializable {

    private final ReentrantReadWriteLock.ReadLock readerLock;
    private final ReentrantReadWriteLock.WriteLock writerLock;
    final Sync sync;

    public ReentrantReadWriteLock() {this(false);}
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }

    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }

    // ...
}</code></pre>
<p>这是重入读写锁的整体结构，可以看到ReentrantReadWriteLock仅仅只是实现了ReadWriteLock接口而已，这个接口仅定义了获取ReadLock和WriteLock的方法，真正的锁实现是<code>ReentrantReadWriteLock.ReadLock</code>和<code>ReentrantReadWriteLock.WriteLock</code>，而这两个锁实现，用的是同一个<code>Sync</code>实例，<code>Sync</code>实例即实现了AQS的公平锁或者非公平锁</p>

          <h5>
            <a name="_root-Fair &amp; NonFair" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Fair &amp; NonFair
          </h5><p>我们先来看非公平锁和公平锁的实现：</p>
<pre><code class="language-java">static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -8159625535654395037L;
    final boolean writerShouldBlock() {
        return false; // writers can always barge
    }
    final boolean readerShouldBlock() {
        return apparentlyFirstQueuedIsExclusive();
    }
}

static final class FairSync extends Sync {
    private static final long serialVersionUID = -2274990926593161451L;
    final boolean writerShouldBlock() {return hasQueuedPredecessors();}
    final boolean readerShouldBlock() {return hasQueuedPredecessors();}
}</code></pre>
<p>读写锁中的公平性主要体现在是否要阻塞读写线程这方面，对于公平锁而言，无论读写线程，都要判断<code>hasQueeudPredecessors</code>这个方法我们上面讲过了，关键是非公平锁，对于写锁是否应该block来说，它总是不应该被block住，而读锁则需要判断<code>apparentlyFirstQueuedIsExclusive</code>方法，</p>
<pre><code class="language-java">final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null &amp;&amp;
        (s = h.next)  != null &amp;&amp;
        !s.isShared()         &amp;&amp;
        s.thread != null;
}</code></pre>
<p>如果队列中的第一个等待结点明显是是独占式锁的结点的话，就返回true，两个方法连起来的意思是，如果队列中的第一个结点是写锁（独占锁）的话，读锁应该被Block住</p>

          <h5>
            <a name="_root-Sync in ReentrantReadWriteLock" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Sync in ReentrantReadWriteLock
          </h5><pre><code class="language-java">abstract static class Sync extends AbstractQueuedSynchronizer {
    static final int SHARED_SHIFT   = 16;
    static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);
    static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;
    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;

    static int sharedCount(int c)    { return c &gt;&gt;&gt; SHARED_SHIFT; }
    static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }

    Sync() {
        readHolds = new ThreadLocalHoldCounter();
        setState(getState()); // ensures visibility of readHolds
    }

    abstract boolean readerShouldBlock();
    abstract boolean writerShouldBlock();

    // .. HolderCounter 相关方法暂时略

    protected final boolean tryRelease(int releases) { 
        // .. 
    }
    protected final boolean tryAcquire(int acquires) {
        // ..
    }
    protected final boolean tryReleaseShared(int unused) {
        // ..
    }
    protected final int tryAcquireShared(int unused) {
        // ..
    }
    final int fullTryAcquireShared(Thread current) {
        // ..
    }
    final boolean tryWriteLock() {
        // ..
    }
    final boolean tryReadLock() {
        // ..
    }

    // .. 锁状态 相关方法暂时略

    final int getCount() { return getState(); }
}</code></pre>
<p>重入读写锁中的<code>Sync</code>类提供的功能比较多，它同时实现了读锁和写锁的管理操作，我们先分析这部分，略去的部分我在注释中说明了</p>
<p>读写状态的管理就是通过位运算去实现的，读写锁的层数也是通过位运算state变量算出来的，这里不再赘述；写锁的tryRelease方法和<code>ReentrantLock</code>基本一致；</p>
<p>我们接着看写锁的try：</p>
<pre><code class="language-java">protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}</code></pre>
<p>老爷子特地写下了一段WalkThrough注释，指出了本方法要处理的情况：</p>
<ol>
<li>如果读写状态都不为零，且当前线程不是该AQS的独占线程，则不能获取写锁；</li>
<li>如果状态满值了，也获取不了写锁；</li>
<li>如果不是上面2种情况，则该线程应该在公平性的指导下<code>writerShouldBlock</code>合法竞争独占锁；</li>
</ol>
<p>再来看读锁的，再看读锁之前，我们要了解一下<code>Sync</code>的几个变量和类：</p>
<pre><code class="language-java">static final class HoldCounter {
    int count = 0;
    // Use id, not reference, to avoid garbage retention
    final long tid = getThreadId(Thread.currentThread());
}

static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; {
    public HoldCounter initialValue() {return new HoldCounter();}
}

private transient ThreadLocalHoldCounter readHolds;

private transient HoldCounter cachedHoldCounter;

private transient Thread firstReader = null;
private transient int firstReaderHoldCount;</code></pre>
<p>有一个<code>HoldCounter</code>类，用于存储每个线程自己的读层数，然后通过ThreadLocal来管理</p>
<ul>
<li><code>readHolds</code>：一个ThreadLocal实例，保存了所有读线程的HoldCounter</li>
<li><code>cachedHoldCounter</code>：表示最后一个成功acquire到readLock的线程的holdCount</li>
<li><code>firstReader</code>：是第一个acquire到读锁的线程</li>
<li><code>firstReaderHoldCount</code>：是<code>firstReader</code>的holdCount</li>
</ul>
<p>然后是读try：</p>
<pre><code class="language-java">protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    int r = sharedCount(c);
    if (!readerShouldBlock() &amp;&amp;
        r &lt; MAX_COUNT &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}</code></pre>
<p>WalkThrough：</p>
<ol>
<li>如果写锁被其它线程获取了，则不能获取读锁；</li>
<li>否则就在公平性的指导下<code>writerShouldBlock</code>，如果允许竞争，则判断是否超量读，如果没超量，则尝试CAS设置读状态，这三个条件过了之后，line:11~line:24是快速地进行tryAcquireShared，它并没有检查重入情况下的acquire，所以它将完整地holdCount检查等工作推迟到了<code>fullTryAcquireShared</code>中去了，因为典型的情况下都是非重入地使用；</li>
<li>如果前2步都不对，那么就开始完整的<code>fullTryAcquireShared</code>，它将会处理之前的CAS失败，已经第二步没有处理好的读重入的情况；</li>
</ol>
<p>关于<code>fullTryAcquireShared</code>的更详细的逻辑，我觉得比较复杂，不太想深究，到此为止</p>
<p>最后回到<code>Sync</code>类最后2个方法：</p>
<ul>
<li><code>tryWriteLock</code>：和<code>tryAcquire</code>相比仅仅少了<code>writerShouldBlock</code></li>
<li><code>tryReadLock</code>：和<code>tryAcquire</code>相比仅仅少了<code>readerShouldBlock</code></li>
</ul>

          <h5>
            <a name="_root-ReadLock &amp; WriteLock in ReentrantReadWirteLock" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            ReadLock &amp; WriteLock in ReentrantReadWirteLock
          </h5><p>大致读下了上面的<code>Sync</code>之后，剩下的<code>ReadLock</code>&amp; <code>WriteLock</code>其实就很简单了</p>
<pre><code class="language-java">public static class ReadLock implements Lock, java.io.Serializable {
    private final Sync sync;
    protected ReadLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    public void lock() {sync.acquireShared(1);}
    public boolean tryLock() {return sync.tryReadLock();}
    public void unlock() {sync.releaseShared(1);}

    // 其余release、中断acquire、超时、状态相关方法略
}

public static class WriteLock implements Lock, java.io.Serializable {
    private final Sync sync;
    protected WriteLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    public void lock() {sync.acquire(1);}
    public boolean tryLock() {return sync.tryWriteLock();}
    public void unlock() {sync.release(1);}

    // 其余release、中断acquire、超时、状态相关方法略
}</code></pre>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

    <script>
        importJsAfterLoad()
    </script>
</body>

</html>