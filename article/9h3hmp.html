<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script>
        if (location.hostname === 'youyinnn.github.io') {
            var xmlhttp = new XMLHttpRequest();
            xmlhttp.onreadystatechange = function() {
                if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                    if (xmlhttp.responseText.search('CHINA') > 0) {
                        location.href = 'https://youyinnn.gitee.io' + location.pathname
                    }
                }
            }
            xmlhttp.open("GET", "https://pv.sohu.com/cityjson?ie=utf-8", true);
            xmlhttp.send();
        }
    </script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
    <script>
        importJsBeforeLoad()
    </script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn" type="button" title="clear search">cls</button>
                <button id="categories" class="btn" type="button">cates</button>
                <button id="tags" class="btn" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-前言" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            前言
          </h3><p>我</p>
<p>面试（大约两个月前）</p>
<p>被问线程安全单例</p>
<p>实际上写得出</p>
<p>只是不知道可以这样写</p>
<p>所以没答好- -</p>
<p>回来一看</p>
<p>可以答</p>
<p>耻辱</p>
<p>说明：本篇代码大部分引自：<a href="https://github.com/iluwatar/java-design-patterns">https://github.com/iluwatar/java-design-patterns</a> </p>
<hr>

          <h3>
            <a name="_root-Singleton" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Singleton
          </h3><p>单例模式（Singleton）算是工厂模式的一种特例，你不需要给出任何参数，就可以马上得到一个在任何地方都可以调用到的唯一的实例</p>
<p>第一次接触到单例，还是在1年多前学习spring的时候，在配置Bean的时候有单例多例配置</p>
<p>总的来说，一个实例，如果是用作工具类或者工具对象的话，那么它并不需要创建多个实例，我们就可以用单例的形式去获取这个对象</p>

          <h4>
            <a name="_root-HungryManStyle（thread safe）" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            HungryManStyle（thread safe）
          </h4><pre><code class="language-java">/**
 * 使用静态对象进行预加载来保证线程安全的
 * 一般我们称这样的单例为饿汉式单例 不管三七二十一 一旦加载这个类就创建对象
 * 一般是在第一次引用这个类的时候就加载这个类
 */
class Singleton{
    private Singleton(){}
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
}</code></pre>
<p>要说的话都在注释里了</p>

          <h4>
            <a name="_root-LazyManStyle" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            LazyManStyle
          </h4>
          <h5>
            <a name="_root-无锁（非线程安全）" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            无锁（非线程安全）
          </h5><pre><code class="language-java">public class Singleton {
    private Singleton(){}
    private static final Singleton INSTANCE;
    public static Singleton getInstance(){
        if (INSTANCE == null) {
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }
}</code></pre>
<p>这种是最基本的单例</p>
<ul>
<li>私有无参构造方法保证外部引用不可以new一个对象</li>
<li>判断是否初始化了instance变量 始终只返会同一个对象</li>
</ul>
<p>但是这种单例只能在单线程的情况下正常工作，在多线程的情况下，如果多个线程同一时刻在line5处判断实例变量不为空，那么就可能有多个线程同时执行line6，在这个时间，会有大量的实例挤破头得被instance引用，这样会造成资源浪费</p>

          <h5>
            <a name="_root-简单Synchronized上锁（线程安全）" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            简单Synchronized上锁（线程安全）
          </h5><pre><code class="language-java">public class Singleton{
    private Singleton(){}
    private static final Singletion INSTANCE;
    public static synchronized Singleton getInstance(){
        if (INSTANCE == null) {
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }
}

// 另外一种写法
public static Singleton getInstance(){
    synchronized(Singleton.class) {
        if (INSTANCE == null) {
            INSTANCE = new Singleton();
        }
    }
    return INSTANCE;
}</code></pre>
<p>优点，比上面那种安全，缺点，获取对象的时候资源浪费，我们上锁的目的只是<strong>防止最开始在实例未被初始化的时候，被多线程访问导致line5判断异常</strong>，往后在实例被创建好了之后，并不需要防止多线程同时访问，每次调用方法都加锁只会增加无意义的消耗，我称这个为<strong>“无意义锁”</strong></p>
<p>这种实现不可取</p>

          <h5>
            <a name="_root-想当然的双重检查锁（非线程安全）" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            想当然的双重检查锁（非线程安全）
          </h5><pre><code class="language-java">public class Singleton{
    private Singleton(){}
    private static final Singletion INSTANCE;
    public static Singleton getInstance(){
        if (INSTANCE == null) {
            synchronized(Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}</code></pre>
<p>这个实现，看似可以避免<strong>无意义锁</strong>的问题，但是line8可能会因为某单线程的重排序导致其他线程对该实例的可见性问题，对于双重检查锁的错误，在系列文章《并发编程第六坎》中可以看到，这里不再赘述</p>
<p>基于双重检查锁的解决方案，给出两种比较标准的实现：</p>

          <h5>
            <a name="_root-基于内部类和类加载机制的——Initialization On Demand Holder Idiom" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            基于内部类和类加载机制的——Initialization On Demand Holder Idiom
          </h5><pre><code class="language-java">public final class InitializingOnDemandHolderIdiom {
    private InitializingOnDemandHolderIdiom(){}
    public static InitializingOnDemandHolderIdiom getInstance() {
        return HelperHolder.INSTANCE;
    }
    private static class HelperHolder {
        private static final InitializingOnDemandHolderIdiom INSTANCE = 
            new InitializingOnDemandHolderIdiom();
    }
}</code></pre>
<p>这个实现的好处就是，它可以在既可以保证线程安全和懒加载，又可以适应所有的JDK版本，比如我们下面的实现用到了volatile变量，就需要JDK1.5以上的支持</p>
<blockquote>
<p> 参考：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom">https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom</a> </li>
<li><a href="http://ifeve.com/initialization-on-demand-holder-idiom/">http://ifeve.com/initialization-on-demand-holder-idiom/</a></li>
<li><a href="https://www.cnblogs.com/fuyoucaoyu/p/6547715.html">https://www.cnblogs.com/fuyoucaoyu/p/6547715.html</a></li>
</ul>
</blockquote>
<p>在这里我们多接触了一个概念——<strong>初始化锁LC锁</strong>，具体的介绍可以看第六坎</p>

          <h5>
            <a name="_root-基于volatile变量的——线程安全的双重检查锁" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            基于volatile变量的——线程安全的双重检查锁
          </h5><pre><code class="language-java">public final class ThreadSafeDoubleCheckLocking {
  private static volatile ThreadSafeDoubleCheckLocking instance;
  private ThreadSafeDoubleCheckLocking() {
    // 防止被反射实例化
    if (instance != null) {
      throw new IllegalStateException(&quot;Already initialized.&quot;);
    }
  }
  public static ThreadSafeDoubleCheckLocking getInstance() {
    // 这个本地变量会提高25%的性能 Joshua Bloch &quot;Effective Java, Second Edition&quot;, p. 283-284
    ThreadSafeDoubleCheckLocking result = instance;
    // 第一次检查 不为空直接返回
    if (result == null) {
      // 上锁同步初始化的过程
      synchronized (ThreadSafeDoubleCheckLocking.class) {
        // 再一次指派本地变量 用于检查是否有其他线程在当前线程被阻塞在锁外的时候已经完成初始化工作了
        // 如果已经完成了 那么可以直接返回结果
        result = instance;
        if (result == null) {
          // 在这个区域完全就是单线程访问了 完成初始化工作
          instance = result = new ThreadSafeDoubleCheckLocking();
        }
      }
    }
    return result;
  }
}</code></pre>
<p>关键是volatile的声明，原因见第六坎</p>

          <h5>
            <a name="_root-枚举法单例" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            枚举法单例
          </h5><pre><code class="language-java">public enum EnumSingleton {
  INSTANCE;
  @Override
  public String toString() {
    return getDeclaringClass().getCanonicalName() + &quot;@&quot; + hashCode();
  }
}</code></pre>
<p>也是利用枚举的特点，线程安全，简单、直接、省事、可用</p>
<p>单例的枚举实现在《Effective Java》中有提到，因为其<strong>功能完整、使用简洁、无偿地提供了序列化机制、在面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化</strong>等优点，单元素的枚举类型被作者认为是实现Singleton的最佳方法。 </p>
<p>具体可以参考：<a href="https://blog.csdn.net/gavin_dyson/article/details/70832185">https://blog.csdn.net/gavin_dyson/article/details/70832185</a></p>
<p>里面说了，为什么枚举类会有一次性锁的效果，其实枚举是一种语法糖，本质是上利用的还是静态特性，然后因为<strong>语法糖揪在一起（自创说法）</strong>的原因，序列化绝对安全</p>

          <h4>
            <a name="_root-总结" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            总结
          </h4><p>这么多单例，最好的实现无疑是最后三种，最后三种各自有各自的优点</p>
<ul>
<li><strong>静态内部类实现：</strong>所有版本通用，常规且有效</li>
<li><strong>volatile双重检查锁实现：</strong>只适用JDK1.5以上，正式切有效</li>
<li><strong>枚举法实现：</strong>蜜汁实现，简单暴力省事高效，但是不易理解其特性</li>
</ul>
<p>多提一句，饿汉式写法没有绝对的漏洞，只是如果你的实例内容如果多，占用空间大，而且没有一开始就需要伴随系统初始化的必要的话，有点浪费资源，其他也没差。</p>
<hr>

          <h3>
            <a name="_root-Observer/Dependents/Publisher-Subscriber" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Observer/Dependents/Publisher-Subscriber
          </h3><p>观察者模式意在建立一种一对多的关联关系，在这个关系中，任意其中一个对象发生了状态变化，其他对象都可以自动感知到这个变化。</p>
<p>观察者模式又称为：关联模式、发布者-订阅者模式</p>
<p>这样的关系很容易理解，就像电视台播报的天气预报一样，天气一变，气象台就会发送变动天气的短信给当地用户，武汉就一天至少2封高温预警的短信- -</p>
<p>我们首先来看</p>

          <h4>
            <a name="_root-Subject/Publisher" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Subject/Publisher
          </h4><pre><code class="language-java">/**
 * Weather对象可以被实现了观察者接口WeatherObserver并且在Weather对象这里注册为观察者的对象才能接受
 * 该Weather对象的发布内容
 */
public class Weather {
  private WeatherType currentWeather;
  private List&lt;WeatherObserver&gt; observers;
  public Weather() {
    observers = new ArrayList&lt;&gt;();
    currentWeather = WeatherType.SUNNY;
  }
  // 注册订阅者
  public void addObserver(WeatherObserver obs) {
    observers.add(obs);
  }
  // 注销订阅者
  public void removeObserver(WeatherObserver obs) {
    observers.remove(obs);
  }
  // 状态变更
  public void timePasses() {
    WeatherType[] enumValues = WeatherType.values();
    currentWeather = enumValues[(currentWeather.ordinal() + 1) % enumValues.length];
    notifyObservers();        // 通知
  }
  // 发布订阅到所有订阅者
  private void notifyObservers() {
    for (WeatherObserver obs : observers) {
      obs.update(currentWeather);
    }
  }
}
public enum WeatherType {
  SUNNY, RAINY, WINDY, COLD;
  @Override
  public String toString() {
    return this.name().toLowerCase();
  }
}</code></pre>

          <h4>
            <a name="_root-观察者接口" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            观察者接口
          </h4><pre><code class="language-java">public interface WeatherObserver {
  void update(WeatherType currentWeather);
}</code></pre>

          <h4>
            <a name="_root-Observer/Subscriber" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Observer/Subscriber
          </h4><pre><code class="language-java">public class Orcs implements WeatherObserver {
  @Override
  public void update(WeatherType currentWeather) {
    switch (currentWeather) {
      // 根据状态选择对应逻辑
    }
  }
}</code></pre>

          <h4>
            <a name="_root-Main" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Main
          </h4><pre><code class="language-java">  public static void main(String[] args) {
    Weather weather = new Weather();
    weather.addObserver(new Orcs());
    weather.timePasses();
    weather.timePasses();
    weather.timePasses();
    weather.timePasses();
  }</code></pre>

          <h4>
            <a name="_root-通用模板" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            通用模板
          </h4>
          <h5>
            <a name="_root-AbstractSubject" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            AbstractSubject
          </h5><pre><code class="language-java">/**
 * 基于泛型和集合框架的通用Subject模板
 * @param &lt;S&gt; Subject
 * @param &lt;O&gt; Observer
 * @param &lt;A&gt; Argument type
 */
public abstract class Observable&lt;
    S extends Observable&lt;S, O, A&gt;,
    O extends Observer&lt;S, O, A&gt;, 
    A&gt; {

  protected List&lt;O&gt; observers;
  public Observable() {
      this.observers = new CopyOnWriteArrayList&lt;&gt;();    // 线程安全的实现
  }
  public void addObserver(O observer) {
      this.observers.add(observer);
  }
  public void removeObserver(O observer) {
      this.observers.remove(observer);
  }
  public void notifyObservers(A argument) {
    for (O observer : observers) {
      observer.update((S) this, argument);
    }
  }
}</code></pre>

          <h5>
            <a name="_root-Observer-Interface" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Observer-Interface
          </h5><p>观察者接口的最顶层抽象接口</p>
<pre><code class="language-java">/**
 * Observer
 * @param &lt;S&gt; Observable
 * @param &lt;O&gt; Observer
 * @param &lt;A&gt; Action
 */
public interface Observer&lt;S extends Observable&lt;S, O, A&gt;, 
                          O extends Observer&lt;S, O, A&gt;, 
                          A&gt; {

  void update(S subject, A argument);
}</code></pre>

          <h5>
            <a name="_root-Observer-Generics-Map" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Observer-Generics-Map
          </h5><p>规定好泛型的观察者接口</p>
<pre><code class="language-java">public interface Race extends Observer&lt;GWeather, Race, WeatherType&gt; {
}</code></pre>

          <h5>
            <a name="_root-Subject-Implement" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Subject-Implement
          </h5><pre><code class="language-java">public class GWeather extends Observable&lt;GWeather, Race, WeatherType&gt; {
  private WeatherType currentWeather;
  public GWeather() {
    currentWeather = WeatherType.SUNNY;
  }
  // 状态变更
  public void timePasses() {
    WeatherType[] enumValues = WeatherType.values();
    currentWeather = enumValues[(currentWeather.ordinal() + 1) % enumValues.length];
    LOGGER.info(&quot;The weather changed to {}.&quot;, currentWeather);
    notifyObservers(currentWeather);  //通知
  }
}</code></pre>

          <h5>
            <a name="_root-Observer-implement" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Observer-implement
          </h5><pre><code class="language-java">public class GOrcs implements Race {

  @Override
  public void update(GWeather weather, WeatherType weatherType) {
    switch (weatherType) {
      // ...
    }
  }
}</code></pre>

          <h5>
            <a name="_root-Main" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Main
          </h5><pre><code class="language-java">  public static void main(String[] args) {
    GWeather gWeather = new GWeather();
    gWeather.addObserver(new GOrcs());
    gWeather.addObserver(new GHobbits());

    gWeather.timePasses();
    gWeather.timePasses();
    gWeather.timePasses();
    gWeather.timePasses();
  }</code></pre>

          <h4>
            <a name="_root-总结" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            总结
          </h4><p>总的来说就是：<strong>观察者把自己的引用注册到发布者给的接口中，发布者每次状态变更就通知所有注册了的引用。</strong></p>
<hr>

          <h3>
            <a name="_root-Decorator/Wrapper" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Decorator/Wrapper
          </h3><p>装饰器（也称包装器）的意图是<strong>动态（运行时）、弹性的（可选）、无侵入的（不改源码）</strong>地给某个类添加功能或者增强功能。</p>
<p>参考项目的作者<code>iluwatter</code>有这样一段比喻：</p>
<blockquote>
<p>附近的山里有一只巨魔（Troll），他平时都空着手，偶尔也会拿着武器；</p>
<p>如果你要让同一只巨魔拿着武器的话，你不需要new一只一模一样的巨魔，你只需要包装这只巨魔就好了[doge]</p>
</blockquote>

          <h4>
            <a name="_root-Object-Interface and Simple Implement" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Object-Interface and Simple Implement
          </h4><pre><code class="language-java">public interface Troll {
  void attack();
  int getAttackPower();
}

public class SimpleTroll implements Troll {
  @Override
  public void attack() {
    System.out.println(&quot;hp - &quot; + this.getAttackPower());
  }
  @Override
  public int getAttackPower() {
    return 10;
  }
}</code></pre>
<p>现在我们有一只攻击力+10的巨魔，接下来我们给它把无尽</p>

          <h4>
            <a name="_root-Decorator" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Decorator
          </h4><pre><code class="language-java">public class ClubbedTroll implements Troll {
  private Troll decorated;
  public ClubbedTroll(Troll decorated) {
    this.decorated = decorated;
  }
  @Override
  public void attack() {
    System.out.println(&quot;hp - &quot; + this.getAttackPower());
  }
  @Override
  public int getAttackPower() {
    return decorated.getAttackPower() + 100;
  }
}</code></pre>

          <h4>
            <a name="_root-Main" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Main
          </h4><pre><code class="language-java">// 空手巨魔
Troll troll = new SimpleTroll();
troll.attack(); // 平A无暴击

// 出无尽的巨魔
troll = new ClubbedTroll(troll);
troll.attack(); // 暴击！</code></pre>

          <h4>
            <a name="_root-总结" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            总结
          </h4><p>感觉和AOP差不多，只不过实现思路和需求不一样</p>
<hr>

          <h3>
            <a name="_root-Adapter/Wrapper" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Adapter/Wrapper
          </h3><p>适配器模式，也是包装模式的一种，它和装饰器模式有一方面像的一点就是，它们都是包装要使用的类，只不过装饰器是针对同一种类去包装，企图强化这个类；而适配器是要包装两个类为一个统一的类，在适配器里兼容一个类的输出，让它的输出为另一个类可用的输入，适配器输出这另一个类的输出，企图让这两个类联合工作。</p>
<p>参考项目的作者<code>iluwatter</code>有这样一段比喻：</p>
<blockquote>
<p>假设你想将你内存卡上的一些图片传到你电脑上去，你需要一种适配器，这个适配器可以适用于你电脑的端口，这样你才能将你的内存卡装载到你的电脑上去，在这个例子里面，读卡器就是一个适配器。</p>
</blockquote>
<p>专业的解释就是：</p>
<blockquote>
<p>适配器是要包装两个类为一个统一的类，在适配器里兼容一个类的输出，让它的输出为另一个类可用的输入，适配器输出这另一个类的输出，企图让这两个类联合工作。（这话是我说的~）</p>
</blockquote>

          <h4>
            <a name="_root-Two Interfaces" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Two Interfaces
          </h4><p>首先我们来看适配器要适配的两个对象类，场景如下：<code>假设船长只会划船，并不会航海，但是旁边有一艘渔船可以出海</code>，于是我们先有两个接口，划船只能划水，渔船可以航海：</p>
<pre><code class="language-java">public interface RowingBoat {
  void row();
}

public class FishingBoat {
  public void sail() {
    System.out.println(&quot;The fishing boat is sailing&quot;);
  }
}</code></pre>

          <h4>
            <a name="_root-User" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            User
          </h4><p>再来看看我们的船长：</p>
<pre><code class="language-java">public class Captain implements RowingBoat {

  private RowingBoat rowingBoat;

  public Captain(RowingBoat rowingBoat) {
    this.rowingBoat = rowingBoat;
  }

  @Override
  public void row() {
    rowingBoat.row();
  }
}</code></pre>
<p>可以看到，这里有一个关键的地方，船长实现RowingBoat类的方式是解耦的，是传入一个RowingBoat对象，基于这个，我们可以编写一个适配器</p>

          <h4>
            <a name="_root-Adapter" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Adapter
          </h4><pre><code class="language-java">public class FishingBoatAdapter implements RowingBoat {
  private FishingBoat boat;
  public FishingBoatAdapter() {
    boat = new FishingBoat();
  }
  @Override
  public void row() {
    boat.sail();
  }
}</code></pre>
<p>在这个适配器中我们可以看到，我们将<code>RowingBoat</code>中的<code>row()</code>方法实现为<code>FishingBoat</code>的<code>sail()</code>方法</p>

          <h4>
            <a name="_root-Main" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Main
          </h4><pre><code class="language-java">Captain captain = new Captain(new FishingBoatAdapter());
captain.row();</code></pre>

          <h4>
            <a name="_root-总结" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            总结
          </h4><p>总的来说，适配器和装饰器差不多，我们需要注意的点是，我们的使用者需要对原来的对象有良好的解耦支持，这样我们适配后的对象才能更好地被使用者使用。</p>
<hr>

          <h3>
            <a name="_root-Factory" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Factory
          </h3><p>工厂模式，在工程化编程中有着举足轻重的地位，将对象的创建、参数分派等行为工程化，是一个项目严谨编写的第一步体现。</p>
<p>项目的作者写分别引了<code>Factory-method</code>和<code>Factory-kit</code>两部分，我们先从method开始说起</p>

          <h4>
            <a name="_root-Factory-method" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Factory-method
          </h4><p>工厂方法模式，是要定义一个专门用于创建对象的接口，只不过创建对象的方式是让实现子类去决定应该创建具体哪一个对象，工厂方法模式<strong>让一个类将实例化过程延迟到子类上</strong>。</p>
<p>我们来看比喻：</p>
<blockquote>
<p> 一个铁匠（BlackSmith）打造（manufacture）武器，精灵（Elves）要求使用小巧的（Elvish）武器，半兽人（Orcs）要求使用重型武器（Orcish）。根据客户要求的不同会召集到打造同一类型武器的铁匠。</p>
</blockquote>
<p>专业的解释：</p>
<blockquote>
<p>将实例化过程的逻辑以委派方式提供给子类</p>
</blockquote>

          <h5>
            <a name="_root-Factory Interface" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Factory Interface
          </h5><pre><code class="language-java">public interface Blacksmith {
  Weapon manufactureWeapon(WeaponType weaponType);
}</code></pre>
<p>首先我们有个工厂类，这个类代表能够制造武器的工匠（先不管可以制造什么类型的武器）</p>
<p>然后下面就是武器的抽象接口和武器的类型</p>

          <h5>
            <a name="_root-Product Interface" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Product Interface
          </h5><pre><code class="language-java">public interface Weapon {
  WeaponType getWeaponType();
}
public enum WeaponType {
  SHORT_SWORD(&quot;short sword&quot;), SPEAR(&quot;spear&quot;), AXE(&quot;axe&quot;), UNDEFINED(&quot;&quot;);
  private String title;
  WeaponType(String title) {
    this.title = title;
  }
  @Override
  public String toString() {
    return title;
  }
}</code></pre>

          <h5>
            <a name="_root-Different Instance Class" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Different Instance Class
          </h5><p>然后我们有不同的实例类，分别是精灵武器和兽人武器</p>
<pre><code class="language-java">public class ElfWeapon implements Weapon {
  private WeaponType weaponType;
  public ElfWeapon(WeaponType weaponType) {this.weaponType = weaponType;}
  @Override
  public String toString() {return &quot;Elven &quot; + weaponType;}
  @Override
  public WeaponType getWeaponType() {return weaponType;}
}
// ============================
public class OrcWeapon implements Weapon {
  private WeaponType weaponType;
  public OrcWeapon(WeaponType weaponType) {this.weaponType = weaponType;}
  @Override
  public String toString() {return &quot;Orcish &quot; + weaponType;}
  @Override
  public WeaponType getWeaponType() {return weaponType;}
}</code></pre>

          <h5>
            <a name="_root-Different Factory Class" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Different Factory Class
          </h5><p>然后我们有不同的工厂类，分别是精灵武器工匠和兽人武器工具</p>
<pre><code class="language-java">public class ElfBlacksmith implements Blacksmith {
  public Weapon manufactureWeapon(WeaponType weaponType) {
    return new ElfWeapon(weaponType);
  }
}
// =============================
public class OrcBlacksmith implements Blacksmith {
  public Weapon manufactureWeapon(WeaponType weaponType) {
    return new OrcWeapon(weaponType);
  }
}
</code></pre>

          <h5>
            <a name="_root-Main" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Main
          </h5><pre><code class="language-java">public class App {
  private final Blacksmith blacksmith;
  public App(Blacksmith blacksmith) {
    this.blacksmith = blacksmith;
  }

  public static void main(String[] args) {
    // Lets go to war with Orc weapons
    App app = new App(new OrcBlacksmith());
    app.manufactureWeapons();

    // Lets go to war with Elf weapons
    app = new App(new ElfBlacksmith());
    app.manufactureWeapons();
  }

  private void manufactureWeapons() {
    Weapon weapon;
    weapon = blacksmith.manufactureWeapon(WeaponType.SPEAR);
    //weapon = blacksmith.manufactureWeapon(WeaponType.AXE);
  }
}</code></pre>
<p>通过上面的<code>Factory-method</code>的例子，不难发现代码的解耦性还是不高，感觉创造者和工厂本身，这两个概念还是有点摸棱两可的，我们在正确地理顺一下工厂模式到底怎么回事：</p>
<blockquote>
<ol>
<li>首先一个工厂（Factory）只生产同一类产品（Product），这里将工厂映射为<code>BlackSmith interface</code>接口，他可以制造<code>Weapon</code>对象</li>
<li>其次产品有很多种产品，所以我们也把产品抽象成接口<code>Weapon interface</code></li>
<li>那么我们要指派不同的创造者（Producer/Builder），去生产不同的产品，这其实就是不同的工厂接口的实现，这映射到的就是<code>ElfBlacksmith</code>和<code>OrcBlacksmith</code>，分别生产<code>ElfWeapon</code>和<code>OrcWeapon</code></li>
<li>最后在App里面，完美地使用了多态的特性：<strong>父类引用指向子类对象</strong></li>
</ol>
</blockquote>

          <h4>
            <a name="_root-Factory-kit" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Factory-kit
          </h4><p>为了更加清晰化工厂模式，于是就有了<code>Factory-kit</code>，意图定义一个不变的常量来将工匠和工厂区分开来</p>

          <h5>
            <a name="_root-Product" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Product
          </h5><p>我们先看产品有哪些：</p>
<pre><code class="language-java">public interface Weapon {
}
public class Axe implements Weapon {
  @Override
  public String toString() {
    return &quot;Axe&quot;;
  }
}
public class Bow implements Weapon {
  @Override
  public String toString() {
    return &quot;Bow&quot;;
  }
}
public class Sword implements Weapon {
  @Override
  public String toString() {
    return &quot;Sword&quot;;
  }
}
public enum WeaponType {
  SWORD, AXE, BOW
}</code></pre>

          <h5>
            <a name="_root-Builder" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Builder
          </h5><p>再看看工匠，这里用到了Java8的函数式特性，传入一个供给者对象</p>
<pre><code class="language-java">public interface Builder {
  void add(WeaponType name, Supplier&lt;Weapon&gt; supplier);            // 4
}</code></pre>

          <h5>
            <a name="_root-Factory" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Factory
          </h5><p>接下来就是重点，看看我们的工厂是如何协调工匠和产品的</p>
<pre><code class="language-java">public interface WeaponFactory {
  // 制造武器，根据传入的WeaponType选取工厂中存在的工匠制造想对应的武器
  Weapon create(WeaponType name);                                // 6

  // 聚集工匠，factory负责维护一个map，一种武器类型对应一类工匠
  static WeaponFactory factory(Consumer&lt;Builder&gt; consumer) {    // 1.2
    Map&lt;WeaponType, Supplier&lt;Weapon&gt;&gt; map = new HashMap&lt;&gt;();    // 2
    consumer.accept(map::put);                                    // 3.0
    return name -&gt; map.get(name).get();                            // 5
  }
}</code></pre>

          <h5>
            <a name="_root-Main" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Main
          </h5><pre><code class="language-java">public class App {
  public static void main(String[] args) {
    WeaponFactory factory = WeaponFactory.factory(builder -&gt; {    // 1.1
      builder.add(WeaponType.SWORD, Sword::new);                // 3.1
      builder.add(WeaponType.AXE, Axe::new);                    // 3.2
      builder.add(WeaponType.SPEAR, Spear::new);                // 3.3
      builder.add(WeaponType.BOW, Bow::new);                    // 3.4
    });
    Weapon axe = factory.create(WeaponType.AXE);
    System.out.println(axe.toString());
  }
}</code></pre>
<p>这里有一段稍微难懂的方法引用语法，我们可以这样理解，跟着标号走</p>
<ol>
<li>首先传入一个<code>consumer</code>对象（1.1-1.2），这个对象就是Builder，它要实现的唯一方法就是<code>add</code>方法，在括号内我们注意到他利用<code>builder</code>调用了多次<code>add</code>方法，将武器类型和武器对象一一对应了起来；</li>
<li>维护一个map，用作映射武器类型名字和武器制造方法（Suplier）这个武器制造方法可以制造一种武器</li>
<li>3.0的代码代表，<code>builder.add(a, b)</code>传入的参数a和b被这个map的<code>put</code>方法所接管，在这个意义上，我们在<code>Main</code>中看到的3.1-3.4相当于在<code>Factory.factory()</code>方法中调用map的<code>put</code>方法，我们看到3.1-3.4后一个参数是一个构造方法引用，用于作为Suplier对象来直接返回一个武器对象</li>
<li>往上看到的是Builder的add方法，这个方法的实现被3.0接管了</li>
<li>看到这个return语句，千万不要会错意，这个return语句其实是上面<code>create</code>方法的实现语句，用于返回一件武器</li>
<li>这段实现真的是无比的迷，毫无逻辑可言</li>
</ol>
<p>大致看懂这段语法糖之后，可以自己尝试实现一个平民版的工厂Kit，函数式编程很大程度上扭曲了Java程序编程的直接意图，让程序晦涩难懂，复现难度大。</p>

          <h4>
            <a name="_root-Friendly Factory-kit" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Friendly Factory-kit
          </h4><p>下面是我改进的亲民版的<code>Factory-kit</code>，虽然也用到了Lambda和方法引用，但是特别强调了面向对象思想，并不难懂</p>

          <h5>
            <a name="_root-Interfaces" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Interfaces
          </h5><pre><code class="language-java">public interface Builder {
    Product build();
}
public interface Product {
}</code></pre>
<p>两个接口，一个代表工匠，提供一个<code>buili()</code>方法去获取<code>Product</code>，一个<code>Product</code>接口用做类型约束</p>

          <h5>
            <a name="_root-Factory" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Factory
          </h5><pre><code class="language-java">public class Factory&lt;PT&gt; {
    private HashMap&lt;PT, Builder&gt; builders = new HashMap&lt;&gt;();

    void addBuilder(PT productType, Builder builder) {
        builders.put(productType, builder);
    }

    public Product produce(PT productType) {
        return builders.get(productType).build();
    }
}</code></pre>
<p>注意<code>addBuilder</code>方法，第二个参数直接就是Builder，因为你观察Builder可以发现，Builder接口直接就可以是一个<code>Supplier</code>，用以直接生产产品</p>

          <h5>
            <a name="_root-Implements" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Implements
          </h5>
          <h6>
            <a name="_root-Product implemenets" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Product implemenets
          </h6><pre><code class="language-java">public class Axe implements Product {
  @Override
  public String toString() {
    return &quot;Axe&quot;;
  }
}
public class Bow implements Product {
  @Override
  public String toString() {
    return &quot;Bow&quot;;
  }
}
public enum WeaponType {
  AXE, BOW
}</code></pre>

          <h6>
            <a name="_root-Factory implements" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Factory implements
          </h6><pre><code class="language-java">public class WeaponFactory extends Factory&lt;WeaponType&gt; {
    public WeaponFactory() {
        addBuilder(WeaponType.AXE, Axe::new);
        addBuilder(WeaponType.BOW, () -&gt; new Bow());
    }
}</code></pre>
<p>这里稍微用到了一些Lambda的语法了，我们在继承<code>Factory</code>的时候，用泛型去规定产品类型，然后在实现子类的构造方法里面注册工匠，我们注意到，传递<code>Builder</code>的时候，第一次传生产<code>Axe</code>对象的<code>Builder</code>的时候，我直接使用了<code>Axe</code>的构造方法引用，这其实是<strong>初始化了一个专门生产<code>Axe</code>对象的<code>Builder</code>对象，这个<code>Builder</code>对象的<code>build</code>方法的实现就是返回生成的<code>Axe</code>对象</strong>，如果不是很好理解，可以看第二次传入生产<code>Bow</code>对象的<code>Builder</code>对象，一看就懂</p>

          <h5>
            <a name="_root-Main" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Main
          </h5><pre><code class="language-java">public class App {
    public static void main(String[] args) {
        WeaponFactory factory = new WeaponFactory();
        System.out.println(factory.produce(WeaponType.AXE));
        System.out.println(factory.produce(WeaponType.BOW));
    }
}</code></pre>

          <h4>
            <a name="_root-总结" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            总结
          </h4><p>对于工厂方法，因为它的地位太重要，所以我们在设计一个工厂的时候要特别注意方法和其他对象之间的解耦性，让这个工厂通用性更强一些</p>
<hr>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

    <script>
        importJsAfterLoad()
    </script>
</body>

</html>