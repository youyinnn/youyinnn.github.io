<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
    <script>
        importJsBeforeLoad()
    </script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn btn-dark" type="button" title="clear search">cls</button>
                <button id="categories" class="btn btn-dark" type="button">cates</button>
                <button id="tags" class="btn btn-dark" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn btn-dark" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-术语" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            术语
          </h3><p><strong>稳定性：</strong>算法排序前后，相同值的元素的相对位置是否不变，变了就不稳定</p>
<p><strong>在位性：</strong>算法排序是否要借助额外的内存空间，需要就不在位</p>

          <h3>
            <a name="_root-各数据对比" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            各数据对比
          </h3>
          <h4>
            <a name="_root-基本数据" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            基本数据
          </h4>
          <h5>
            <a name="_root-小数据量" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            小数据量
          </h5><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最好</th>
<th align="center">平均</th>
<th align="center">最坏</th>
<th align="center">辅助空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center"><strong>O(n)</strong></td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center"><strong>O(n)</strong></td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">✖️</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center"><strong>O(n)</strong></td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center"><strong>O(n^1.3)</strong></td>
<td align="center"><strong>O(nlogn)~O(n^2)</strong></td>
<td align="center"><strong>O(n^2)</strong></td>
<td align="center">O(1)</td>
<td align="center">✖️</td>
</tr>
</tbody></table>

          <h5>
            <a name="_root-大数据量" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            大数据量
          </h5><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最好</th>
<th align="center">平均</th>
<th align="center">最坏</th>
<th align="center">辅助空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">快速排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center"><strong>O(n^2)</strong></td>
<td align="center"><strong>O(logn)~O(n)</strong></td>
<td align="center">✖️</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center"><strong>O(n)</strong></td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">✖️</td>
</tr>
</tbody></table>

          <h4>
            <a name="_root-场景表现（⚠️仅供参考！！！）" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            场景表现（⚠️仅供参考！！！）
          </h4><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">良序表现</th>
<th align="center">乱序表现</th>
<th align="center">逆序表现</th>
<th align="center">部分重复</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡</td>
<td align="center">第二</td>
<td align="center">第六</td>
<td align="center">第六</td>
<td align="center">第六</td>
</tr>
<tr>
<td align="center">选择</td>
<td align="center"><strong>最差</strong></td>
<td align="center"><strong>最差</strong></td>
<td align="center"><strong>最差</strong></td>
<td align="center"><strong>最差</strong></td>
</tr>
<tr>
<td align="center">插入</td>
<td align="center"><strong>最好</strong></td>
<td align="center">第五</td>
<td align="center">第五</td>
<td align="center">第三</td>
</tr>
<tr>
<td align="center">希尔</td>
<td align="center">第三</td>
<td align="center">第二</td>
<td align="center"><strong>最好</strong></td>
<td align="center"><strong>最好</strong></td>
</tr>
<tr>
<td align="center">快速</td>
<td align="center">第六</td>
<td align="center">第四</td>
<td align="center">第四</td>
<td align="center">第五</td>
</tr>
<tr>
<td align="center">归并</td>
<td align="center">第四</td>
<td align="center">第三</td>
<td align="center">第三</td>
<td align="center">第四</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">第五</td>
<td align="center"><strong>最好</strong></td>
<td align="center">第二</td>
<td align="center">第二</td>
</tr>
</tbody></table>
<blockquote>
<p>参考：<a href="https://www.toptal.com/developers/sorting-algorithms%EF%BC%88%E8%82%89%E7%9C%BC%E6%B5%8B%E9%87%8F%E3%80%81%E9%9A%BE%E5%85%8D%E6%9C%89%E8%AF%AF%EF%BC%89">https://www.toptal.com/developers/sorting-algorithms（肉眼测量、难免有误）</a></p>
</blockquote>
<ol>
<li><strong>快排</strong>真的<strong>不咋地</strong>，性能不稳定，排序也不稳定，场景表现也不咋地</li>
<li><strong>希尔</strong>确实不错，各场景表现综合<strong>第一</strong></li>
<li><strong>选择</strong>是真的<strong>菜鸡</strong></li>
<li><strong>随机</strong>情况下表现依次为：<strong>堆、希尔、归并、快排、插入、冒泡</strong></li>
<li><strong>良序</strong>情况下表现依次为：<strong>插入、冒泡、希尔、归并、堆、快排</strong></li>
<li><strong>逆序</strong>情况下表现依次为：<strong>希尔、堆、归并、快排、插入、冒泡</strong></li>
</ol>
<hr>

          <h3>
            <a name="_root-BubbleSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            BubbleSort
          </h3><blockquote>
<p> 相邻元素之间两两比较，按照大小顺序作为交换，每一轮比较都把最大的元素安排到当前轮次的最后面</p>
<p> 每一轮都把当前待排序列的最大元素从前往后“移动”到最后面，移动的过程形象为“冒泡”；</p>
<p> 所用技术：<strong>蛮力法</strong></p>
<p> 稳定性：<strong>稳定</strong></p>
<p> 在位性：<strong>在位</strong></p>
<p> 使用场景：处理<strong>基本有序</strong>，<strong>小量数据</strong></p>
<p> 优化措施：设置一个<strong>标志</strong>，每轮比较时，如果发现没有进行交换操作，说明数组已经有序，退出循环，停止比较</p>
<p> 时间复杂度：</p>
<ul>
<li>最坏：<strong>O(n^2)</strong></li>
<li>最好：<strong>O(n)</strong></li>
<li>平均：<strong>O(n^2)</strong></li>
</ul>
</blockquote>
<pre><code class="language-java">public static void bubbleSort(int[] arr){
    for (int i = 0; i &lt; arr.length - 1; ++i) {
        for (int j = 0 ; j &lt; arr.length - 1 - i; ++j) {
            if (arr[j] &gt; arr[j+1]) {
                swap(arr, j, j+1);
            }
        }
    }
}</code></pre>
<hr>

          <h3>
            <a name="_root-SelectionSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            SelectionSort
          </h3><blockquote>
<p>每次扫描后n-i个元素 选出当前参与扫描的最小值，扫描结束后把最小值放置当前轮次的最前面</p>
<p>每一轮都把最值放到端位置，例子中就是找的最小值，放到最前面，挑最值的过程称为“选择”</p>
<p>所用技术：<strong>蛮力法</strong></p>
<p>稳定性：<strong>不稳定</strong></p>
<p>在位性：<strong>在位的</strong></p>
<p>使用场景：处理<strong>基本有序</strong>，<strong>小量数据</strong></p>
<p>优化措施：每次寻找最小或最大元素时，同时记录最小最大元素的位置，每次使用3次比较寻找两个元素的位置，而不是4次比较</p>
<p>时间复杂度：</p>
<ul>
<li>最坏：<strong>O(n^2)</strong></li>
<li>最好：<strong>O(n^2)</strong></li>
<li>平均：<strong>O(n^2)</strong></li>
</ul>
</blockquote>
<pre><code class="language-java">public static void selectionSort(int[] arr){
    for (int i = 0 ; i &lt; arr.length - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1 ; j &lt; arr.length ; ++j) {
            if (arr[minIndex] &gt; arr[j]){
                minIndex = j;
            }
        }
        if (minIndex != i) {
            swap(arr, i, minIndex);
        }
    }
}</code></pre>
<hr>

          <h3>
            <a name="_root-InsertionSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            InsertionSort
          </h3>
          <h4>
            <a name="_root-StraightInsertionSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            StraightInsertionSort
          </h4><blockquote>
<p>将数组分为两部分，一部分是已经排序好的，另一部分是待插入的数组</p>
<p>每次从待插入的数组中取出<strong>第一个元素</strong>元素和有序数组从后往前进行比较，待插入一个一个<strong>往前挤</strong>，直到找到合适的位置</p>
<p>直到待插入部分元素为0</p>
<p>所用技术：<strong>减治法</strong></p>
<p>稳定性：<strong>稳定</strong></p>
<p>在位性：<strong>在位</strong></p>
<p>使用场景：处理<strong>基本有序</strong>，<strong>小量数据</strong></p>
<p>优化措施：每次都是在已排序的情况下从后往前找位置插入，可以用二分查找到自己应该插入的位置</p>
<p>时间复杂度：</p>
<ul>
<li>最坏：<strong>O(n^2)</strong></li>
<li>最好：<strong>O(n)</strong></li>
<li>平均：<strong>O(n^2)</strong></li>
</ul>
</blockquote>
<pre><code class="language-java">public static void straightInsertionSort(int[] arr){
    for (int i = 1 ; i &lt; arr.length ; i++) {
        int j = i;
        while (j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]) {
            swap(arr, j, j - 1);
            j--;
        }
    }
}</code></pre>
<hr>

          <h4>
            <a name="_root-BinaryInsertionSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            BinaryInsertionSort
          </h4><blockquote>
<p>直接插入排序是将带插入元素从后往前比较和移动<br>目的是为了在以排序序列中找到自己该插入的位置<br>二分插入排序就是在查找该插入位置的时候，使用二分法去查找<br>而不是逆序查找，这样查找的次数就少了很多</p>
<p>属性大致同直接插入排序</p>
</blockquote>
<pre><code class="language-java">public static void binaryInsertionSort(int[] arr) {
    for (int i = 1 ; i &lt; arr.length ; i++) {
        int key = arr[i];
        int low = 0,high = i - 1 , mid;
        while (low &lt;= high) {
            mid = (low + high) &gt;&gt;&gt; 1;
            if (key &lt; arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        if (high + 1 != i) {
            // 给key找到位置之后，先把位置到i上的元素往后移 给key腾个位置
            for (int j = i ; j &gt; high + 1 ; j--) {
                arr[j] = arr[j - 1];
            }
            // 把key放到位置上
            arr[high + 1] = key;
        }
    }
}</code></pre>
<hr>

          <h4>
            <a name="_root-ShellSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            ShellSort
          </h4><blockquote>
<p>希尔排序，是插入排序的一种，是直接插入排序的改进版</p>
<p>希尔排序有好几种实现，根据选取的增量的不同而改变</p>
<p>希尔排序是<strong>不稳定的、在位的</strong></p>
<p>使用场景：处理<strong>基本有序</strong>，<strong>小量数据</strong></p>
<p>一般的Shell排序的时间复杂度为<strong>O(n^2)</strong>，好一点的有<strong>O(n^(3/2))</strong>，下界为<strong>O(n(log2n))</strong>，没有快排<strong>O(n(logn))</strong>快</p>
</blockquote>

          <h5>
            <a name="_root-SwapHalfShellSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            SwapHalfShellSort
          </h5><blockquote>
<p>常规实现，增量一半一半地砍，交换法做插入</p>
</blockquote>
<pre><code class="language-java">    public static void shellSort1(int []arr){
        //增量gap，并逐步缩小增量
        for(int gap = arr.length / 2; gap &gt; 0; gap /= 2){
            //从第gap个元素，逐个对其所在组进行直接插入排序操作
            for(int i = gap; i &lt; arr.length; i++){
                int j = i;
                while(j - gap &gt;= 0 &amp;&amp; arr[j] &lt; arr[j - gap]){
                    //插入排序采用交换法
                    swap(arr,j,j - gap);
                    j -= gap;
                }
            }
        }
    }</code></pre>
<p>我把插入排序再贴一遍，可以比较一下：</p>
<pre><code class="language-java">public static void straightInsertionSort(int[] arr){
    for (int i = 1 ; i &lt; arr.length ; i++) {
        int j = i;
        while (j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]) {
            swap(arr, j, j - 1);
            j--;
        }
    }
}</code></pre>

          <h5>
            <a name="_root-MoveHalfShellSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            MoveHalfShellSort
          </h5><blockquote>
<p>移动法做插入，一半增量    ，这种实现意义不大</p>
</blockquote>
<pre><code class="language-java">    public static void shellSort2(int []arr){
        //增量gap，并逐步缩小增量
        for(int gap = arr.length / 2; gap &gt; 0; gap /= 2){
            //从第gap个元素，逐个对其所在组进行直接插入排序操作
            for(int i = gap;i &lt; arr.length; i++){
                int j = i;
                int temp = arr[j];
                if(arr[j] &lt; arr[j - gap]){
                    while(j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]){
                        //移动法
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    arr[j] = temp;
                }
            }
        }
    }</code></pre>
<hr>

          <h3>
            <a name="_root-MergeSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            MergeSort
          </h3><blockquote>
<p>对于需要排序的数组，把它一分为二，递归分</p>
<p>分到不可再分为止就开始合并，并且是有序地合并</p>
<p>所用技术：<strong>分治法</strong></p>
<p>稳定性：<strong>稳定</strong></p>
<p>在位性：<strong>不在位</strong></p>
<p>应用场景：处理<strong>大量数据</strong>且要求<strong>排序稳定</strong>时</p>
<p>优化措施：由于使用递归，递归深度太深容易造成内存溢出，所以可使用非递归版本归并排序</p>
<p>时间复杂度：都是<strong>O(n(logn))</strong></p>
</blockquote>
<pre><code class="language-java">public static void mergeSort(int[] arr) {
    if (arr.length &gt; 1) {
        int half = arr.length &gt;&gt;&gt; 1;
        int[] brr = new int[half];
        int[] crr = new int[arr.length - half];
        System.arraycopy(arr, 0, brr, 0, half);
        System.arraycopy(arr, half, crr, 0, arr.length - half);    
        mergeSort(brr);
        mergeSort(crr);
        merge(brr, crr, arr);
    }
}

private static void merge(int[] brr, int[] crr, int[] arr){
    int bLength = brr.length;
    int cLength = crr.length;
    int aIndex = 0, cIndex = 0, bIndex = 0;
    while (bIndex &lt; bLength &amp;&amp; cIndex &lt; cLength) {
        if (brr[bIndex] &lt;= crr[cIndex]) {
            arr[aIndex++] = brr[bIndex++];
        } else {
            arr[aIndex++] = crr[cIndex++];
        }
    }
    while (cIndex &lt; cLength) {
        arr[aIndex++] = crr[cIndex++];
    }
    while (bIndex &lt; bLength) {
        arr[aIndex++] = brr[bIndex++];
    }
}</code></pre>
<hr>

          <h3>
            <a name="_root-QuickSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            QuickSort
          </h3><blockquote>
<p> 以arr[l]为左界，arr[r]为右界，选择当前界限内的第一个元素作为分裂点</p>
<p> 从两界向中间扫描为分裂点寻找一个合适的位置，使得分裂点左边的元素都小于等于分裂点</p>
<p> 右边的元素都大于等于分裂点，再递归以分裂点对左右两边的子数组进行划分排序</p>
<p> 快排的实现有很多种，所谓的<strong>“简单快排”</strong>及俗称的挖坑法却是最难理解的（用代码去推结果的话），这里先po好理解的<strong>双路快排（左右指针实现）</strong>，还有一种前后指针法，具体没细看，但是双路的手算和挖坑的手算还是比较好写出来，特别是牛客上的快排第一趟结果的题都是挖坑去做的</p>
<p> 所用技术：<strong>分治法</strong></p>
<p> 稳定性在位性：<strong>不稳定、不在位</strong></p>
<blockquote>
<p>为什么不在位？虽然快排没有显示地创建辅助空间，但由于需要用到递归实现，所以递归栈需要占用空间</p>
</blockquote>
<p> 应用场景：<strong>处理大量数据</strong></p>
<p> 优化措施：由于如果每次选取基准元素时都选到了最小或最大的元素，会导致快排时间复杂度很高，所以可以<strong>随机选取基准元素</strong>，能有效的提高排序的平均性能，防止时间复杂度达到O(n2)。</p>
<p> 时间复杂度：</p>
<ul>
<li><p>最坏：<strong>O(n^2)</strong></p>
<blockquote>
<p>什么时候会退化为最坏情况？在元素完全逆序的情况下，快排会退化为冒泡排序。</p>
</blockquote>
</li>
<li><p>最好：<strong>O(nlogn)</strong></p>
</li>
<li><p>平均：<strong>O(nlogn)</strong></p>
<p>好文：</p>
</li>
<li><p>挖坑、左右指针、前后指针：<a href="https://blog.csdn.net/qq_36528114/article/details/78667034">https://blog.csdn.net/qq_36528114/article/details/78667034</a></p>
</li>
<li><p>单路、三路、双轴的简单实现和图片解析：<a href="https://rerun.me/2013/06/13/quicksorting-3-way-and-dual-pivot/">https://rerun.me/2013/06/13/quicksorting-3-way-and-dual-pivot/</a></p>
<p>目前来说，实现最快的快排是双轴快排，它的表现非常好，再JDK7的时候，<code>Arrays.sort()</code>方法用的就是自实现的双轴快排<code>java.util.DualPivotQuicksort</code></p>
<p>更多双轴快排的参考：</p>
</li>
<li><p><a href="http://www.it610.com/article/2141917.htm">双枢轴快排（JDK7快排）（译文）</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/6d26d525bb96">DualPivotQuickSort 双轴快速排序 源码 笔记</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/2c6f79e8ce6e">DualPivot的历史简介</a></p>
</li>
</ul>
</blockquote>

          <h4>
            <a name="_root-BothSideQuickSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            BothSideQuickSort
          </h4><pre><code class="language-java">public static void bothSideQuickSort(int[] arr, int left, int right) {
    if (left &lt; right) {
        int s = partition(arr, left, right);
        bothSideQuickSort(arr, left, s - 1);
        bothSideQuickSort(arr, s + 1, right);
    }
}

/*
 * 思路参考：http://developer.51cto.com/art/201403/430986.htm
 */
private static int partition(int[] arr, int left, int right) {
    int i = left;
    int var = arr[i];
    // 在一次快速排序中只要left的值比right小，我们就应该去移动，因为当前这次排序还没有完成
    while (left &lt; right) {
        // 表示只有当前指针没有重合并且当前right指向的值大于val时，才会向左移动right
        while (left &lt; right &amp;&amp; arr[right] &gt;= var) {
            right--;
        }
        while (left &lt; right &amp;&amp; arr[left] &lt;= var) {
            left++;
        }
        swap(arr, right, left);
    }
    // 找到了所属的位置，并且将我们选定的值val赋到这个位置上去
    swap(arr, i, left);
    return left;
}</code></pre>
<hr>

          <h3>
            <a name="_root-HeapSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            HeapSort
          </h3><blockquote>
<p>堆排序很有意思，它的思想就是：</p>
<p>将每个数组看作一个堆，然后我们将这个堆造成大顶堆（根的值在当前数组中最大）或者小顶堆（最小），然后如果是构造大顶堆，那么堆化成功的时候，将根交换到数组最后，这个时候等于找到了最大的元素了（排好了的意思），然后在这个最大元素之前的子数组规模中再造堆，直到造堆的规模为1为止</p>
<p>这么看下来的话，有点选择排序的意思</p>
<p>总结一下堆排序的步骤：</p>
<ol>
<li>构造顶堆</li>
<li>去顶</li>
<li>减小规模，重复1</li>
</ol>
<p>所属技术：<strong>变治法</strong></p>
<p>在位性稳定性：<strong>不稳定、在位</strong></p>
<p>应用场景：<strong>数据量大，或者数据呈流式输入时</strong></p>
<p>优化措施：建立堆的时候不需要对叶子结点进行维护堆性质操作，因此只需要对n/2个数进行维护堆操作</p>
<p>时间复杂度：都是<strong>O(n(logn))</strong></p>
</blockquote>
<pre><code class="language-java">public static void heapSort(int[] arr) {
    // 逐渐减小堆规模 直到规模为1
    for (int i = 0; i &lt; arr.length - 1; i++) {
        int heapLength = arr.length - i;
        int lastParentIndex = (heapLength - 2) / 2;
        // 堆化
        for (int j = lastParentIndex ; j &gt;= 0 ; --j) {
            int leftChildIndex = j * 2 + 1;
            int rightChileIndex = leftChildIndex + 1;
            int bigChildIndex = leftChildIndex;
            if (rightChileIndex &lt; heapLength
                    &amp;&amp; arr[rightChileIndex] &gt; arr[leftChildIndex]) {
                bigChildIndex = rightChileIndex;
            }
            if (arr[bigChildIndex] &gt; arr[j]) {
                swap(arr, bigChildIndex, j);
            }
        }
        // 删除最大键
        swap(arr,0, heapLength - 1);
    }
}</code></pre>
<hr>

          <h3>
            <a name="_root-CountingSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            CountingSort
          </h3><blockquote>
<p>计数排序也是一种很有意思的算法，紫皮书上说到2种计数排序的思想，它是<strong>时空权衡</strong>思想的代表之一</p>
<ul>
<li><p>比较计数：是最直观的思想，针对待排序的每一个元素，算出列表中小于该元素值的元素<strong>个数</strong>，并把结果记录在一张表上，于是这个<strong>“个数”</strong>就是该元素在有序表中的位置。</p>
  <pre class="nhi">
  A[0..5]     62  31  84  96  19  47
  counting     3   1   4   5   0   2
  ----------------------------------
  S[0..5]     19  31  47  62  84  96
  explain：   比如有比62小的元素是2个，所以62应该在数组的2下标位置
  </pre>
</li>
<li><p>分布计数：待排序列表中的元素假如都能映射到一个<strong>天然有序的集合</strong>里，我们只需要计算出所有待排序列表中的元素在有序集合中<strong>出现的次数</strong>，就能按照<strong>次数</strong>将待排序列表转换为有序列表。</p>
  <pre class="nhi">
  A[0..5]     13  11  12  13  12  12
  map         11  12  13
  counting     1   3   2
  ----------------------------------
  S[0..5]     11  12  12  12  13  13
  explain：   比如11出现了1次，12出现了3次，13出现了2次，映射结果显而易见
  </pre>

</li>
</ul>
</blockquote>

          <h4>
            <a name="_root-ComparisonCountingSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            ComparisonCountingSort
          </h4><blockquote>
<p>时间复杂度：平方级</p>
<p>空间复杂度：2n</p>
<p>好处：算法使得键值移动次数最小化，直接放置键值</p>
</blockquote>
<pre><code class="language-java">public static int[] comparisonCountingSort(int[] arr) {
    int[] counts = new int[arr.length];
    int[] result = new int[arr.length];
    // 计数
    for (int i = 0; i &lt; arr.length - 1; i++) {
        for (int j = i + 1; j &lt; arr.length; j++) {
            if (arr[i] &lt; arr[j]) {
                counts[j]++;
            } else {
                counts[i]++;
            }
        }
    }
    // 还原
    for (int i = 0; i &lt; arr.length; i++) {
        result[counts[i]] = arr[i];
    }
    return result;
}</code></pre>

          <h4>
            <a name="_root-DistributionCountingSort" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            DistributionCountingSort
          </h4><blockquote>
<p>分布式计数的思想：</p>
<ol>
<li>需要知道待排序序列的范围：<strong>rank</strong></li>
<li>准备一个map数组用于记录分布值：<strong>map</strong></li>
<li>计算待排序数组在<strong>rank</strong>中的分布值</li>
<li>映射<strong>rank</strong>和分布值为有序数组</li>
</ol>
<p>计数排序的核心思想就是利用了<strong>元素值和下标的关系</strong>，网上有很多实现，但我觉得都不太好，有的甚至说计数排序只能处理非负数，有的甚至说计数排序必须知道元素的最大值最小值才能使用（这样说也行8）</p>
<p>但我们可以利用核心思想去处理含有负数的序列，目前来说，计数排序唯一的限制就是：<strong>元素值得是整数</strong></p>
<p>从我的实现中可以看出，算法的时间复杂度是<strong>n+n+n+k</strong>，其中k是<strong>rank</strong>的大小，空间复杂度是<strong>n+k</strong></p>
<p>由于<strong>rank</strong>的原因，如果数据分布太散，可能会浪费很多空间，比如很多<strong>rank值</strong>根本就没有在待排序的序列中出现过；</p>
<p>从这样来看的话，它的应用场景大致是：<strong>空间允许的情况下，能够线性时间地处理大量整数数据，最好是数据分布较为集中的情况下</strong></p>
</blockquote>
<pre><code class="language-java">public static int[] distributionCountingSort(int[] arr) {
    int low = arr[0];
    int high = arr[0];
    // calculate rank
    for (int num : arr) {
        if (low &gt; num) {
            low = num;
        }
        if (high &lt; num) {
            high = num;
        }
    }
    // distribution rate in rank
    int[] disRate = new int[high - low + 1];
    int[] result = new int[arr.length];
    // calculate distribution rate
    for (int num : arr) {
        disRate[num - low]++;
    }
    int index = 0;
    // consume the distribution rate with order
    for (int i = 0; i &lt; result.length; i++) {
        while (disRate[index] == 0) {
            index++;
        }
        result[i] = index + low;
        disRate[index]--;
    }
    return result;
}</code></pre>

          <h4>
            <a name="_root-DistributionCountingSort2" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            DistributionCountingSort2
          </h4><blockquote>
<p>再补充一个场景限制，现有实现的分布式计数排序<strong>无法表达整数以外的特性</strong>，比如稳定性</p>
<p>比方说我有一组元素<strong>[3, 2, 2, 1]</strong>, 其中有两个2，第一个设为2a，后者2b，其他排序完成之后，能够表达出2a或者2b是否还在原来的<strong>相对位置</strong>，但是现在的分布率图，是无状态的，最终的结果仅是<code>result[i] = index + low</code>算出的，比如2元素的计数是<strong>2</strong>，这个<strong>2</strong>无法区分到底是2a还是2b</p>
<p>有一个方法是用queue数组来存储分布率，所以上面的序列的分布率可以为：</p>
<p><strong>queue[] = { {1a}, {2a, 2b}, {3a} }</strong></p>
<p>它的时间复杂度依然是<strong>n+n+n+k</strong>，空间复杂度稍微要不一样点，是<strong>n+k+c</strong>，其中c是2b这样的同位元素的数量总和</p>
<p>关键的是：<strong>它保持了稳定性，结果中的元素还是原来的元素，而不是新算出来的元素</strong></p>
<p>⚠️需要注意的是，这个实现里的<strong>c</strong>，可能会很致命，如果序列的<strong>rank</strong>比较大的话，会造成<strong>更多</strong>的空间成本</p>
</blockquote>
<pre><code class="language-java">public static int[] distributionCountingSort2(int[] arr) {
    int low = arr[0];
    int high = arr[0];
    // calculate rank
    for (int num : arr) {
        if (low &gt; num) {
            low = num;
        }
        if (high &lt; num) {
            high = num;
        }
    }
    // distribution rate in rank
    LinkedList[] disRate = new LinkedList[high - low + 1];
    int[] result = new int[arr.length];
    // calculate distribution rate
    for (int num : arr) {
        if (disRate[num - low] == null) {
            disRate[num - low] = new LinkedList&lt;Integer&gt;();
        }
        disRate[num - low].add(num);
    }
    int index = 0;
    // consume the distribution rate with order
    for (LinkedList queue : disRate) {
        if (queue != null) {
            while (!queue.isEmpty()) {
                result[index++] = (int) queue.poll();
            }
        }
    }
    return result;
}</code></pre>
<hr>
<p><em>应用场景和优化措施的参考：<a href="https://blog.csdn.net/hairy_monsters/article/details/80154391">https://blog.csdn.net/hairy_monsters/article/details/80154391</a></em></p>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

    <script>
        importJsAfterLoad()
    </script>
</body>

</html>