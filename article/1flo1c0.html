<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="http://pv.sohu.com/cityjson?ie=utf-8"></script>
    <script>
        if (location.hostname === 'youyinnn.github.io' && returnCitySN.cname === 'CHINA') {
            location.href = 'https://youyinnn.gitee.io' + location.pathname
        }
    </script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">


    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn" type="button" title="clear search">cls</button>
                <button id="categories" class="btn" type="button">cates</button>
                <button id="tags" class="btn" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-Introduction" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Introduction
          </h3><p>我们先分析Leetcode的55题，是从45题Jump Game II 跳过来的，因为这题比II要简单一点，只需要判断序列是否能jump到终点就行，而45题是要找最小的jump次数；</p>
<p>为什么这题要拿出篇幅来分析？因为这题包含了很多东西： </p>
<ul>
<li><strong>纯回溯</strong></li>
<li><strong>纯回溯<code>---&gt;</code>回溯Top-down DP</strong></li>
<li><strong>回溯Top-Down DP<code>---&gt;</code>迭代Bottom-up DP</strong></li>
<li><strong>迭代Bottom-up DP<code>---&gt;</code>线性贪婪</strong></li>
</ul>
<p>分析完之后你会发现，原来算法可以这么美妙😃</p>

          <h3>
            <a name="_root-Jump Game" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Jump Game
          </h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p><strong>Determine if you are able to reach the last index.</strong></p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.:</code></pre>
          <h4>
            <a name="_root-1. Backtracking" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            1. Backtracking
          </h4><p>无论是I还是II，我最开始只能想到的就是回溯法，而回溯法用于解这两题是会炸的，因为时间复杂度和递归栈太多了，单作为DP的第一步，我们还是先把回溯写出来</p>
<pre><code class="language-java">public boolean canJump(int[] nums) {
    return backtracking(nums, 0);
}

private boolean backtracking(int[] nums, int now) {
    if (now == nums.length - 1) {
        return true;
    } else {
        // 从允许的最大跳数开始跳
        int maxStep = nums[now];
        if (now + maxStep &gt;= nums.length) {
            maxStep = nums.length - now - 1;
        }
        for (int i = maxStep; i &gt;= 1; i--) {
            if (backtracking(nums, now + i)) {
                return true;
            }
        }
    }
    return false;
}</code></pre>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : <strong>O(2^n)</strong>. There are <strong>2^n</strong> (upper bound) ways of jumping from the first position to the last, where <em>n</em> is the length of array <code>nums</code>. For a complete proof, please refer to Appendix A.</li>
<li>Space complexity : <strong>O(n)</strong>. Recursion requires additional memory for the stack frames. </li>
</ul>

          <h4>
            <a name="_root-2. Memorization: DP Top-down" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            2. Memorization: DP Top-down
          </h4><p>也许你已经意识到了，我们仅仅是想知道每一个位置是否能跳到最后一格而已，但是某个位置可能会有从不同地方跳过来的，如果第一次跳过来的时候，这时候肯定不知道这个位置能不能到达，然后从这个位置继续往下跳的时候就能回溯出一个结果来，如果我们将这个结果记录下来的话，那么第二次有从其他地方跳过来的时候，我们就知道这个位置往下走到底是个什么结果，这样就不必再继续往下跳然后等回溯了；</p>
<p>于是我们将每个位置的回溯结果记忆化：能到终点代表<strong><em>GOOD</em></strong>、不能到终点代表<strong><em>BAD</em></strong>、没尝试过代表<strong><em>UNKNOWN</em></strong></p>
<p>比如Leetcode上的例子：</p>
<p>An example of a memorization table for input array <code>nums = [2, 4, 2, 1, 0, 2, 0]</code> can be seen in the diagram below. We write <strong>G</strong> for a <em>GOOD</em> position and <strong>B</strong> for a <em>BAD</em> one. We can see that we cannot start from indices 2, 3 or 4 and eventually reach last index (6), but we can do that from indices 0, 1, 5 and (trivially) 6.</p>
<table>
<thead>
<tr>
<th>Index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>nums</td>
<td>2</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>memo</td>
<td>G</td>
<td>G</td>
<td>B</td>
<td>B</td>
<td>B</td>
<td>G</td>
<td>G</td>
</tr>
</tbody></table>
<p><strong>Steps</strong></p>
<ol>
<li>Initially, all elements of the <code>memo</code> table are <strong><em>UNKNOWN</em></strong>, except for the last one, which is (trivially) <strong><em>GOOD</em></strong> (it can reach itself)</li>
<li>Modify the backtracking algorithm such that the recursive step first checks if the index is known (<strong><em>GOOD</em></strong>/ <strong><em>BAD</em></strong>)<ol>
<li>If it is known then return <em>True</em> / <em>False</em></li>
<li>Otherwise perform the backtracking steps as before</li>
</ol>
</li>
<li>Once we determine the value of the current index, we store it in the <code>memo</code> table</li>
</ol>
<pre><code class="language-java">public class Solution {
    enum Index {
        GOOD, BAD, UNKNOWN
    }
    Index[] memo;
    public boolean canJumpFromPosition(int position, int[] nums) {
        if (memo[position] == Index.BAD) {
            return false;
        } else if (memo[position] == Index.GOOD) {
            return true;
        } else {
            int maxStep = Math.min(nums[position], nums.length - position - 1);
            for (int i = maxStep; i &gt; 0; i--) {
                if (canJumpFromPosition(position + i, nums)) {
                    memo[position + maxStep] = Index.GOOD;
                    return true;
                }
            }
            memo[position] = Index.BAD;
            return false;
        }
    }

    public boolean canJump(int[] nums) {
        memo = new Index[nums.length];
        for (int i = 0; i &lt; nums.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[nums.length - 1] = Index.GOOD;
        return canJumpFromPosition(0, nums);
    }
}</code></pre>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : <strong>O(n^2)</strong> For every element in the array, say <code>i</code>, we are looking at the next <code>nums[i]</code> elements to its right aiming to find a <em>GOOD</em> index. <code>nums[i]</code> can be at most <em>n</em>, where <em>n</em> is the length of array <code>nums</code>.</li>
<li>Space complexity : <strong>O(2n) =O(n)</strong>. First n originates from recursion. Second n comes from the usage of the memo table. </li>
</ul>
<p>送算减少了很多的回溯了，时间复杂度也从2的n次方降到n的2次方了，这回提交到Leetcode，打了11.11%</p>

          <h4>
            <a name="_root-3. Memorization: DP Bottom-up" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            3. Memorization: DP Bottom-up
          </h4><p>上篇练习过挺多DP的，但是都没仔细研究过<strong>自顶向下</strong>和<strong>自底向上</strong>，正好借这题来分析分析</p>
<p>我们的问题，若是要从一头到另一头，比如这一题，需要从起点跳到终点，然后从终点回溯回来（也许是跳到了之前回溯好了的结果），这样才能知道结果，形式化的想象一下，我们主动地发送请求到服务端，然后服务端返回结果，这是一个过去/回来的过程；</p>
<p>如果我们能直接从服务端返回结果，那么就少花一半以上的effort，也就是说，我们可以从终点直接往回走！</p>
<p>因为我们起点部分的点的结果，都是从终点附近的后半段点的结果递归回来的，我们这样做是提前从后半段算回结果</p>
<p>于是我们可以通过两个for循环，消除回溯调用栈</p>
<pre><code class="language-java">enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    public boolean canJump(int[] nums) {
        Index[] memo = new Index[nums.length];
        for (int i = 0; i &lt; nums.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[nums.length - 1] = Index.GOOD;

        for (int i = nums.length - 2; i &gt;= 0; i--) {
            int maxStep = Math.min(nums[i], nums.length - i - 1);
            // 从当前position的第一步开始
            for (int j = i + 1; j &lt;= i + maxStep; j++) {
                if (memo[j] == Index.GOOD) {
                    memo[i] = Index.GOOD;
                    break;
                }
            }
        }

        return memo[0] == Index.GOOD;
    }
}</code></pre>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : <strong>O(n^2)</strong>. For every element in the array, say <code>i</code>, we are looking at the next <code>nums[i]</code> elements to its right aiming to find a <em>GOOD</em> index. <code>nums[i]</code> can be at most <em>n</em>, where <em>n</em> is the length of array <code>nums</code>.</li>
<li>Space complexity : <strong>O(n)</strong>. This comes from the usage of the memo table. </li>
</ul>
<p>我们又优化了一下DP，这次打了30.77%，似乎还不错，再看看能不能再有什么优化的地方</p>

          <h4>
            <a name="_root-4. Refine The DP" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            4. Refine The DP
          </h4><p>如果我们减负去很多题目以外的概念的话，我们将会得到一个很简单的Memo模型：和自底向上一样，只不过我们不需要考虑什么<strong><em>UNKNOWN</em></strong></p>
<pre><code class="language-java">public boolean canJump(int[] nums) {
    boolean[] can = new boolean[nums.length];
    can[nums.length - 1] = true;
    for (int i = nums.length - 2; i &gt;= 0; i--) {
        int steps = nums[i];
        for (int j = i + 1; j &lt; nums.length &amp;&amp; j &lt;= i + steps; j++) {
            if  (can[j]) {
                can[i] = true;
                break;
            }
        }
    }
    return can[0];
}</code></pre>
<p>这次打了34.76%，别看和上面的没提升多少，相比之下这已经减少了1倍以上的耗时了，我们似乎已经达到了这道题DP的极限了，再靠DP的思维已经无法再进行优化了，这时候我告诉你，差一步你就能将这个DP转为线性解法，你可能会崩溃</p>

          <h4>
            <a name="_root-5. Greedy" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            5. Greedy
          </h4><p>从上面的DP我们可以发现，每当我们的到达一个新的位置（i）的时候，它就会往后找，找到一个GOOD就break掉，于是我们就认为这个新位置也是GOOD，而这个被找到的GOOD，就是当前新位置能reach到的第一个GOOD，因为一旦reach到这个GOOD，那么其他case就不比再考虑了，所以我们才break；</p>
<table>
<thead>
<tr>
<th>Index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>nums</td>
<td>9</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>memo</td>
<td>U</td>
<td>G</td>
<td>B</td>
<td>B</td>
<td>B</td>
<td>G</td>
<td>G</td>
</tr>
</tbody></table>
<p>那么如果说，我们每次都记录最后的GOOD的位置，于是我们仅仅需要计算，<strong>当前位置能不能reach到这个GOOD</strong>就行了，而这一步甚至不需要迭代，只要当前位置能跳的距离大于等于这个GOOD的位置就好了，于是我们可以从后往前线性地得到题解：</p>
<pre><code class="language-java">public boolean canJump(int[] nums) {
    int lastPos = nums.length - 1;
    for (int i = nums.length - 1; i &gt;= 0; i--) {
        if (i + nums[i] &gt;= lastPos) {
            lastPos = i;
        }
    }
    return lastPos == 0;
}</code></pre>

          <h3>
            <a name="_root-Jump Game II" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Jump Game II
          </h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.</code></pre>
          <h4>
            <a name="_root-1. Backtracking - O(2^n)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            1. Backtracking - O(2^n)
          </h4><p>不多BB</p>
<pre><code class="language-java">public int jump(int[] nums) {
    return dfs(nums, 0, 0, Integer.MAX_VALUE);
}

private int dfs(int[] nums, int now, int jump, int minJump) {
    if (jump &gt;= minJump) {
        return minJump;
    }
    if (now == nums.length - 1) {
        return Math.min(jump, minJump);
    } else {
        int subJump = Integer.MAX_VALUE;
        for (int i = 1; i &lt;= nums[now] &amp;&amp; now + i &lt; nums.length; i++) {
            subJump = Math.min(dfs(nums, now + i, jump + 1, minJump), subJump);
        }
        return Math.min(subJump, minJump);
    }
}</code></pre>
<p>不用多想，时间复杂度爆掉了</p>

          <h4>
            <a name="_root-2. DP Bottom-up - O (n^2)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            2. DP Bottom-up - O (n^2)
          </h4><pre><code class="language-java">public int jump(int[] nums) {
    int[] dp = new int[nums.length];
    for (int i = nums.length - 2; i &gt;= 0; i--) {
        // one jump to the end
        if (i + nums[i] &gt;= nums.length) {
            dp[i] = 1;
        } else {
            // jump max step if it can reach the end
            int tmp = Integer.MAX_VALUE;
            for (int j = i + 1; j &lt;= i + nums[i]; j++) {
                if (dp[j] != Integer.MAX_VALUE) {
                    tmp = Math.min(tmp, dp[j] + 1);
                }
            }
            dp[i] = tmp;
        }
    }
    return dp[0];
}</code></pre>

          <h4>
            <a name="_root-3. BFS - O (n)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            3. BFS - O (n)
          </h4><p>参考自：<a href="https://leetcode.com/problems/jump-game-ii/discuss/18019/10-lines-C%252B%252B-(16ms)-Python-BFS-Solutions-with-Explanations">10-lines C++ (16ms) / Python BFS Solutions with Explanations</a></p>
<p>如果我们仅观察步数的增长的话，我们其实能够把数组视为一棵以跳数来分层的数结构，这也是这道题能够用广度优先搜索来思考的关键点</p>
<p>比如<code>nums = [2, 3, 1, 1, 4]</code>，第一层是我们的起点<code>2</code>，它能够到达的下一层数字有<code>3,1</code>，而<code>3,1</code>的下一跳能够到达的是<code>1,4</code>如此一来我们仅需要跳2层就能够到达终点了；</p>
<p>再比如<code>nums = [2, 6, 5, 2, 3, 7, 4, 9, 8, 2, 1, 1]</code>，第一层<code>2</code>，第二层<code>6, 5</code>，第三层<code>2,3,7,4,9</code>，因为最多能从<code>i = 1, nums[1] = 6</code>跳到<code>nums[1 + 6] = nums[7] = 9</code>，然后第三层的第一个数必定是第二层结尾的下一个数，以此类推第四层<code>2, 1, 1</code></p>
<pre><code class="language-java">public int jump(int[] nums) {
    int jump = 0;
    int start = 0, end = 0;
    // when end reach the final index
    // that means we finish the jump
    while (end &lt; nums.length - 1) {
        // jump first
        jump++;
        // at least one position on next floor
        int tmpEnd = end + 1;
        for (int i = start; i &lt;= end; i++) {
            // hit the final straight
            if (i + nums[i] &gt; nums.length) {
                return jump;
            }
            tmpEnd = Math.max(tmpEnd, i + nums[i]);
        }
        // visit next floor
        start = end + 1;
        end = tmpEnd;
    }
    return jump;
}</code></pre>

          <h3>
            <a name="_root-Edit Distance" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Edit Distance
          </h3><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
Output: 3
Explanation: 
horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)
rorse -&gt; rose (remove &#39;r&#39;)
rose -&gt; ros (remove &#39;e&#39;)</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
Output: 5
Explanation: 
intention -&gt; inention (remove &#39;t&#39;)
inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)
enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)
exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)
exection -&gt; execution (insert &#39;u&#39;)</code></pre>
          <h4>
            <a name="_root-DP Top-down" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            DP Top-down
          </h4><p>这题，乍一看一脸懵逼，咋还有3种情况！咋还随便什么位置都能有这三种情况！怎么玩！用什么思路！</p>
<p>思考几分钟后无果，果断去讨论区找思路，然后看到高评DP解，醍醐灌顶- -</p>
<p>简单来说，虽然对比到有不同有<strong>33333333333333</strong>种情况，但是我们还是可以按照顺序来给两个word做一个矩阵，于是熟悉的操作就来了，</p>
<pre><code class="language-java">a = ac, b = ae

     j = 0 1
         a e
i = 0 a  0 1
    1 c  1 1

我们看到，当我们走到i = 1，j = 1的时候，我们有3种选择：
1. 直接替换，于是操作数在a -&gt; a的基础上+1；
2. 删除c，我们在ac -&gt; a完成之后的基础上，继续进行a -&gt; ae；
3. 插入e，我们在ac -&gt; aec完成之后的基础上，继续进行aec -&gt; ae；

（上面这一套是巨难理解的地方）

于是在这3个选择中选最小值</code></pre>
<p>矩阵都来了，dp就完事了，于是我们可以想象一下状态转移公式：</p>
<pre><code class="language-java">String a,b

F(i, j) = {
    if a.charAt(i) == b.charAt(j)
        dp[i][j] = dp[i - 1][j - 1];
    else
        dp[i][j] = min of {
            dp[i - 1][j - 1],    // replace
            dp[i][j - 1],        // insert
            dp[i - 1][j]        // delete
        } + 1
}

base case：
    dp[i][0] = i;
    dp[0][j] = j;</code></pre>
<p>于是代码为：</p>
<pre><code class="language-java">public int minDistance(String word1, String word2) {
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];
    for (int i = 0; i &lt;= word1.length(); i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j &lt;= word2.length(); j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i &lt;= word1.length(); i++) {
        for (int j = 1; j &lt;= word2.length(); j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                // same as before
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1
                        + Math.min(
                                // replace
                                dp[i - 1][j - 1],
                        Math.min(
                                // delete
                                dp[i - 1][j],
                                // insert
                                dp[i][j - 1]));
            }
        }
    }
    return dp[word1.length()][word2.length()];
}</code></pre>

          <h4>
            <a name="_root-DP Bottom-up + Backtracking" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            DP Bottom-up + Backtracking
          </h4><p>我们还可以用回溯的形式去计算dp，也就是说以自底向上的思路去求解</p>
<pre><code class="language-java">public int minDistance(String a, String b) {
    int[][] dp = new int[a.length() + 1][b.length() + 1];
    return dfs(a, b, a.length() - 1, b.length() - 1, dp);
}

private int dfs(String a, String b, int i, int j, int[][] dp) {
    if (i == -1) {
        return j + 1;
    }
    if (j == -1) {
        return i + 1;
    }
    if (dp[i][j] == 0) {
        if (a.charAt(i) == b.charAt(j)) {
            dp[i][j] = dfs(a, b, i - 1, j - 1, dp);
        } else {
            dp[i][j] = 1
                    + Math.min(
                            dfs(a, b, i - 1, j - 1, dp),
                    Math.min(
                            dfs(a, b, i - 1, j, dp),
                            dfs(a, b, i, j - 1, dp)));
        }
    }
    return dp[i][j];
}</code></pre>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>