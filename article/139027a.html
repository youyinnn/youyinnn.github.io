<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="http://pv.sohu.com/cityjson?ie=utf-8"></script>
    <script>
        if (location.hostname === 'youyinnn.github.io' && returnCitySN.cname === 'CHINA') {
            location.href = 'https://youyinnn.gitee.io' + location.pathname
        }
    </script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">


    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn" type="button" title="clear search">cls</button>
                <button id="categories" class="btn" type="button">cates</button>
                <button id="tags" class="btn" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-前言" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            前言
          </h3><p>不知不觉写到第六坎了，前面刀剑磨刀石内功心法都有了，感觉自己应该很厉害了，其实不是，这一个月因为考试末尾和实习，断断续续的看，反反复复的看，越看越精神，越看越心虚。</p>
<p>无论怎么说，短板还是得慢慢补上来，保持谦逊，虚心学习。</p>
<p>回到整体，前面由内到外说了Java并发中很基本的几件事：</p>
<ul>
<li>基本的线程API和使用</li>
<li>基本的并发概念</li>
<li>volatile和synchronized和锁概念</li>
</ul>
<p>我觉得是时候得停一下，综合一下这些东西，真刀真枪干几次，所以这篇算是我们并发游戏世界中，主人翁的<strong>“初出茅庐”</strong>篇，又可以叫做小试牛刀，在这篇我尝试例出并发编程中最基本的场景如：</p>
<ul>
<li><strong>死锁</strong></li>
<li><strong>“等待-通知”</strong></li>
<li><strong>有超时的“等待-通知”</strong></li>
<li><strong>“生产者-消费者”模式</strong></li>
<li><strong>双重检查锁延迟初始化的错误与正确示范</strong></li>
</ul>
<hr>

          <h3>
            <a name="_root-死锁" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            死锁
          </h3><p>死锁是多个以上的process互相等待对方释放资源而进入永久等待的一种情况，要产生死锁，就必须同时满足一下四个条件：</p>
<ul>
<li><p><strong>互斥条件</strong></p>
<p>  ​    即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。</p>
</li>
<li><p><strong>不可抢占条件</strong></p>
<p>  ​    进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。</p>
</li>
<li><p><strong>占有且申请条件</strong></p>
<p>  ​    进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。</p>
</li>
<li><p><strong>循环等待条件</strong></p>
<p>  ​    存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。</p>
</li>
</ul>
<p>死锁的处理可以分为：预防，避免，检测和解除</p>

          <h4>
            <a name="_root-死锁预防" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            死锁预防
          </h4><p>这是一种较为简单、直观的事先预防方法，方法是破坏产生死锁的4个条件，就算破坏一个，死锁也不会产生。这是一种静态方法。</p>

          <h4>
            <a name="_root-死锁避免" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            死锁避免
          </h4><p>系统在运行时分配资源的时候，能够对资源分配情况进行动态检查，如果结果良好，则允许分配，如果结果显示分配后会出现死锁，则不予分配。这是一种动态方法。</p>

          <h4>
            <a name="_root-检测和解除" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            检测和解除
          </h4><ul>
<li><p>检测</p>
<p>  ​    不事先采取限制措施，也不检测系统是否进入安全区，运行系统在运行时发生死锁，但是会通过系统设置的检查机制，检测出死锁发生的地方。</p>
</li>
<li><p>解除</p>
<p>  ​    检测到死锁地点之后，解除死锁状态</p>
</li>
</ul>
<p>例：</p>
<pre><code class="language-java">public class DeadLock {
    private static StringBuffer a = new StringBuffer();
    private static StringBuffer b = new StringBuffer();
    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (a){
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (b){}
            }
        }).start();
        new Thread(() -&gt; {
            synchronized (b){
              synchronized (a){}
            }
        }).start();
    }
}</code></pre>

          <h3>
            <a name="_root-“等待-通知”" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            “等待-通知”
          </h3><blockquote>
<p>在就餐的时候，厨师和服务员之间的交互就是一种等待通知模式：</p>
<ol>
<li>厨师需要一定的时间去做菜</li>
<li>厨师没做好菜的时候，服务员就没活干了，所以服务员就有（wait）的状态</li>
<li>服务员取菜的时机是取决于厨师的，只有当厨师将菜放到“台面”上，并“通知（notify）”服务员，服务员菜开始干活</li>
</ol>
</blockquote>

          <h4>
            <a name="_root-范式" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            范式
          </h4><pre><code class="language-java">synchronized(对象) {
    while(退出等待的条件不满足){
        对象.wait();
    }
    // 等待完后的工作
}</code></pre>
<pre><code class="language-java">synchronized(对象){
    // 改变退出等待的条件
    对象.notifyAll()；
}</code></pre>

          <h4>
            <a name="_root-实现" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            实现
          </h4><pre><code class="language-java">public class WaitNotifyParadigm {

    private static String lock = &quot;lock&quot;;
    private static boolean wait = true;

    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (lock) {
                System.out.println(&quot;T1 started to wait...&quot;);
                while (wait) {
                    try {
                        lock.wait(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(&quot;T1 stop waitting !&quot;);
            }
        }).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 3; i++) {
                System.out.println(&quot;T2 processing: &quot; + (i + 1));
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            synchronized (lock) {
                System.out.println(&quot;T2 done process, notifyAll...&quot;);
                wait = false;
                lock.notifyAll();
            }
        }).start();
    }
}</code></pre>
<p>结果：</p>
<pre><code class="language-console">T1 started to wait...
T2 processing: 1
T2 processing: 2
T2 processing: 3
T2 done process, notifyAll...
T1 stop waitting !</code></pre>

          <h4>
            <a name="_root-有超时的“等待-通知”" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            有超时的“等待-通知”
          </h4><p>要搭配<code>wait()</code>的超时机制的话，就得在条件中也考虑超时，我们可以加两个变量来完成超时：</p>
<ul>
<li>left：表示剩余多少时间就超时</li>
<li>end：表示超时时间的完整毫秒数</li>
</ul>
<pre><code class="language-java">public class WaitNotifyParadigmWithTimeout {

    private static String lock = &quot;lock&quot;;
    private static boolean wait = true;
    private static long timeout = 5000;

    public static void main(String[] args) {
        new Thread(() -&gt; {
            synchronized (lock) {
                System.out.println(&quot;T1 started to wait...&quot;);
                long left = timeout;
                long end = System.currentTimeMillis() + timeout;
                while (wait &amp;&amp; left &gt; 0) {
                    try {
                        lock.wait(left);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    left = end - System.currentTimeMillis();
                }
                System.out.println(&quot;T1 stop waitting !&quot;);
            }
        }).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                System.out.println(&quot;T2 processing: &quot; + (i + 1));
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            synchronized (lock) {
                System.out.println(&quot;T2 done process, notifyAll...&quot;);
                wait = false;
                lock.notifyAll();
            }
        }).start();
    }
}</code></pre>

          <h3>
            <a name="_root-“生产者/消费者”" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            “生产者/消费者”
          </h3><p>利用wait/notify机制，先上一段多消费者/多生产者的示例</p>
<pre><code class="language-java">public class TestProducerConsumer2 {

    static Integer limit = 50;
    static volatile Integer stock = 0;
    static final String P_LOCK = &quot;p&quot;;
    static final String C_LOCK = &quot;c&quot;;

    public static void main(String[] args) {
        new Thread(new Producer2(&quot;P-1&quot;)).start();
        new Thread(new Consumer2(&quot;C-1&quot;)).start();
        new Thread(new Consumer2(&quot;C-2&quot;)).start();
    }
}

class Producer2 implements Runnable {

    private String name;

    public Producer2(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        while (true) {
            if (TestProducerConsumer2.stock &lt; TestProducerConsumer2.limit) {
                System.out.println(&quot;Producing&quot;);
                while (TestProducerConsumer2.stock &lt; TestProducerConsumer2.limit) {
                    synchronized (TestProducerConsumer2.P_LOCK) {
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        TestProducerConsumer2.stock++;
                        System.out.println(&quot;Produced the &quot; + TestProducerConsumer2.stock + &quot; stock&quot;);
                    }
                }
                System.out.println(&quot;Produce process done&quot;);
                synchronized (TestProducerConsumer2.C_LOCK) {
                    TestProducerConsumer2.C_LOCK.notifyAll();
                }
            }
            synchronized (TestProducerConsumer2.P_LOCK) {
                try {
                    TestProducerConsumer2.P_LOCK.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class Consumer2 implements Runnable {

    private String name;

    public Consumer2(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        while (true) {
            if (TestProducerConsumer2.stock &gt;= TestProducerConsumer2.limit) {
                System.out.println(name + &quot; consuming&quot;);
                while (TestProducerConsumer2.stock &gt; 0) {
                    synchronized (TestProducerConsumer2.C_LOCK) {
                        System.out.println(name + &quot; consumed the &quot; + TestProducerConsumer2.stock + &quot; stock&quot;);
                        TestProducerConsumer2.stock--;
                    }
                }
                System.out.println(name + &quot;consume process done&quot;);
                synchronized (TestProducerConsumer2.P_LOCK) {
                    TestProducerConsumer2.P_LOCK.notifyAll();
                }
            }
            synchronized (TestProducerConsumer2.C_LOCK) {
                try {
                    TestProducerConsumer2.C_LOCK.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<p>目标item是stock，我们用<code>volatile</code>来保证其在P/C之间的可见性</p>
<p>P/C之间各通过对方的LOCK来唤醒对方</p>
<p>生产/消费到达limit之后，各在自己的LOCK上等待</p>
<p>消费者之间通过消费者LOCK保证消费同步，生产者之间通过生产者LOCK保证生产同步</p>

          <h3>
            <a name="_root-双重检查锁延迟初始化的错误与正确示范" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            双重检查锁延迟初始化的错误与正确示范
          </h3><p>关于双重检查锁的由来就不再多说，我们看看双重检查的错误示范：</p>
<pre><code class="language-java">public class DoubleCheckLocking {
    private static Instance instance;
    public static Instance getInstance() {
        if (instance == null) {                            // 第一次检查
            synchronized(DoubleCheckLocking.class) {    // 加锁
                if (instance == null) {                    // 第二次检查
                    instance = new Instance();            // 初始化：这里有坑
                }
            }
        }
        return instance;
    }
}</code></pre>
<blockquote>
<p>双重检查锁看起来很完美，但是这是一个没有考虑完整的优化！</p>
<p>在线程执行到line4的时候，代码读取到instance不为空，但是instance所引用的对象可能还没有完成对象初始化</p>
<p>即现在不为空的对象其实并不具备工作能力</p>
</blockquote>

          <h4>
            <a name="_root-探究" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            探究
          </h4><p>代码的第七行（<code>instance = new Instance();</code>）问题就出在这里，我们可以把这句话分解为以下三行：</p>
<ol>
<li>memory = allocate();        // 1 分配对象的内存空间</li>
<li>ctorInstance(memory);       // 2 初始化对象</li>
<li>instance = memory;            // 3 设置instance指向刚分配的内存地址</li>
<li>// 后续对instance对象的访问</li>
</ol>
<p>上面的2、3行代码，在某些编译器中可能会被重排序，可能是3先2后，这就是所谓的，对象不为空，但是对象并不具备工作的可能，为什么JMM会允许这样的重排序？说白了，JMM重排序，允许这样的重排序因为在单线程情况下这样的重排序并不影响程序结果，1234无论怎样，只要保证2在4之前就好了</p>
<p>这样的重排序在<code>单线程</code>的情况下是能安全地起到优化作用的，但是在多线程的情况下就会出问题了，我们看一个表：</p>
<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">线程A</th>
<th align="center">线程B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">t1</td>
<td align="center">A1：分配对象的内存空间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t2</td>
<td align="center">A3：设置instance指向内存空间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t3</td>
<td align="center"></td>
<td align="center">B1：判断instance是否为空</td>
</tr>
<tr>
<td align="center">t4</td>
<td align="center"></td>
<td align="center">B2：不为空，访问instance引用的对象</td>
</tr>
<tr>
<td align="center">t5</td>
<td align="center">A2：初始化对象</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">t6</td>
<td align="center">A4：访问instance引用的对象</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在t4时刻，线程B访问到的对象是不具备工作能力的对象，这样的对象没有意义。</p>
<p>我们要修正这个错误，有两种办法：</p>
<ul>
<li>禁止2和3的重排序</li>
<li>允许重排序，但是禁止其他线程感知到这个重排序</li>
</ul>

          <h4>
            <a name="_root-基于volatile的解决方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            基于volatile的解决方法
          </h4><pre><code class="language-java">public class SafeDoubleCheckLocking {
    private static volatile Instance instance;
    public static Instance getInstance() {
        if (instance == null) {                            
            synchronized(SafeDoubleCheckLocking.class) {    
                if (instance == null) {                    
                    instance = new Instance();            
                }
            }
        }
        return instance;
    }
}</code></pre>
<p>将instance声明为volatile变量，这样做可以<strong>禁止2和3的重排序</strong></p>

          <h4>
            <a name="_root-基于内部类和类初始化的解决方案" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            基于内部类和类初始化的解决方案
          </h4><p>在JVM初始化类的时候，JVM首先会获取一个锁，保证多个线程同时初始化这个类的同步性，而类的加载和初始化工作，会准备好类中所有的静态变量</p>
<p>基于这个特性，我们可以有另外一种线程安全的延迟初始化方案——<code>Initialization On Demand Holder idiom</code></p>
<pre><code class="language-java">public class InstanceFactory {
    private statci class InstanceHolder {
        public static Instance instance = new Instance();
    }
    public static Instance getInstance() {
        return InstanceHolder.instance;    // 如果是第一次引用，那么在这个地方就会加载上面那个内部类
    }
}</code></pre>
<p>这个方案的本质是：让其他线程看不到初始化类线程的内部重排序，只能感知到结果</p>
<p>等于说，我们做线程安全单例，其实只需要一个<strong>“一次性锁”</strong>，而类初始化的这个特性恰好就是一个<strong>“一次性锁”</strong></p>
<p>这个锁称之为——<strong>初始化锁（LC）</strong>，我们来看看书里是怎么介绍的：</p>
<blockquote>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁（LC）与之对应。从C到LC的映射，由JVM自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少要获取一次锁来确保这个类已经被初始化过了。</p>
</blockquote>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>