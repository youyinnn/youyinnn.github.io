<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script>
        if (location.hostname === 'youyinnn.github.io') {
            var xmlhttp = new XMLHttpRequest();
            xmlhttp.onreadystatechange = function() {
                if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
                    if (xmlhttp.responseText.search('CHINA') > 0) {
                        location.href = 'https://youyinnn.gitee.io' + location.pathname
                    }
                }
            }
            xmlhttp.open("GET", "https://pv.sohu.com/cityjson?ie=utf-8", true);
            xmlhttp.send();
        }
    </script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
    <script>
        importJsBeforeLoad()
    </script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn" type="button" title="clear search">cls</button>
                <button id="categories" class="btn" type="button">cates</button>
                <button id="tags" class="btn" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-前言" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            前言
          </h3><p>前一篇基本说了线程的基本概念和如何创建一个线程，以及非常基本的几个线程方法，接下来我们说说线程的前几个控制相关的方法，包括和暂停一个线程（PAUSE）、让暂停的线程恢复（RESUME）、让线程终止（STOP）</p>
<p>这篇我们但是这几个方法不能直接去用，因为这些方法都<strong>过期了</strong>！下面就着Java官方的文档解释，说说为什么过期这几个方法，以及贴出官方给的模板方法去实现这几个过期方法，具体的实现会在后面有例子</p>
<hr>

          <h4>
            <a name="_root-中断线程" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            中断线程
          </h4><p>我们现在已经可以跑起来一个线程了，但是对于线程的控制力度还不够，我们希望在处理线程子任务的时候，碰到需要暂停任务的情况的时候，我们有能力马上就退出</p>
<p>但是停止线程的任务并不简单，总的来说，停止线程的方式有这么三种：</p>
<ul>
<li><strong>让run方法执行完</strong>，线程就停了</li>
<li><strong>使用stop方法</strong>，但是这个方法<strong>绝对不能够使用</strong>，因为不安全而被列为<strong>过期方法</strong></li>
<li><strong>使用interrupt方法去中断线程</strong></li>
</ul>
<p>这么看来，如果要在线程任务中间去停止线程，只能使用<strong>interrupt方法</strong>，但是这个方法也<strong>不是说停就停</strong>的</p>

          <h5>
            <a name="_root-interrupt()" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            interrupt()
          </h5><p>我们来看看方法的源码介绍，方法注释就不解释了，注释里主要说的是一些异常信息，其实这个方法的本质<strong>只是在当前线程中打了一个中断标志，并不是真正地停止线程！</strong></p>
<pre><code class="language-java">public void interrupt() {
    if (this != Thread.currentThread())
        checkAccess();

    synchronized (blockerLock) {
        Interruptible b = blocker;
        if (b != null) {
            interrupt0();           // Just to set the interrupt flag
            b.interrupt(this);
            return;
        }
    }
    interrupt0();
}</code></pre>

          <h5>
            <a name="_root-判断线程中断" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            判断线程中断
          </h5><p><strong>Thread类</strong>中有两个方法可以用于判断线程是否中断，分别是：</p>
<ol>
<li><strong>Thread.interrupted()：测试当前线程是否已经中断</strong></li>
<li><strong>this.isInterrupted()：测试线程是否已经中断</strong></li>
</ol>
<p>很明显，这两个方法是有区别的，区别就在于<strong>“当前线程”</strong>是谁了，当前线程指的是运行<strong>Thread.interrupted()</strong>方法的代码段所在的线程</p>
<p>我们看源码：</p>
<pre><code class="language-java">public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}
public boolean isInterrupted() {
    return isInterrupted(false);
}
private native boolean isInterrupted(boolean ClearInterrupted);</code></pre>
<p>可以看到，<strong>interrupted()</strong>其实也是调用的<strong>本地方法isInterrupted(boolean clearInterrupted)</strong>，而且是<strong>当前线程（currendThread）去调用</strong>，所以这个方法是静态方法，而<strong>isInterrupted()</strong>同样也是调用<strong>本地方法isInterrupted(boolean clearInterrupted)</strong>，只是这个调用是通过this去调用的</p>
<p>还需要注意的是，<strong>interrupted()会清楚中断标识，而isInterrupted()不会</strong></p>

          <h5>
            <a name="_root-有效中断的方法" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            有效中断的方法
          </h5><p>前面我们说了，<strong>interrupted()</strong>方法只是设置中断flag，到底怎么真正停止线程呢？</p>
<p><strong>方法1：</strong></p>
<p>我们就可以使用上面的<strong>判断中断方法+程序流程设计</strong>去实行有效地中断</p>
<pre><code class="language-java">int i = 0;

@Test
public void testEffectedInterrupt() throws InterruptedException {
    Runnable run = () -&gt; {
        System.out.println(Thread.currentThread().getName());
        while (true) {
            if (Thread.currentThread().isInterrupted()) {
                System.out.println(&quot;interrupted!&quot;);
                break;
            }
            System.out.println(Thread.currentThread().isInterrupted());
            System.out.println(i++);
        }
    };
    Thread t = new Thread(run, &quot;runThread&quot;);
    t.start();
    Thread.sleep(10);
    t.interrupt();
}</code></pre>
<p><strong>runThread</strong>一直在跑，只不过在跑之前会判断一下自身线程的<strong>中断标志</strong>，如果被设置了<strong>中断标志</strong>，那while就break，也就是说方法已经执行完毕了，<strong>线程自然死亡</strong></p>
<p>当然这里是在main线程里面调用<strong>runThread</strong>的中断方法，<strong>runThread</strong>内部也可以不依靠中断方法去break语句，这里只是示例外部中断</p>
<p><strong>方法2：</strong></p>
<p>也许你可以使用<strong>interrupt()方法+return语句</strong>，和上面的break差不多骚，都是为了到达run方法的底部</p>
<blockquote>
<p>2018年7月9日 13点12分 补充如下：</p>
<p>我在Servlet中尝试使用interrupt()设置中断标识的方法去中断线程，但是很遗憾的是失败了，但是单独写在Main数中，或者在Android代码中去验证却是可以，不太清楚是不是Servlet对线程有什么影响，所以中断线程可以用官方给的模型去中断，即用一个volatile布尔变量去设置<code>run(){while()}</code>的run方法的while循环退出条件</p>
<p>搞懂为什么失败了，我在线程run方法中有<strong>Thread.sleep()</strong>方法，虽然我while循环最开始就有isInterrupt()方法做判断，但是大部分时间线程是在sleep()方法中的<code>TIMED_WAITING</code>状态下，在这个状态下使用interrupt()方法去中断线程会在sleep方法被调用处抛出<code>InterruptedException</code>异常，如果在catch语句中没有跳出循环的语句的话，下次while循环中的isInterrupt()仍然是false，因为一旦抛出<code>InterruptedException</code>异常就会<strong>清除线程的中断标志</strong></p>
<p>我们看看sleep的源码说明：</p>
<pre><code class="language-java">    /**
     * Causes the currently executing thread to sleep (temporarily cease
     * execution) for the specified number of milliseconds, subject to
     * the precision and accuracy of system timers and schedulers. The thread
     * does not lose ownership of any monitors.
     *
     * @param  millis
     *         the length of time to sleep in milliseconds
     *
     * @throws  IllegalArgumentException
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
     *          cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;</code></pre>
<p>之前实验的时候，使用到了sleep，使用interrupt怎么都测不到isInterrupted()为true，然后catch语句块里也没有做任何处理，所以线程始终无法停止，搞得我以为哪里出错了</p>
<p>关于怎么写stop、suspend、resume方法的代码贴在后面</p>
</blockquote>

          <h5>
            <a name="_root-关于stop()强制停止" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            关于stop()强制停止
          </h5><p>关于这个作废的方法，我们还是要说一下为什么这方法被作废了，当然最权威的介绍还是官方解释了<em><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html">Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?</a></em></p>
<p>官方给出的<strong>stop()过期解释</strong>：</p>
<blockquote>
<p>强制性地使用<strong>stop()</strong>方法会<strong>释放当前线程所持有的所有锁（监控器会因为ThreadDeath异常被抛到方法栈的最上层而解锁）</strong>，有的锁并不是我们期望释放掉的，所以这样会<strong>导致某些同步数据在并发且不完全锁上</strong>的情况下被修改，如果在这种<strong>状态</strong>不一致的情况下，事先有任何对象被这些监视器所保护着的话，其他的对象也会看到这些不一致的<strong>状态</strong>，我们可以认为，这些对象已经被<strong>破坏（damaged）</strong>了，再用这些对象去执行任务已经没有意义了</p>
<p>而且上述的影响很微妙，短时间内是无法检测出来的，因为不像其他<strong>非受检异常（unchecked exceptions）</strong>，<strong>ThreadDeath</strong>异常是一种<strong>静默异常</strong>，因此，如果程序因为这个异常而出错，用户通常是不会收到任何警告的，可能过个几个小时或者几天，程序才会因为最开始的<strong>强制停止</strong>所带来的长久影响而抛出某个业务中的异常</p>
</blockquote>
<p>官方解释中说明了，虽然从理论上，你可以抓取<strong>ThreadDeath</strong>异常去尝试修复被破坏的对象，<strong>但是这样的做法是不现实的：</strong>因为你需要非常严谨的逻辑去处理整个子任务，在这个严谨的过程中你还需要更严谨地去处理强制中断的破坏修复，这样的做法得不偿失，甚至代价超过任务本身，而且<strong>ThreadDeath</strong>这个异常在任何地方、任何时间都可以抛，你不确定这个异常是不是你想要的那个</p>
<p>最终官方给出了一个<strong>简单且有效</strong>的方法去实现线程停止：</p>
<pre><code class="language-java">private volatile Thread blinker;

public void stop() {
    blinker = null;
}

public void run() {
    Thread thisThread = Thread.currentThread();
    while (blinker == thisThread) {
        try {
            Thread.sleep(interval);
        } catch (InterruptedException e){
        }
        repaint();
    }
}</code></pre>
<p>如代码里面所示，线程一旦开启，就进入到<strong>run()</strong>方法的<strong>while循环</strong>里面，<strong>while循环</strong>退出的点是<strong>blinker等于当前线程</strong>的时候，我们只需要简单的<strong>在外部将这个同步变量置空</strong>，这样线程就会<strong>结束while循环——方法结束——退出线程</strong>，达到暂停线程的效果</p>
<p>但是这个方法还不够强，如果说，我们要让一个<strong>陷入长时间wait的线程中断的话（陷入wait就意味着线程卡在某个代码段那不继续往下执行了，而是等着抢资源）</strong>这个时候你就别指望说线程会跑到<strong>line：9</strong>去判断了</p>
<p>所以这里就该是我们的<strong>interrupt()方法</strong>登场了~</p>
<p>官方称，<strong>interrupt()</strong>方法就是为了这一刻而诞生的，上述例子的<strong>blinker = null</strong>也是一种有效的<strong>“基于状态”的信号机制</strong>，<strong>interrupt()</strong>方法也差不多是这个概念，它甚至可以中断等待</p>
<pre><code class="language-java">public void stop() {
    Thread moribund = waiter;
    waiter = null;
    moribund.interrupt();
}</code></pre>
<blockquote>
<p> 这个机制，对于在任何<strong>捕获到中断异常并且还没有准备好马上重新断言异常</strong>的方法来说很重要，我们常说<strong>宁可重新断言一个异常也不要抛出这个异常</strong>，因为重新抛出异常的做法并不总是好的</p>
<p>如果一个方法捕获到了<strong>没有声明过的中断异常</strong>，你应该让这个线程<strong>再中断它自己一次</strong></p>
<pre><code class="language-java">Thread.currentThread().interrupt();</code></pre>
<p>以保证它尽可能及时地发出中断异常</p>
</blockquote>

          <h5>
            <a name="_root-在sleep()里中断线程" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            在sleep()里中断线程
          </h5><p>没什么说的，<strong>sleep()</strong>的调用需要捕获中断异常，如果在<strong>sleep()</strong>的过程中中断异常的话，就会抛出<strong>中断异常</strong>，在<strong>catch语句块中处理中断的后续逻辑</strong>就好了，<strong><u>请一定要在catch块中做出中断处理！！！（原因见sleep的注意事项）</u></strong></p>

          <h4>
            <a name="_root-暂停/恢复线程" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            暂停/恢复线程
          </h4><p>同样的，因为不安全，<strong>suspend()和resume()</strong>方法也都过期了，禁止使用，在和<strong>stop()</strong>被过期的官方介绍中同样介绍了原因：</p>
<blockquote>
<p><strong>Thread.suspend</strong>方法有天生的死锁倾向</p>
<p>如果目标线程持有一个<strong>非常重要的系统资源的锁</strong>的时候，如果我们使用<strong>Thread.suspend</strong>去试图暂停这个线程的话，没有任何其它的线程可以访问到这个<strong>系统资源</strong>，除非再调用<strong>Thread.resume</strong>方法，线程执行完毕才有可能重新竞争这个资源</p>
<p>如果这个想要恢复已经暂停了的目标线程的线程<strong>试图要在监视器的锁内</strong>调用<strong>Thread.resume</strong>方法，这就是一个死锁，因为你把钥匙锁里面了</p>
<p>这种类型的死锁线程就是典型的<strong>“冻结”程序</strong></p>
</blockquote>
<p>官方也给出了安全实现暂停和恢复线程的示例：</p>
<p>比如说，你的应用程序中包含这个鼠标点击事件的事件处理器，这个处理器会出发一个交<strong>blinker</strong>的线程</p>
<pre><code class="language-java">private boolean threadSuspended;

Public void mousePressed(MouseEvent e) {
    e.consume();

    if (threadSuspended)
        blinker.resume();
    else
        blinker.suspend();  // DEADLOCK-PRONE!

    threadSuspended = !threadSuspended;
}</code></pre>
<p>上面这样的程序就会出现死锁倾向，<strong>自己暂停自己，自己又怎么能恢复自己呢？</strong>所以官方给出的解决代码是</p>

          <h5>
            <a name="_root-官方“恢复”代码" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            官方“恢复”代码
          </h5><pre><code class="language-java">public synchronized void mousePressed(MouseEvent e) {
    e.consume();

    threadSuspended = !threadSuspended;

    if (!threadSuspended)
        notify();
}</code></pre>
<p>然后在线程的run循环里面加上：</p>
<pre><code class="language-java">synchronized(this) {
    while (threadSuspended)
        wait();
}</code></pre>
<p>因为<strong>wait()</strong>方法会抛出<strong>中断异常</strong>，所以得包在try-catch语句中，你不妨在这里顺便睡上一小段时间，给程序一些缓冲时间好让线程在<strong>“恢复”</strong>之后可以马上执行<strong>repaint()方法（这里的repaint方法代表恢复之后要做的事情）</strong></p>
<pre><code class="language-java">public void run() {
    while (true) {
        try {
            Thread.sleep(interval);
            synchronized(this) {
                while (threadSuspended)
                    wait();
            }
        } catch (InterruptedException e){
        }
        repaint();
    }
}</code></pre>
<p>特别注意到：<strong>notify()和wait()</strong>方法都被包在<strong>同步块（synchronized block）</strong>中，这是Java语法要求这么做的，以保证这两个方法是<strong>绝对串行</strong>地工作，然而，保证同步的代价确实有点大，为了减小同步带来的代价，我们可以简单的用一些伎俩去优化上述的两段代码，这个伎俩也很简单，在进<strong>同步块</strong>之前，先判断一次<strong>threadSuspended</strong></p>
<pre><code class="language-java">if (threadSuspended) {
    synchronized(this) {
        while (threadSuspended)
            wait();
    }
}</code></pre>
<p>这样一来，我们得保证<strong>threadSuspended</strong>也得是<strong>线程安全</strong>的，我们可以用<strong>volatile</strong>关键字去修饰它</p>

          <h5>
            <a name="_root-官方”暂停“代码" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            官方”暂停“代码
          </h5><pre><code class="language-java">private volatile boolean threadSuspended;

public void run() {
    while (true) {
        try {
            Thread.sleep(interval);

            if (threadSuspended) {
                synchronized(this) {
                    while (threadSuspended)
                        wait();
                }
            }
        } catch (InterruptedException e){
        }
        repaint();
    }
}</code></pre>

          <h4>
            <a name="_root-实例" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            实例
          </h4><p>为了有多线程效果，把例子装在了servlet中用网页请求去运行</p>
<pre><code class="language-java">package mythread;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet(&quot;/xixi&quot;)
public class AThreadTest extends HttpServlet {

    private static Thread timer;
    private volatile boolean stoped = false;
    private volatile boolean suspended = false;

    @Override
    public void init() throws ServletException {
        timer = new Thread() {
            private int count = 0;

            @Override
            public void run() {
                if (!timer.getName().equals(&quot;Timer&quot;)) {                    
                    timer.setName(&quot;Timer&quot;);
                }
                System.out.println(Thread.currentThread() + &quot; started&quot;);
                while (!stoped) {
                    if (timer.isInterrupted()) {
                        System.out.println(&quot;interrupted break&quot;);
                        break;
                    }
                    try {
                        if (!stoped &amp;&amp; !suspended) {
                            count += 1;
                            System.out.println(Thread.currentThread() +  &quot; &quot; + count);
                            if (suspended) {
                                synchronized (timer) {
                                    while (suspended) {
                                        timer.wait();
                                    }
                                }                                                            
                            }
                        }
                        Thread.sleep(1000);
                    } catch (Exception e) {
                        System.out.println(&quot;exception because the interrupt when thread was in sleeping&quot;);
                        return;
                    }
                }
            }
        };
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String act = request.getParameter(&quot;act&quot;);
        switch (act) {
        case &quot;start&quot;:
            if (timer == null) {
                init();
            }
            timer.start();
            break;
        case &quot;stop&quot;:
            stop();
            break;
        case &quot;pause&quot;:
            pause();
            break;
        case &quot;resume&quot;:
            resume();
            break;
        case &quot;state&quot;:
            state();
            break;
        default:
            break;
        }
        response.sendRedirect(&quot;/Learning_zoom&quot;);
    }

    public void stop() {
        timer.interrupt();
//        stoped = true;
        System.out.println(&quot;stop&quot;);
    }

    public void pause() {
        suspended = true;
        System.out.println(&quot;pause&quot;);
    }

    public void resume() {
        suspended = false;
        if (!suspended) {
            synchronized (timer) {
                timer.notify();
                System.out.println(&quot;resume&quot;);
            }
        }
    }

    public void state() {
        System.out.print(&quot;status: &quot;);
        if (timer == null) {
            System.out.println(&quot;null&quot;);
        } else {            
            System.out.println(timer.getState());            
        }
    }

}
</code></pre>
<p>网页如下，线程过程中顺便还可以监控线程的状态</p>
<pre><code class="language-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;Insert title here&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

HelloWorld!

&lt;hr&gt;
Timer Test&lt;br&gt;

    &lt;a href=&quot;http://localhost:8080/Learning_zoom/xixi?act=start&quot;&gt;Start&lt;/a&gt;&lt;br&gt;
    &lt;a href=&quot;http://localhost:8080/Learning_zoom/xixi?act=stop&quot;&gt;Stop&lt;/a&gt;&lt;br&gt;
    &lt;a href=&quot;http://localhost:8080/Learning_zoom/xixi?act=pause&quot;&gt;Pause&lt;/a&gt;&lt;br&gt;
    &lt;a href=&quot;http://localhost:8080/Learning_zoom/xixi?act=resume&quot;&gt;Resume&lt;/a&gt;&lt;br&gt;
    &lt;a href=&quot;http://localhost:8080/Learning_zoom/xixi?act=state&quot;&gt;State&lt;/a&gt;&lt;br&gt;

&lt;hr&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>上面的例子中对于暂停的做法有三个处理，因为有45行的sleep代码，所以线程大多数时候都是处于sleep状态，这时候你想要用中断标志去停止线程是有点不太可能，所以我们需要在catch块中对sleep中断错误的处理进行停止的逻辑，比如可以直接return</p>
<p>如果想要看中断标志去停止线程的效果，可以把45行的sleep注掉，然后就可以看到用29-32行的那种中断标志+break的方式去中断了，当然你可能还会注意到还有一个volatile变量：stoped</p>
<p>你可以把84行的注释打开，这样可以用和暂停一样的思想去做中断，效果也是一样的</p>
<hr>
<p>好了<strong>第二坎</strong>就到这啦，神兵利器已经准备好啦！开始修炼内功！</p>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

    <script>
        importJsAfterLoad()
    </script>
</body>

</html>