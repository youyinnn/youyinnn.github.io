<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/myjs/import.js"></script>
    <script>
        importJsBeforeLoad()
    </script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn btn-dark" type="button" title="clear search">cls</button>
                <button id="categories" class="btn btn-dark" type="button">cates</button>
                <button id="tags" class="btn btn-dark" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn btn-dark" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-1. TwoSum(Easy)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            1. TwoSum(Easy)
          </h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p><strong>Example:</strong></p>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].</code></pre>
          <h4>
            <a name="_root-Ⅰ.Brute Force" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Ⅰ.Brute Force
          </h4><pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i &lt; nums.length; i++) {
        for (int j = i + 1; j &lt; nums.length; j++) {
            if (nums[j] == target - nums[i]) {
                return new int[] { i, j };
            }
        }
    }
    throw new IllegalArgumentException(&quot;No two sum solution&quot;);
}</code></pre>

          <h4>
            <a name="_root-Ⅱ.Hashing" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Ⅱ.Hashing
          </h4><p>Of all other Java solution with they call “hashing”, they just using JDK’s provided implementation, and it’s not a friendly solution for those who are not coding with Java.</p>
<p>And as I thinking about, it’s shit code that you are using <strong>a non-classic structure</strong> like <strong>“HashMap”, “ArrayList”</strong> and so on.</p>
<p>It’s ok that you using JDK’s implementation like <strong>“LinkedList”, “Stack”</strong> because their basic function were all implemented in the accepted ordinary way.</p>
<p>But using a structure like <strong>“HashMap”, “ArrayList”</strong>, it’s totally cheating because the algorithm inside them <strong>is not your work</strong>, and you probably don’t know how to implement <strong>HashMap’s</strong> treeify operation or <strong>ArrayList’s</strong> grow operation.</p>
<p>I see the solution to this Problem and I was disappointed with it.</p>
<pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(nums.length);
    for (int i = 0; i &lt; nums.length ; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[]{i, map.get(complement)};
        }
        map.put(nums[i], i);
    }
    return nums;
}</code></pre>
<p>So here is my solution about &quot;TwoSum&quot; with <strong>self implement &quot;hashing&quot;</strong>, it may not a nice code but it&#39;s friendly for all of you</p>
<pre><code class="language-java">// 4ms runtime 26~27MB memory use
// need to record val and index at the same time
class Pair {
    int val;
    int index;
}

// hash table
private Pair[] table;

// hash method just mod
private int hash(int key) {
    return Math.abs(key) % table.length;
}

// set hash table from origin sequence
private void setTable(int[] origin) {
    // table&#39;s rank is double
    int rank = origin.length &lt;&lt; 1;
    table = new Pair[rank];
    for (int i = 0; i &lt; origin.length; i++) {
        // detection the right place the key should set on hash table
        int place = detection(origin[i], false);
        Pair pair = new Pair();
        pair.val = origin[i];
        pair.index = i;
        table[place] = pair;
    }
}

// seek the key&#39;s position in hash table
private int seek(int key) {
    // seek key and return -1 if no key found in hash table
    return detection(key, true);
}

// collsion handle with just linear detection
private int detection(int key, boolean seek) {
    int hash = hash(key);
    // detect key&#39;s position in hash table at once hash()
    if (!seek &amp;&amp; table[hash] == null) {
        return hash;
    } else if (seek &amp;&amp; table[hash] == null) {
        // no match found
        return -1;
    } else if (seek &amp;&amp; table[hash].val == key) {
        // match key
        return hash;
    } else {
        // collsion handle with linear detection
        int offset = 1;
        boolean after = false;
        // linear detect forward
        while (hash + offset &lt; table.length) {
            if (!seek &amp;&amp; table[hash + offset] == null) {
                break;
            } else if (seek &amp;&amp; table[hash + offset] == null) {
                return -1;
            } else if (seek &amp;&amp; table[hash + offset].val == key) {
                return hash + offset;
            }
            offset++;
        }
        // liner detect backward
        if (hash + offset == table.length) {
            offset = 1;
            while (hash - offset &gt;= 0) {
                if (!seek &amp;&amp; table[hash - offset] == null) {
                    break;
                } else if (seek &amp;&amp; table[hash - offset] == null) {
                    return -1;
                } else if (seek &amp;&amp; table[hash - offset].val == key) {
                    return hash + offset;
                }
                offset++;
            }
        } else {
            after = true;
        }
        return after ? hash + offset : hash - offset;
    }
}

public int[] twoSum(int[] nums, int target) {
    setTable(nums);
    for (int i = 0; i &lt; nums.length; i++) {
        int complement = target - nums[i];
        int seek = seek(complement);
        if (seek != -1) {
            int index = table[seek].index;
            // handle case like [3, 3] target 6
            if (index == i) {
                if (seek + 1 &lt; table.length) {
                    index = table[seek + 1].index;
                } else {
                    index = table[seek - 1].index;
                }
            }
            // handle case like [3, 2, 4] target 6
            if (nums[index] + nums[i] == target) {
                return new int[]{i, index};
            }
        }
    }
    return nums;
}</code></pre>

          <h3>
            <a name="_root-2. Add Two Number(Medium)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            2. Add Two Number(Medium)
          </h3><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.</code></pre><p><img src="https://leetcode.com/problems/add-two-numbers/Figures/2_add_two_numbers.svg" alt=""></p>
<p>这题没什么tricky的，就是两个连各自的结点相加，关键是怎么记录各自链表的当前计算指针，并且处理好长短不一情况下的进位，下面是官方的solution：</p>
<pre><code class="language-java">// 由第三条新的链和它的计算指针完成
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummyHead;
    int carry = 0;
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry &gt; 0) {
        curr.next = new ListNode(carry);
    }
    return dummyHead.next;
}</code></pre>
<p>下面是我参照这种思路，针对空间优化的代码，所有计算在1链上进行，并处理了两条链长短不一样的情况，如果1链长，那么就继续计算carry；如果二链长，那么把二链剩余需要计算的链接到1链上，在1链上继续计算carry：</p>
<pre><code class="language-java">public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    boolean carry = false;
    ListNode ap = l1, bp = l2;
    while (ap != null || bp != null) {
        int count = carry ? 1 : 0;
        if (ap != null) {
            count += ap.val;
        }
        if (bp != null) {
            count += bp.val;
        }
        if (count &gt;= 10) {
            count = count % 10;
            carry = true;
        } else {
            carry = false;
        }

        if (ap != null) {
            ap.val = count;
            if (ap.next == null) {
                if (bp != null) {
                    ap.next = bp.next;
                    bp = null;
                    // 以防还有carry 在l2上记录l1最后一个结点
                    l2 = ap;
                } else if (carry) {
                    ap.next = new ListNode(1);
                    carry = false;
                    break;
                }
            }
            ap = ap.next;
        }
        if (bp != null) {
            bp = bp.next;
        }
    }
    if (carry) {
        l2.next = new ListNode(1);
    }
    return l1;
}</code></pre>

          <h3>
            <a name="_root-3. Longest Substring(Medium)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            3. Longest Substring(Medium)
          </h3><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;abcabcbb&quot;
Output: 3 
Explanation: The answer is &quot;abc&quot;, with the length of 3. </code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3. 
             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</code></pre>
          <h4>
            <a name="_root-ascii mapping" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            ascii mapping
          </h4><p>官方给出的解法，官方还给出了用HashMap和HashSet去解的</p>
<p><strong>ascii mapping</strong>这样的解法虽然知道<strong>第一目的</strong>是用ascii映射数组去记录上一次重复出现char的下标，但是官方的这个后续实现，不多看几眼，很难看出意图，所以我觉得这是一段没有灵魂的代码，里面的i、j已经完全没有灵魂了，难以理解</p>
<pre><code class="language-java">public class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(), ans = 0;
        int[] index = new int[128];
        for (int j = 0, i = 0; j &lt; n; j++) {
            i = Math.max(index[s.charAt(j)], i);
            ans = Math.max(ans, j - i + 1);
            index[s.charAt(j)] = j + 1;
        }
        return ans;
    }
}</code></pre>
<p>还是解一下逻辑：</p>
<ol>
<li><p>既然有下标，可以考虑用<strong>下标差</strong>去计算长度，而不是count出来</p>
</li>
<li><p>假设要表达的字符序列只在<strong>ascii-128</strong>中出现，于是我们可以用<strong>hash</strong>的方式，给出一个128位的数组<code>index</code>，数组用来记录<strong>上一次重复出现该ascii码字符的index的下一位（<code>index[s.charAt(j)] = j + 1</code>）</strong>，为什么是下一位？因为既然已经重复了，就从下一位开始计算所求序列</p>
<p> 比如说<strong>“a”</strong>这个序列，<strong>a</strong>的<strong>ascii</strong>是97，所以在<code>index</code>的97号上找index，这时候是0</p>
</li>
<li><p><strong>i</strong>的作用：获取最靠近<code>j</code>的<strong>有过重复的字符index的下一位</strong>，比如序列<strong>“abca”</strong>，当J循环到最后一个a的时候，i的值是上一个有过重复的a的index的下一位</p>
</li>
</ol>

          <h3>
            <a name="_root-4. Median of Two Sorted Arrays(Hard)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            4. Median of Two Sorted Arrays(Hard)
          </h3><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

The median is 2.0</code></pre><p><strong>Example 2:</strong></p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5</code></pre><p>这道题难就难在要找到<strong>O(log (m+n))</strong>的解，说到已排好序、log级，自然而然想到二分法，关键是怎么对两个已排序的数组进行统一二分法，找到中位数</p>
<p>在此先给出容易想到但是不符合题意的解<strong>(n+m)/2</strong>解</p>

          <h4>
            <a name="_root-Ⅰ.a (n+m)/2 solution" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Ⅰ.a (n+m)/2 solution
          </h4><p>分别从两个数组中取最小的数，然后取到两数组长度中位之后，自然就找到中位数了</p>
<pre><code class="language-java">public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    if (nums1.length &lt; nums2.length) {
        return findMedianSortedArrays(nums2, nums1);
    }
    int lengthSum = nums1.length + nums2.length;
    int mi = lengthSum / 2;
    int p1 = 0, p2 = 0;
    int[] tar = new int[mi + 1];
    for (int i = 0 ; i &lt;= mi; i++) {
        if (p1 == nums1 .length) {
            tar[i] = nums2[p2];
            continue;
        }
        if (p1 &lt;= nums1.length - 1 &amp;&amp; p2 &lt;= nums2.length - 1) {
            if (nums1[p1] &gt; nums2[p2]) {
                tar[i] = nums2[p2];
                p2++;
            } else if (nums1[p1] &lt; nums2[p2]) {
                tar[i] = nums1[p1];
                p1++;
            } else {
                tar[i++] = nums1[p1];
                if (i &lt; tar.length) {
                    tar[i] = nums1[p1];
                }
                p1++;
                p2++;
            }
        } else {
            tar[i] = nums1[p1];
            p1++;
        }
    }
    if (lengthSum % 2 == 0) {
        double a = tar[tar.length - 1];
        double b = tar[tar.length - 2];
        return (a + b) / 2;
    } else {
        return tar[tar.length - 1];
    }
}</code></pre>

          <h4>
            <a name="_root-Ⅱ. log(m+n) solution" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Ⅱ. log(m+n) solution
          </h4><p>对数级解非常不容易找出来，我觉得能解出来的都是数学家- -</p>
<p>对数级解决方案有2种，一种是<strong>泛化为“findKth”问题</strong>，另一种是<strong>“分治法寻找perfect I”</strong></p>

          <h5>
            <a name="_root-Perfect I" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Perfect I
          </h5><p>官方给出的<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/solution/">solution</a>就是它，为了解这个问题，首先我们从统计学上去了解一下什么是<strong>Medium</strong></p>
<blockquote>
<p>Dividing a set into two equal length subsets, that one subset is always greater than the other.</p>
<p>它将原集合分成等长的两个子集，其中一个子集中的任意元素总是大于另一个子集中的任意元素</p>
</blockquote>
<p>然后我们再了解一个<strong>切（Cut）</strong>的概念：</p>
<blockquote>
<p> 假设长度为m的A集合有随机一个<strong>cut</strong>出现在下标i的位置，那么有<strong>m + 1</strong>种可能的<strong>cut（0 ~ m）</strong></p>
<pre><code class="language-nhi">        left_A             |        right_A
  A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]</code></pre>
<p> 其中：</p>
<ul>
<li><p>len(left_A) = i, len(right_A) = m − i</p>
</li>
<li><p>when i = 0, <strong>left_A</strong> is empty, and when i = m, <strong>right_A</strong> is empty</p>
<p>类似地，对B我们可以：</p>
<pre><code class="language-nhi">     left_B             |        right_B
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</code></pre>
<p>A、B连在一起看，我们得出：</p>
<pre><code class="language-nhi">     left_part          |        right_part
A[0], A[1], ..., A[i-1]  | A[i], A[i+1], ..., A[m-1]
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]</code></pre>
<p>如果我们可以找到如下<strong>两个条件</strong>：</p>
</li>
</ul>
<ol>
<li><p><strong>len(left_part) = len(right_part)</strong></p>
</li>
<li><p><strong>max(left_part) ≤ min(right_part)</strong></p>
<p>那么我们就等于将全集<strong>{A, B}</strong>分为<strong>等长</strong>的2部分，且左半部分中的元素总是比右半部分中的元素要小</p>
<p>注意，<strong>等长</strong>概念在偶数全集里面比较容易展现，即左右两边元素个数相同，而在奇数集合里面，约定<strong>左集合比右集合多一个</strong>，所以奇数集合的中位数总是<strong>左集合中最大的那一个</strong></p>
<p>这时候<strong>Medium</strong>可以由 <strong>(max(left_part) + min(right_part)) / 2</strong> 得出！也即我们若是找到了正确的切点，那么也就找到了<strong>Medium</strong></p>
</li>
</ol>
</blockquote>
<p>于是我们按照以下步骤进行切点的寻找：</p>
<blockquote>
<ol>
<li><p>总是以较短的集合作为A集合，以短集合的长度去寻找<strong>Cut</strong></p>
</li>
<li><p>设置<code>iMin=0</code>，<code>iMax=m</code>，在[iMin, iMax]中寻找cut</p>
</li>
<li><p><code>i</code>为A的cut，它等于<code>(iMin + iMax) / 2</code>; <code>j</code>为B的cut，它等于<code>(m + n + 1) / 2 -i</code></p>
</li>
<li><p>现在我们切好了，满足了等长条件，于是我们判断切点是否是我们想要的，这将会有3种情况：</p>
<ul>
<li><p><code>B[j - 1] &lt;= A[i] &amp;&amp; A[i - 1] &gt;= B[j]</code></p>
<p>  意味着满足了条件二了，<code>i</code>和<code>j</code>正是我们要找的<strong>切点</strong>，找到了切点，就判断全集长度的奇偶性，从而求出<strong>Medium</strong></p>
</li>
<li><p><code>B[j - 1] &gt;  A[i]</code>：</p>
<p>  意味着<code>i</code>找小了，所以这时候将<code>iMin</code>加1，于是下一次<code>i</code>切点也会往后挪</p>
</li>
<li><p><code>A[i-1] &gt; B[j]</code>：</p>
<p>  意味着<code>i</code>找大了，这时候将<code>iMax</code>减1，于是下一次<code>i</code>切点也会往前挪</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<pre><code class="language-java">public double findMedianSortedArrays(int[] A, int[] B) {
    int m = A.length;
    int n = B.length;
    // to ensure m&lt;=n
    if (m &gt; n) {
        return findMedianSortedArrays(B, A);
    }
    int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;
    while (iMin &lt;= iMax) {
        int i = (iMin + iMax) / 2;
        int j = halfLen - i;
        if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i]){
            // i is too small
            iMin = i + 1;
        } else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) {
            // i is too big
            iMax = i - 1;
        } else {
            // i is perfect
            int maxLeft;
            if (i == 0) { maxLeft = B[j-1]; }
            else if (j == 0) { maxLeft = A[i-1]; }
            else { maxLeft = Math.max(A[i-1], B[j-1]); }
            if ( (m + n) % 2 == 1 ) { return maxLeft; }

            int minRight;
            if (i == m) { minRight = B[j]; }
            else if (j == n) { minRight = A[i]; }
            else { minRight = Math.min(B[j], A[i]); }

            return (maxLeft + minRight) / 2.0;
        }
    }
    return 0.0;
}

// show cut when perfect i was found
// eg: A[1, 8, 20, 55, 77] B[2, 4, 5, 9, 23, 27, 85, 152, 964]
//
// cut:3 --&gt; [1, 8, 20] | [55, 77]
// cut:4 --&gt; [2, 4, 5, 9] | [23, 27, 85, 152, 964]
public void showCut(int[] arr, int cutIndex) {
    int[] leftPart = new int[cutIndex];
    int[] rightPart = new int[arr.length - cutIndex];
    System.arraycopy(arr, 0, leftPart, 0, cutIndex);
    System.arraycopy(arr, cutIndex, rightPart, 0, arr.length - cutIndex);
    System.out.println(&quot;cut:&quot; + cutIndex + &quot; --&gt; &quot; + Arrays.toString(leftPart) + &quot; | &quot; + Arrays.toString(rightPart));
}</code></pre>

          <h3>
            <a name="_root-5. Longest Palindromic Substring" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            5. Longest Palindromic Substring
          </h3><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;cbbd&quot;
Output: &quot;bb&quot;</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: &quot;ab&quot;
Output: &quot;a&quot;</code></pre><p><strong>Example 4:</strong></p>
<pre><code>Input: &quot;&quot;
Output: &quot;&quot;</code></pre>
          <h4>
            <a name="_root-60+ms Solution (Beat 33%)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            60+ms Solution (Beat 33%)
          </h4><p>因为String <strong>s</strong>是一个char数组，我们以遍历这个数组为基础，当我们在位置<code>i</code>碰到一个char的时候，就找它下一次出现的位置<code>j</code>，那么我们就可以继续数组子序列<code>[i, j]</code>是否是回文串，由此找到一个可能的解；然后再以<code>j+1</code>开始，再找下一个<code>j</code>，于是代码可以是：</p>
<pre><code class="language-java">public boolean isPalindrome(char[] src, int begin, int end) {
    while(begin &lt; end) {
        if(src[begin++] != src[end--]) {
            return false;
        }
    }
    return true;
}

public String longestPalindrome(String s) {
    char[] chars = s.toCharArray();
    if (chars.length == 1) {
        return s;
    }
    int start = 0, end = 0;
    for (int i = 0; i &lt; chars.length; i++) {
        if (chars.length - i &lt; end - start + 1) {
            break;
        }
        char nowC = chars[i];
        int next = i;
        do {
            next = s.indexOf(nowC, next + 1);
            if (next - i + 1 &lt; end - start + 1) {
                continue;
            }
            if (next &gt; 0) {
                if (next - i + 2 &gt; end - start + 1 &amp;&amp;
                    isPalindrome(chars, i + 1, next - 1)) {

                    start = i;
                    end = next + 1;
                }
            }
        } while (next &gt; 0);
    }
    if (end == 0 &amp;&amp; chars.length != 0) {
        return chars[0] + &quot;&quot;;
    }
    return s.substring(start, end);
}</code></pre>
<p>解法的关键是do循环里面的<code>next = s.indexOf(nowC, next + 1)</code>，但也正是在这一步里，花费了大量的时间做了重复的工作，因为这里也是在遍历数组- -</p>

          <h4>
            <a name="_root-7-10ms Solution (Beat 98%)" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            7-10ms Solution (Beat 98%)
          </h4><p>我们换个思路，关于next的位置，我们不一定要通过遍历数组的方式去寻找下一个可能的end字符的下标，我们可以通过之前已经找到过的回文字符串的长度，来<strong>猜</strong>出下标</p>
<p>我们倒着来看（为什么倒着？后面解释），对于每个<code>i &gt; 0</code>，都有很多种可能说在<code>s[i]</code>就是一组回文数的end，那么这个可能性由什么去缩小？由一个<strong>既定的长度len</strong>来决定，我们倒着来看的话，<code>s[i - len + 1]</code>到<code>s[i]</code>之间的<strong>len</strong>长度子串如果是回文数的话，我们就马上找到了一组可能的解</p>
<p>那么这个<strong>既定的len</strong>怎么求？我们可以发现这个<strong>len</strong>最终就是我们想要的结果字串的长度，所以我们不妨从0开始，在序列<strong>至少有一个字符</strong>的时候，<strong>要找到比原len更长的解的话，我们的len需要再往前吃1位或者2位数字</strong>，如果还是要保持原<strong>len</strong>的话，是求不出解的，比如最开始<code>end = i = 0</code>的时候<code>start = i - len + 1 = 1</code>，这是无解</p>
<p>以<code>&quot;abcba&quot;</code>为例</p>
<p>我们尝试<strong>len</strong>往前吃1位，<code>end = i = 0</code>的时候<code>start = i - (len + 1)+ 1 = i - len = 0</code>，我们得到整个字符串的第一个字符<code>&#39;a&#39;</code>，它肯定是回文数，所以我们得到第一个解，<strong>len++</strong>，此时记录下<code>start</code>和<code>end</code></p>
<p>接下来我们以表格的形式来描述遍历过程，包含了往前吃2位的情况：</p>
<table>
<thead>
<tr>
<th align="center">end = i</th>
<th align="center">start = i - len - 1</th>
<th align="center">start = i - len</th>
<th align="center">string[start, end]</th>
<th align="center">len</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0 = <code>&#39;a&#39;</code></td>
<td align="center">-1 <strong>无解</strong></td>
<td align="center">0</td>
<td align="center">a</td>
<td align="center">++后等于1</td>
</tr>
<tr>
<td align="center">1= <code>&#39;b&#39;</code></td>
<td align="center">-1 <strong>无解</strong></td>
<td align="center">0</td>
<td align="center">ab <strong>不是解</strong></td>
<td align="center">还是1</td>
</tr>
<tr>
<td align="center">2= <code>&#39;c&#39;</code></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">abc/bc <strong>都不是解</strong></td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3= <code>&#39;b&#39;</code></td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">bcb <strong>是解</strong></td>
<td align="center">吃两位得的解，所以len+=2 = 3</td>
</tr>
<tr>
<td align="center">4= <code>&#39;a&#39;</code></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">abcba <strong>是解</strong></td>
<td align="center">len+=2 = 5</td>
</tr>
</tbody></table>
<p>于是循环中的逻辑为：</p>
<pre><code class="language-java">public String longestPalindrome(String s) {
    char[] ca = s.toCharArray();
    // handle &quot;&quot;
    if (ca.length == 0) {
        return &quot;&quot;;
    }
    int start = 0, end = 0;
    int len = 0;
    for(int i = 0; i &lt; ca.length; i++) {
        // eat 2
        if(isPalindrome(ca, i - len - 1, i)) {
            start = i - len - 1; end = i;
            len += 2;
        } 
        // eat 1
        else if(isPalindrome(ca, i - len, i)) {
            start = i - len; end = i;
            len += 1;
        }
    }
    return s.substring(start, end + 1);
}

private boolean isPalindrome(char[] chars, int head, int tail) {
    if(head &lt; 0) {
        return false;
    }
    while(head &lt; tail) {
        if(chars[head++] != chars[tail--]) {
            return false;
        }
    }
    return true;
}</code></pre>

          <h5>
            <a name="_root-一点优化" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            一点优化
          </h5><p>观察表中最后一行以及<code>isPalindrome</code>函数可以发现，判断<code>abcba</code>是否为回文串的时候，重复判断了<code>bcb</code>，而它已经在上一次被判断过了，于是我们可以将start和end提出去，让它们在下一次判断回文数的时候也能够使用，避免重复判断</p>
<p>在回文数判断函数中补上：</p>
<pre><code class="language-java">private int start, end;
private boolean isPalindrome(char[] chars, int head, int tail) {
    if(head &lt; 0) {
        return false;
    }
    if (chars[head] == chars[tail] &amp;&amp; start == head + 1 &amp;&amp; end == tail - 1) {
        return true;
    }
    while(head &lt; tail) {
        if(chars[head++] != chars[tail--]) {
            return false;
        }
    }
    return true;
}</code></pre>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

    <script>
        importJsAfterLoad()
    </script>
</body>

</html>