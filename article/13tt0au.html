<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
    <script>
        if (location.hostname === 'youyinnn.github.io' && returnCitySN.cname === 'CHINA') {
            location.href = 'https://youyinnn.gitee.io' + location.pathname
        }
    </script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@master/img/favicon.ico" />
    <link rel="stylesheet" href="/mycss/style.css">


    <script src="/resources/resources.js"></script>
    <script src="/myjs/import.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg em-svg em-rocket"></button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <span id="slogan">
            <i id="wolf-logo" class="em-svg em-new_moon mr-4"></i>I'M BACK
        </span>
        <div id="showmore"> &gt; About Me & This Blog</div>
        <div id="showhacknical"> &gt; My Github Analysis</div>
        <div id="toarticles"> &gt; My Tech Articles</div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="series" class="unselectable">
        <span>系</span>
        <span>列</span>
        <span>文</span>
        <span>章</span>
    </div>
    <div id="seriesbox" class="unselectable">

    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistic</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Site running days:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Total article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Char count:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Category count:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tag count:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search">
            <div class="input-group-append">
                <button id="cleanbut" class="btn" type="button" title="clear search">cls</button>
                <button id="categories" class="btn" type="button">cates</button>
                <button id="tags" class="btn" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn" type="button" title="search">sch</button>
            </div>
        </div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3>
            <a name="_root-Introduction" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Introduction
          </h3><p>本篇主要内容：</p>
<ol>
<li>Java 到底是值传递还是引用传递</li>
<li>Java 中的引用类型详解以其应用场景</li>
</ol>

          <h3>
            <a name="_root-Pass-By-Value Or Pass-By-Reference ?" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Pass-By-Value Or Pass-By-Reference ?
          </h3><p>Java中的所有传递都是值传递，并不存在所谓的引用传递</p>
<p>要理解这个问题的关键在于：</p>
<pre><code class="language-java">Dog myDog;</code></pre>
<p>其中的<code>myDog</code>并不是真正的Dog对象，而是一个<em>pointer</em>，这个指针可以指向一个Dog对象</p>
<p>意思是说：</p>
<pre><code class="language-java">Dog myDog = new Dog(&quot;Rover&quot;);
foo(myDog);</code></pre>
<p>本质上来说，这仅仅只是将这个被创建的Dog对象的地址传递给了<code>foo</code>方法</p>
<p>假如说<code>myDog</code> 这个<em>pointer</em>的地址是<strong>0x19</strong>，而它指向的这个<code>Dog</code>对象的地址是<strong>0x42</strong>，那么我们其实是把<strong>0x42</strong>这个值，传递给了方法，而不是将<strong>0x19</strong>传递给了方法</p>
<p>如果说方法里面的逻辑是这样的：</p>
<pre><code class="language-java">public void foo(Dog someDog) {
    someDog.setName(&quot;Max&quot;);     // 1
    someDog = new Dog(&quot;Fifi&quot;);  // 2
    someDog.setName(&quot;Rowlf&quot;);   // 3
}</code></pre>
<p>我们来分析一下这个方法里发生了什么事：</p>
<ul>
<li>参数<code>someDog</code>指向<strong>0x42</strong></li>
<li>在<code>//1</code><ul>
<li><code>someDog</code> 指向的<strong>0x42</strong>被setName成<strong>Max</strong>了</li>
</ul>
</li>
<li>在<code>//2</code><ul>
<li>一个名称为<strong>Fifi</strong>的新<code>Dog</code>对象（<strong>0x97</strong>）被<code>someDog</code>指向了</li>
</ul>
</li>
<li>在<code>//3</code><ul>
<li><code>someDog</code>指向的<strong>0x97</strong>被setName成<strong>Rowlf</strong>了</li>
</ul>
</li>
<li>方法返回</li>
</ul>
<p>那么接下来是灵魂拷问：<em>方法外面的<code>myDog</code>这时候叫什么名字？</em></p>
<p>这里就是关键！</p>
<p>它叫<strong>Max</strong>，但是！</p>
<p>从始至终请记住，<code>myDog</code>是一个pointer，它从始至终只指向了<strong>0x42</strong>，它还是原来那条一无是处的狗，只不过在<code>//1</code>的时候被人改了名字而已；</p>
<p>至于<code>someDog</code>，它只是一个容易变心的指针而已，所以方法内外的<code>myDog</code>和<code>someDog</code>，它们是两个世界的指针，谁也不会真正影响到谁变心；</p>

          <h3>
            <a name="_root-Reference Type" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Reference Type
          </h3><p>之前在JVM学习的时候学过几种引用的含义，这里再引用一些<a href="https://blog.csdn.net/xlinsist/article/details/57089288">参考</a>，深入了解一下</p>
<blockquote>
<p>作者：Xurtle<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/xlinsist/article/details/57089288">https://blog.csdn.net/xlinsist/article/details/57089288</a> </p>
</blockquote>

          <h4>
            <a name="_root-Strong reference" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Strong reference
          </h4><p>显式写出来的引用就是它，除非显式引用断开了否则就回收它，而这背后JVM正是直接通过可达性判断来回收的，每个强引用的对象都能通过可达性判断；</p>
<pre><code class="language-java">String a = new String(&quot;xixi&quot;);    // ’xixi‘ is at 0x42
// some work
a = null;    // ‘xixi’ which means 0x42 is now available for GC</code></pre>

          <h4>
            <a name="_root-Soft reference" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Soft reference
          </h4><p>它引用的对象只有在内存不足时<strong>且没有强引用同时引用这个对象的时候</strong>，才会被回收，也即是在下次OOM之前，JVM一定会清理掉所有的<strong>soft reference</strong></p>
<p>虽然GCor们已经很努力地在工作了，但是我们作为Java开发，也不能为所欲为，不当的代码会造成冗余的对象，变成GCor们无法清理的垃圾，甚至造成内存泄漏问题</p>
<p>我们来看一段代码：</p>
<pre><code class="language-java">public class LeakyChecksum {
    private byte[] byteArray;

    public synchronized int getFileChecksum(String fileName) {
        int len = getFileSize(fileName);
        if (byteArray == null || byteArray.length &lt; len)
            byteArray = new byte[len];
        readFileContents(fileName, byteArray);
        // calculate checksum and return it
    }
}</code></pre>
<p>在没有对<code>byteArray</code>进行手动数据清理的时候，<code>byteArray</code>会不断重用数组，除非<code>LeakyChecksum</code>对象被GC，否则它不会被GC，它的大小会始终和它处理过的最大的文件一样大，这样会增加GC的频率；</p>
<p>而且因为方法后续没有手动清理，所以这个字节数组就一直存在内存中的垃圾，造成内存泄漏</p>
<p>于是我们可以使用软引用去描述这个字节数组，一旦内存紧张的时候，它就会被回收掉，从而释放多余的空间</p>
<pre><code class="language-java">public class CachingChecksum {
    private SoftReference&lt;byte[]&gt; bufferRef;

    public synchronized int getFileChecksum(String fileName) {
        int len = getFileSize(fileName);
        byte[] byteArray = bufferRef.get();
        if (byteArray == null || byteArray.length &lt; len) {
            byteArray = new byte[len];
            bufferRef.set(byteArray);
        }
        readFileContents(fileName, byteArray);
        // calculate checksum and return it
    }
}</code></pre>
<p>可以看到，我们每次都尝试获取软引用对象，如果它为null，证明它是第一次访问或者被GC清理掉了</p>

          <h4>
            <a name="_root-Weak reference" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Weak reference
          </h4><p>被声明为弱引用的对象，<strong>如果没有强引用同时引用这个对象</strong>，那么它只能存活到下一次GC之前</p>
<pre><code class="language-java">WeakReference&lt;String&gt; sr = new WeakReference&lt;String&gt;(new String(&quot;hello&quot;));

System.out.println(sr.get()); // hello
System.gc();                  // 通知JVM的gc进行垃圾回收
System.out.println(sr.get()); // might be null</code></pre>

          <h4>
            <a name="_root-Phantom reference" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Phantom reference
          </h4><p><strong>Phantom References</strong>与上面的几个引用存在很大的不同，至少上面的<code>Reference</code> 对象通过它们的<code>get()</code> 方法可以获取到它们所引用的对象，但是，<code>PhantomReference</code> 的只会返回<code>null</code>，因为虚引用的意义不在于get到引用，而在于<strong>它能提醒我们哪些对象不应该继续存在了</strong></p>
<p><a href="https://blog.csdn.net/xlinsist/article/details/57089288">这篇里</a>说：<em>“Phantom reference 的唯一作用就是它可以监测到对象的死亡，即，当你的对象真正从内存中移除时，指向这个对象的<code>PhantomReference</code> 就会被加入到队列中”</em></p>
<p>这句话其实后半句有误，应该是<em>“这个被回收对象生前所引用的虚引用对象会被加入到*</em>引用队列*<em>中”</em>才对</p>
<p>关于<strong>引用队列</strong>，具体是什么，我们下节再细说，先来整理一下虚引用到底有什么神通</p>
<p>它首先会表现出来的行为是：当且仅当虚引用对象的<strong>参照对象（referent）</strong>被GC回收掉的时候，那么这个虚引对象用会被加入到<code>ReferenceQueue</code>中，<strong>这时候虚引用对象还没被回收</strong></p>
<pre><code class="language-java">public class PhantomReferenceDemo {
    private static ReferenceQueue&lt;Person&gt; rq = new ReferenceQueue&lt;&gt;();
    static Person p;
    static Dog d;
    public static void main(String[] args){
        p = new Person(&quot;xixi&quot;);
        d = new Dog(p, rq, &quot;haha&quot;);
        printRQ();
        p = null;
        System.gc();
        waitMoment(2000);    // wait gc
        printRQ();
    }

    static class Person {
        String name;Dog dog;
        public Person(String name) {this.name = name;}
        public void setDog(Dog dog) {this.dog = dog;}
    }

    static class Dog extends PhantomReference&lt;Person&gt; {
        String name;
        // Person person;
        public Dog(Person referent, ReferenceQueue&lt;? super Person&gt; q, String name) {
            super(referent, q);
            // this.person = referent;
            this.name = name;
        }
    }

    private static void waitMoment(long time) {
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void printRQ() {
        int size = 0;
        Object obj;
        while ( ( obj = rq.poll() ) != null ) {
            System.out.println(&quot;reference: &quot; + obj);
            size++;
        }
        System.out.println(&quot;size of rq： &quot; + size);
    }
}

// size of rq： 0
// reference: _reference.PhantomReferenceDemo$Dog@45ee12a7
// size of rq： 1</code></pre>
<p>虚引用的正确实现方式就是如<code>Dog</code>对象一样，继承<code>PhantomReference&lt;Person&gt;</code>，因为狗是跟随人的，如果人没有了，那么狗就没有存在的必要了（请不要带有感情地去读这句话，客观的看代码- -）所以说，狗对象的<strong>参照对象（referent）</strong>是人！</p>
<p>所以在<code>line:9</code>之后，当人对象变为<strong>不可达状态</strong>的时候，被GC处理掉了之后，因为两者之间的虚引用关系，狗对象被加入到了指定的引用队列中，表面需要对这个没有存在必要的狗对象也进行处理，我们可以重写虚引用对象的<code>clear()</code>方法，在方法里面去掉狗的强引用，去然后在处理引用队列的时候，调用虚引用对象的<code>clear()</code>方法</p>
<pre><code class="language-java">// Dog
@Override
public void clear() {
    super.clear();
    System.out.println(&quot;clear dog&quot;);
    d = null;
}
// printRQ
private static void printRQ() {
    // ...
    while ( ( obj = rq.poll() ) != null ) {
        // ...
        ((Reference) obj).clear();
    }
    // ...
}</code></pre>
<p>那么上一句说到的不可达状态如何验证？狗对象的Person字段相关被注释掉了，如果解开注释之后，即使全局q对象已经设置为null，但是人对象还有狗对象去引用，人对象还是处于可达状态的，所以第二次<code>printRQ</code>方法依旧是没有任何对象入队</p>

          <h3>
            <a name="_root-Reference Abstract Class &amp; ReferenceQueue" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Reference Abstract Class &amp; ReferenceQueue
          </h3><p>上面提到的4种引用类型中的后3种，在Java中其实都是<code>Reference</code>的子类实现，并且<code>Reference</code>和<code>ReferenceQueue</code>的关系很密切</p>
<p>其实我感觉虚引用的作用可以人为替代，比如上文的人和狗的关系，只要狗没有强引用，那么人没了狗也就没了</p>
<p>所以更多的时候，虚引用是用来监听虚引用的参照对象是否被GC掉了</p>
<p>上节已经说过虚引用和引用队列的关系了，它必须指定一个引用队列，软引用和弱引用可以选择性地和引用队列合作</p>
<p>以下参考自<a href="https://juejin.im/entry/5b28f605f265da59942344d4">java 源码系列 - 带你读懂 Reference 和 ReferenceQueue</a></p>

          <h4>
            <a name="_root-Reference" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Reference
          </h4><p>主要是负责内存的一个状态，当然它还和java虚拟机，垃圾回收器打交道。Reference类首先把内存分为4种状态Active，Pending，Enqueued，Inactive。</p>
<ul>
<li>Active，一般来说内存一开始被分配的状态都是 Active，</li>
<li>Pending 大概是指快要被放进队列的对象，也就是马上要回收的对象，</li>
<li>Enqueued 就是对象的内存已经被回收了，我们已经把这个对象放入到一个队列中，方便以后我们查询某个对象是否被回收，</li>
<li>Inactive就是最终的状态，不能再变为其它状态。</li>
</ul>

          <h4>
            <a name="_root-ReferenceQueue" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            ReferenceQueue
          </h4><p>引用队列，在检测到适当的<strong>可到达性更改</strong>后，垃圾回收器将已注册的引用对象添加到队列中，ReferenceQueue实现了入队（enqueue）和出队（poll），还有remove操作，内部元素head就是泛型的Reference。</p>

          <h4>
            <a name="_root-Sample" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Sample
          </h4><pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    ReferenceQueue queue = new ReferenceQueue();

    // 创建弱引用，此时状态为Active，并且Reference.pending为空
    // 当前Reference.queue = 上面创建的queue，并且next=null
    WeakReference reference = new WeakReference(new Object(), queue);
    System.out.println(reference);
    // 当GC执行后，由于是虚引用，所以回收该object对象
    //并且置于pending上，此时reference的状态为PENDING
    System.gc();

    /* ReferenceHandler从pending中取下该元素，并且将该元素放入到queue中，
    此时Reference状态为ENQUEUED，Reference.queue = ReferenceENQUEUED */

    /* 当从queue里面取出该元素，则变为INACTIVE，Reference.queue = Reference.NULL */
    Reference reference1 = queue.remove();
    System.out.println(reference1);
}</code></pre>
<p>我们很容易就想到，<code>reference</code>和<code>reference1</code>是同一个对象，而且这段代码也揭示了一个事实：<strong>匿名对象都是虚引用</strong></p>

          <h3>
            <a name="_root-Conclusion" class="reference-link" target="_blank">
              <span class="header-link"></span>
            </a>
            Conclusion
          </h3><p>有效地利用3种引用类型，可以帮助我们提高GC效率，防止OOM</p>
<p>在Java中也有许多应用实例，比如有<code>WeakHashMap</code>等等，他在<code>ThreadLocal</code>里就运用到了，以后有空再研究</p>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>