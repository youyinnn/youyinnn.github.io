<h3 id="前言">前言</h3>
<p>我</p>
<p>面试（大约两个月前）</p>
<p>被问线程安全单例</p>
<p>实际上写得出</p>
<p>只是不知道可以这样写</p>
<p>所以没答好- -</p>
<p>回来一看</p>
<p>可以答</p>
<p>耻辱</p>
<p>说明：本篇代码大部分引自：<a href="https://github.com/iluwatar/java-design-patterns">https://github.com/iluwatar/java-design-patterns</a></p>
<hr>
<h3 id="singleton">Singleton</h3>
<p>单例模式（Singleton）算是工厂模式的一种特例，你不需要给出任何参数，就可以马上得到一个在任何地方都可以调用到的唯一的实例</p>
<p>第一次接触到单例，还是在 1 年多前学习 spring 的时候，在配置 Bean 的时候有单例多例配置</p>
<p>总的来说，一个实例，如果是用作工具类或者工具对象的话，那么它并不需要创建多个实例，我们就可以用单例的形式去获取这个对象</p>
<h4 id="hungrymanstyle（thread-safe）">HungryManStyle（thread safe）</h4>
<pre><code class="hljs language-java"><span class="hljs-comment">/**
 * 使用静态对象进行预加载来保证线程安全的
 * 一般我们称这样的单例为饿汉式单例 不管三七二十一 一旦加载这个类就创建对象
 * 一般是在第一次引用这个类的时候就加载这个类
 */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>{}
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> INSTANCE;
    }
}
</code></pre>
<p>要说的话都在注释里了</p>
<h4 id="lazymanstyle">LazyManStyle</h4>
<h5 id="无锁（非线程安全）">无锁（非线程安全）</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>{}
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) {
            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();
        }
        <span class="hljs-keyword">return</span> INSTANCE;
    }
}
</code></pre>
<p>这种是最基本的单例</p>
<ul>
<li>私有无参构造方法保证外部引用不可以 new 一个对象</li>
<li>判断是否初始化了 instance 变量 始终只返会同一个对象</li>
</ul>
<p>但是这种单例只能在单线程的情况下正常工作，在多线程的情况下，如果多个线程同一时刻在 line5 处判断实例变量不为空，那么就可能有多个线程同时执行 line6，在这个时间，会有大量的实例挤破头得被 instance 引用，这样会造成资源浪费</p>
<h5 id="简单-synchronized-上锁（线程安全）">简单 Synchronized 上锁（线程安全）</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>{}
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singletion INSTANCE;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) {
            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();
        }
        <span class="hljs-keyword">return</span> INSTANCE;
    }
}

<span class="hljs-comment">// 另外一种写法</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>{
    <span class="hljs-keyword">synchronized</span>(Singleton.class) {
        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) {
            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();
        }
    }
    <span class="hljs-keyword">return</span> INSTANCE;
}
</code></pre>
<p>优点，比上面那种安全，缺点，获取对象的时候资源浪费，我们上锁的目的只是<strong>防止最开始在实例未被初始化的时候，被多线程访问导致 line5 判断异常</strong>，往后在实例被创建好了之后，并不需要防止多线程同时访问，每次调用方法都加锁只会增加无意义的消耗，我称这个为<strong>“无意义锁”</strong></p>
<p>这种实现不可取</p>
<h5 id="想当然的双重检查锁（非线程安全）">想当然的双重检查锁（非线程安全）</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>{
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>{}
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singletion INSTANCE;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>{
        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">synchronized</span>(Singleton.class) {
                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) {
                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();
                }
            }
        }
        <span class="hljs-keyword">return</span> INSTANCE;
    }
}
</code></pre>
<p>这个实现，看似可以避免<strong>无意义锁</strong>的问题，但是 line8 可能会因为某单线程的重排序导致其他线程对该实例的可见性问题，对于双重检查锁的错误，在系列文章《并发编程第六坎》中可以看到，这里不再赘述</p>
<p>基于双重检查锁的解决方案，给出两种比较标准的实现：</p>
<h5 id="基于内部类和类加载机制的initialization-on-demand-holder-idiom">基于内部类和类加载机制的——Initialization On Demand Holder Idiom</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InitializingOnDemandHolderIdiom</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InitializingOnDemandHolderIdiom</span><span class="hljs-params">()</span>{}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InitializingOnDemandHolderIdiom <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> HelperHolder.INSTANCE;
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelperHolder</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">InitializingOnDemandHolderIdiom</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span>
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitializingOnDemandHolderIdiom</span>();
    }
}
</code></pre>
<p>这个实现的好处就是，它可以在既可以保证线程安全和懒加载，又可以适应所有的 JDK 版本，比如我们下面的实现用到了 volatile 变量，就需要 JDK1.5 以上的支持</p>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom">https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom</a></li>
<li><a href="http://ifeve.com/initialization-on-demand-holder-idiom/">http://ifeve.com/initialization-on-demand-holder-idiom/</a></li>
<li><a href="https://www.cnblogs.com/fuyoucaoyu/p/6547715.html">https://www.cnblogs.com/fuyoucaoyu/p/6547715.html</a></li>
</ul>
</blockquote>
<p>在这里我们多接触了一个概念——<strong>初始化锁 LC 锁</strong>，具体的介绍可以看第六坎</p>
<h5 id="基于-volatile-变量的线程安全的双重检查锁">基于 volatile 变量的——线程安全的双重检查锁</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeDoubleCheckLocking</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> ThreadSafeDoubleCheckLocking instance;
  <span class="hljs-keyword">private</span> <span class="hljs-title function_">ThreadSafeDoubleCheckLocking</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 防止被反射实例化</span>
    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Already initialized.&quot;</span>);
    }
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadSafeDoubleCheckLocking <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> {
    <span class="hljs-comment">// 这个本地变量会提高25%的性能 Joshua Bloch &quot;Effective Java, Second Edition&quot;, p. 283-284</span>
    <span class="hljs-type">ThreadSafeDoubleCheckLocking</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> instance;
    <span class="hljs-comment">// 第一次检查 不为空直接返回</span>
    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) {
      <span class="hljs-comment">// 上锁同步初始化的过程</span>
      <span class="hljs-keyword">synchronized</span> (ThreadSafeDoubleCheckLocking.class) {
        <span class="hljs-comment">// 再一次指派本地变量 用于检查是否有其他线程在当前线程被阻塞在锁外的时候已经完成初始化工作了</span>
        <span class="hljs-comment">// 如果已经完成了 那么可以直接返回结果</span>
        result = instance;
        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) {
          <span class="hljs-comment">// 在这个区域完全就是单线程访问了 完成初始化工作</span>
          instance = result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadSafeDoubleCheckLocking</span>();
        }
      }
    }
    <span class="hljs-keyword">return</span> result;
  }
}
</code></pre>
<p>关键是 volatile 的声明，原因见第六坎</p>
<h5 id="枚举法单例">枚举法单例</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumSingleton</span> {
  INSTANCE;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> getDeclaringClass().getCanonicalName() + <span class="hljs-string">&quot;@&quot;</span> + hashCode();
  }
}
</code></pre>
<p>也是利用枚举的特点，线程安全，简单、直接、省事、可用</p>
<p>单例的枚举实现在《Effective Java》中有提到，因为其<strong>功能完整、使用简洁、无偿地提供了序列化机制、在面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化</strong>等优点，单元素的枚举类型被作者认为是实现 Singleton 的最佳方法。</p>
<p>具体可以参考：<a href="https://blog.csdn.net/gavin_dyson/article/details/70832185">https://blog.csdn.net/gavin_dyson/article/details/70832185</a></p>
<p>里面说了，为什么枚举类会有一次性锁的效果，其实枚举是一种语法糖，本质是上利用的还是静态特性，然后因为<strong>语法糖揪在一起（自创说法）</strong>的原因，序列化绝对安全</p>
<h4 id="总结">总结</h4>
<p>这么多单例，最好的实现无疑是最后三种，最后三种各自有各自的优点</p>
<ul>
<li><strong>静态内部类实现：</strong>所有版本通用，常规且有效</li>
<li><strong>volatile 双重检查锁实现：</strong>只适用 JDK1.5 以上，正式切有效</li>
<li><strong>枚举法实现：</strong>蜜汁实现，简单暴力省事高效，但是不易理解其特性</li>
</ul>
<p>多提一句，饿汉式写法没有绝对的漏洞，只是如果你的实例内容如果多，占用空间大，而且没有一开始就需要伴随系统初始化的必要的话，有点浪费资源，其他也没差。</p>
<hr>
<h3 id="observerdependentspublisher-subscriber">Observer/Dependents/Publisher-Subscriber</h3>
<p>观察者模式意在建立一种一对多的关联关系，在这个关系中，任意其中一个对象发生了状态变化，其他对象都可以自动感知到这个变化。</p>
<p>观察者模式又称为：关联模式、发布者-订阅者模式</p>
<p>这样的关系很容易理解，就像电视台播报的天气预报一样，天气一变，气象台就会发送变动天气的短信给当地用户，武汉就一天至少 2 封高温预警的短信- -</p>
<p>我们首先来看</p>
<h4 id="subjectpublisher">Subject/Publisher</h4>
<pre><code class="hljs language-java"><span class="hljs-comment">/**
 * Weather对象可以被实现了观察者接口WeatherObserver并且在Weather对象这里注册为观察者的对象才能接受
 * 该Weather对象的发布内容
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Weather</span> {
  <span class="hljs-keyword">private</span> WeatherType currentWeather;
  <span class="hljs-keyword">private</span> List&lt;WeatherObserver&gt; observers;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Weather</span><span class="hljs-params">()</span> {
    observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    currentWeather = WeatherType.SUNNY;
  }
  <span class="hljs-comment">// 注册订阅者</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(WeatherObserver obs)</span> {
    observers.add(obs);
  }
  <span class="hljs-comment">// 注销订阅者</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(WeatherObserver obs)</span> {
    observers.remove(obs);
  }
  <span class="hljs-comment">// 状态变更</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">timePasses</span><span class="hljs-params">()</span> {
    WeatherType[] enumValues = WeatherType.values();
    currentWeather = enumValues[(currentWeather.ordinal() + <span class="hljs-number">1</span>) % enumValues.length];
    notifyObservers();		<span class="hljs-comment">// 通知</span>
  }
  <span class="hljs-comment">// 发布订阅到所有订阅者</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">for</span> (WeatherObserver obs : observers) {
      obs.update(currentWeather);
    }
  }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">WeatherType</span> {
  SUNNY, RAINY, WINDY, COLD;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name().toLowerCase();
  }
}
</code></pre>
<h4 id="观察者接口">观察者接口</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WeatherObserver</span> {
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(WeatherType currentWeather)</span>;
}
</code></pre>
<h4 id="observersubscriber">Observer/Subscriber</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orcs</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WeatherObserver</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(WeatherType currentWeather)</span> {
    <span class="hljs-keyword">switch</span> (currentWeather) {
      <span class="hljs-comment">// 根据状态选择对应逻辑</span>
    }
  }
}
</code></pre>
<h4 id="main">Main</h4>
<pre><code class="hljs language-java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">Weather</span> <span class="hljs-variable">weather</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weather</span>();
    weather.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Orcs</span>());
    weather.timePasses();
    weather.timePasses();
    weather.timePasses();
    weather.timePasses();
  }
</code></pre>
<h4 id="通用模板">通用模板</h4>
<h5 id="abstractsubject">AbstractSubject</h5>
<pre><code class="hljs language-java"><span class="hljs-comment">/**
 * 基于泛型和集合框架的通用Subject模板
 * <span class="hljs-doctag">@param</span> &lt;S&gt; Subject
 * <span class="hljs-doctag">@param</span> &lt;O&gt; Observer
 * <span class="hljs-doctag">@param</span> &lt;A&gt; Argument type
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observable</span>&lt;
    S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observable</span>&lt;S, O, A&gt;,
    O <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observer</span>&lt;S, O, A&gt;,
    A&gt; {

  <span class="hljs-keyword">protected</span> List&lt;O&gt; observers;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Observable</span><span class="hljs-params">()</span> {
      <span class="hljs-built_in">this</span>.observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();	<span class="hljs-comment">// 线程安全的实现</span>
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addObserver</span><span class="hljs-params">(O observer)</span> {
      <span class="hljs-built_in">this</span>.observers.add(observer);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(O observer)</span> {
      <span class="hljs-built_in">this</span>.observers.remove(observer);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">(A argument)</span> {
    <span class="hljs-keyword">for</span> (O observer : observers) {
      observer.update((S) <span class="hljs-built_in">this</span>, argument);
    }
  }
}
</code></pre>
<h5 id="observer-interface">Observer-Interface</h5>
<p>观察者接口的最顶层抽象接口</p>
<pre><code class="hljs language-java"><span class="hljs-comment">/**
 * Observer
 * <span class="hljs-doctag">@param</span> &lt;S&gt; Observable
 * <span class="hljs-doctag">@param</span> &lt;O&gt; Observer
 * <span class="hljs-doctag">@param</span> &lt;A&gt; Action
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span>&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observable</span>&lt;S, O, A&gt;,
                          O <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observer</span>&lt;S, O, A&gt;,
                          A&gt; {

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(S subject, A argument)</span>;
}
</code></pre>
<h5 id="observer-generics-map">Observer-Generics-Map</h5>
<p>规定好泛型的观察者接口</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Race</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observer</span>&lt;GWeather, Race, WeatherType&gt; {
}
</code></pre>
<h5 id="subject-implement">Subject-Implement</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GWeather</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observable</span>&lt;GWeather, Race, WeatherType&gt; {
  <span class="hljs-keyword">private</span> WeatherType currentWeather;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">GWeather</span><span class="hljs-params">()</span> {
    currentWeather = WeatherType.SUNNY;
  }
  <span class="hljs-comment">// 状态变更</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">timePasses</span><span class="hljs-params">()</span> {
    WeatherType[] enumValues = WeatherType.values();
    currentWeather = enumValues[(currentWeather.ordinal() + <span class="hljs-number">1</span>) % enumValues.length];
    LOGGER.info(<span class="hljs-string">&quot;The weather changed to {}.&quot;</span>, currentWeather);
    notifyObservers(currentWeather);  <span class="hljs-comment">//通知</span>
  }
}
</code></pre>
<h5 id="observer-implement">Observer-implement</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GOrcs</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Race</span> {

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(GWeather weather, WeatherType weatherType)</span> {
    <span class="hljs-keyword">switch</span> (weatherType) {
      <span class="hljs-comment">// ...</span>
    }
  }
}
</code></pre>
<h5 id="main-1">Main</h5>
<pre><code class="hljs language-java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">GWeather</span> <span class="hljs-variable">gWeather</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GWeather</span>();
    gWeather.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GOrcs</span>());
    gWeather.addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GHobbits</span>());

    gWeather.timePasses();
    gWeather.timePasses();
    gWeather.timePasses();
    gWeather.timePasses();
  }
</code></pre>
<h4 id="总结-1">总结</h4>
<p>总的来说就是：<strong>观察者把自己的引用注册到发布者给的接口中，发布者每次状态变更就通知所有注册了的引用。</strong></p>
<hr>
<h3 id="decoratorwrapper">Decorator/Wrapper</h3>
<p>装饰器（也称包装器）的意图是<strong>动态（运行时）、弹性的（可选）、无侵入的（不改源码）</strong>地给某个类添加功能或者增强功能。</p>
<p>参考项目的作者<code>iluwatter</code>有这样一段比喻：</p>
<blockquote>
<p>附近的山里有一只巨魔（Troll），他平时都空着手，偶尔也会拿着武器；</p>
<p>如果你要让同一只巨魔拿着武器的话，你不需要 new 一只一模一样的巨魔，你只需要包装这只巨魔就好了[doge]</p>
</blockquote>
<h4 id="object-interface-and-simple-implement">Object-Interface and Simple Implement</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Troll</span> {
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span>;
  <span class="hljs-type">int</span> <span class="hljs-title function_">getAttackPower</span><span class="hljs-params">()</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleTroll</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Troll</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> {
    System.out.println(<span class="hljs-string">&quot;hp - &quot;</span> + <span class="hljs-built_in">this</span>.getAttackPower());
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAttackPower</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
  }
}
</code></pre>
<p>现在我们有一只攻击力+10 的巨魔，接下来我们给它把无尽</p>
<h4 id="decorator">Decorator</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClubbedTroll</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Troll</span> {
  <span class="hljs-keyword">private</span> Troll decorated;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClubbedTroll</span><span class="hljs-params">(Troll decorated)</span> {
    <span class="hljs-built_in">this</span>.decorated = decorated;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> {
    System.out.println(<span class="hljs-string">&quot;hp - &quot;</span> + <span class="hljs-built_in">this</span>.getAttackPower());
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAttackPower</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> decorated.getAttackPower() + <span class="hljs-number">100</span>;
  }
}
</code></pre>
<h4 id="main-2">Main</h4>
<pre><code class="hljs language-java"><span class="hljs-comment">// 空手巨魔</span>
<span class="hljs-type">Troll</span> <span class="hljs-variable">troll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleTroll</span>();
troll.attack(); <span class="hljs-comment">// 平A无暴击</span>

<span class="hljs-comment">// 出无尽的巨魔</span>
troll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClubbedTroll</span>(troll);
troll.attack(); <span class="hljs-comment">// 暴击！</span>
</code></pre>
<h4 id="总结-2">总结</h4>
<p>感觉和 AOP 差不多，只不过实现思路和需求不一样</p>
<hr>
<h3 id="adapterwrapper">Adapter/Wrapper</h3>
<p>适配器模式，也是包装模式的一种，它和装饰器模式有一方面像的一点就是，它们都是包装要使用的类，只不过装饰器是针对同一种类去包装，企图强化这个类；而适配器是要包装两个类为一个统一的类，在适配器里兼容一个类的输出，让它的输出为另一个类可用的输入，适配器输出这另一个类的输出，企图让这两个类联合工作。</p>
<p>参考项目的作者<code>iluwatter</code>有这样一段比喻：</p>
<blockquote>
<p>假设你想将你内存卡上的一些图片传到你电脑上去，你需要一种适配器，这个适配器可以适用于你电脑的端口，这样你才能将你的内存卡装载到你的电脑上去，在这个例子里面，读卡器就是一个适配器。</p>
</blockquote>
<p>专业的解释就是：</p>
<blockquote>
<p>适配器是要包装两个类为一个统一的类，在适配器里兼容一个类的输出，让它的输出为另一个类可用的输入，适配器输出这另一个类的输出，企图让这两个类联合工作。（这话是我说的~）</p>
</blockquote>
<h4 id="two-interfaces">Two Interfaces</h4>
<p>首先我们来看适配器要适配的两个对象类，场景如下：<code>假设船长只会划船，并不会航海，但是旁边有一艘渔船可以出海</code>，于是我们先有两个接口，划船只能划水，渔船可以航海：</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RowingBoat</span> {
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">row</span><span class="hljs-params">()</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FishingBoat</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sail</span><span class="hljs-params">()</span> {
    System.out.println(<span class="hljs-string">&quot;The fishing boat is sailing&quot;</span>);
  }
}
</code></pre>
<h4 id="user">User</h4>
<p>再来看看我们的船长：</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Captain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RowingBoat</span> {

  <span class="hljs-keyword">private</span> RowingBoat rowingBoat;

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Captain</span><span class="hljs-params">(RowingBoat rowingBoat)</span> {
    <span class="hljs-built_in">this</span>.rowingBoat = rowingBoat;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">row</span><span class="hljs-params">()</span> {
    rowingBoat.row();
  }
}
</code></pre>
<p>可以看到，这里有一个关键的地方，船长实现 RowingBoat 类的方式是解耦的，是传入一个 RowingBoat 对象，基于这个，我们可以编写一个适配器</p>
<h4 id="adapter">Adapter</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FishingBoatAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RowingBoat</span> {
  <span class="hljs-keyword">private</span> FishingBoat boat;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FishingBoatAdapter</span><span class="hljs-params">()</span> {
    boat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FishingBoat</span>();
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">row</span><span class="hljs-params">()</span> {
    boat.sail();
  }
}
</code></pre>
<p>在这个适配器中我们可以看到，我们将<code>RowingBoat</code>中的<code>row()</code>方法实现为<code>FishingBoat</code>的<code>sail()</code>方法</p>
<h4 id="main-3">Main</h4>
<pre><code class="hljs language-java"><span class="hljs-type">Captain</span> <span class="hljs-variable">captain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Captain</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FishingBoatAdapter</span>());
captain.row();
</code></pre>
<h4 id="总结-3">总结</h4>
<p>总的来说，适配器和装饰器差不多，我们需要注意的点是，我们的使用者需要对原来的对象有良好的解耦支持，这样我们适配后的对象才能更好地被使用者使用。</p>
<hr>
<h3 id="factory">Factory</h3>
<p>工厂模式，在工程化编程中有着举足轻重的地位，将对象的创建、参数分派等行为工程化，是一个项目严谨编写的第一步体现。</p>
<p>项目的作者写分别引了<code>Factory-method</code>和<code>Factory-kit</code>两部分，我们先从 method 开始说起</p>
<h4 id="factory-method">Factory-method</h4>
<p>工厂方法模式，是要定义一个专门用于创建对象的接口，只不过创建对象的方式是让实现子类去决定应该创建具体哪一个对象，工厂方法模式<strong>让一个类将实例化过程延迟到子类上</strong>。</p>
<p>我们来看比喻：</p>
<blockquote>
<p>一个铁匠（BlackSmith）打造（manufacture）武器，精灵（Elves）要求使用小巧的（Elvish）武器，半兽人（Orcs）要求使用重型武器（Orcish）。根据客户要求的不同会召集到打造同一类型武器的铁匠。</p>
</blockquote>
<p>专业的解释：</p>
<blockquote>
<p>将实例化过程的逻辑以委派方式提供给子类</p>
</blockquote>
<h5 id="factory-interface">Factory Interface</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Blacksmith</span> {
  Weapon <span class="hljs-title function_">manufactureWeapon</span><span class="hljs-params">(WeaponType weaponType)</span>;
}
</code></pre>
<p>首先我们有个工厂类，这个类代表能够制造武器的工匠（先不管可以制造什么类型的武器）</p>
<p>然后下面就是武器的抽象接口和武器的类型</p>
<h5 id="product-interface">Product Interface</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Weapon</span> {
  WeaponType <span class="hljs-title function_">getWeaponType</span><span class="hljs-params">()</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">WeaponType</span> {
  SHORT_SWORD(<span class="hljs-string">&quot;short sword&quot;</span>), SPEAR(<span class="hljs-string">&quot;spear&quot;</span>), AXE(<span class="hljs-string">&quot;axe&quot;</span>), UNDEFINED(<span class="hljs-string">&quot;&quot;</span>);
  <span class="hljs-keyword">private</span> String title;
  WeaponType(String title) {
    <span class="hljs-built_in">this</span>.title = title;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> title;
  }
}
</code></pre>
<h5 id="different-instance-class">Different Instance Class</h5>
<p>然后我们有不同的实例类，分别是精灵武器和兽人武器</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElfWeapon</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Weapon</span> {
  <span class="hljs-keyword">private</span> WeaponType weaponType;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ElfWeapon</span><span class="hljs-params">(WeaponType weaponType)</span> {<span class="hljs-built_in">this</span>.weaponType = weaponType;}
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Elven &quot;</span> + weaponType;}
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> WeaponType <span class="hljs-title function_">getWeaponType</span><span class="hljs-params">()</span> {<span class="hljs-keyword">return</span> weaponType;}
}
<span class="hljs-comment">// ============================</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrcWeapon</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Weapon</span> {
  <span class="hljs-keyword">private</span> WeaponType weaponType;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrcWeapon</span><span class="hljs-params">(WeaponType weaponType)</span> {<span class="hljs-built_in">this</span>.weaponType = weaponType;}
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Orcish &quot;</span> + weaponType;}
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> WeaponType <span class="hljs-title function_">getWeaponType</span><span class="hljs-params">()</span> {<span class="hljs-keyword">return</span> weaponType;}
}
</code></pre>
<h5 id="different-factory-class">Different Factory Class</h5>
<p>然后我们有不同的工厂类，分别是精灵武器工匠和兽人武器工具</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ElfBlacksmith</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Blacksmith</span> {
  <span class="hljs-keyword">public</span> Weapon <span class="hljs-title function_">manufactureWeapon</span><span class="hljs-params">(WeaponType weaponType)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ElfWeapon</span>(weaponType);
  }
}
<span class="hljs-comment">// =============================</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrcBlacksmith</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Blacksmith</span> {
  <span class="hljs-keyword">public</span> Weapon <span class="hljs-title function_">manufactureWeapon</span><span class="hljs-params">(WeaponType weaponType)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrcWeapon</span>(weaponType);
  }
}
</code></pre>
<h5 id="main-4">Main</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Blacksmith blacksmith;
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">App</span><span class="hljs-params">(Blacksmith blacksmith)</span> {
    <span class="hljs-built_in">this</span>.blacksmith = blacksmith;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-comment">// Lets go to war with Orc weapons</span>
    <span class="hljs-type">App</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrcBlacksmith</span>());
    app.manufactureWeapons();

    <span class="hljs-comment">// Lets go to war with Elf weapons</span>
    app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ElfBlacksmith</span>());
    app.manufactureWeapons();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">manufactureWeapons</span><span class="hljs-params">()</span> {
    Weapon weapon;
    weapon = blacksmith.manufactureWeapon(WeaponType.SPEAR);
    <span class="hljs-comment">//weapon = blacksmith.manufactureWeapon(WeaponType.AXE);</span>
  }
}
</code></pre>
<p>通过上面的<code>Factory-method</code>的例子，不难发现代码的解耦性还是不高，感觉创造者和工厂本身，这两个概念还是有点摸棱两可的，我们在正确地理顺一下工厂模式到底怎么回事：</p>
<blockquote>
<ol>
<li>首先一个工厂（Factory）只生产同一类产品（Product），这里将工厂映射为<code>BlackSmith interface</code>接口，他可以制造<code>Weapon</code>对象</li>
<li>其次产品有很多种产品，所以我们也把产品抽象成接口<code>Weapon interface</code></li>
<li>那么我们要指派不同的创造者（Producer/Builder），去生产不同的产品，这其实就是不同的工厂接口的实现，这映射到的就是<code>ElfBlacksmith</code>和<code>OrcBlacksmith</code>，分别生产<code>ElfWeapon</code>和<code>OrcWeapon</code></li>
<li>最后在 App 里面，完美地使用了多态的特性：<strong>父类引用指向子类对象</strong></li>
</ol>
</blockquote>
<h4 id="factory-kit">Factory-kit</h4>
<p>为了更加清晰化工厂模式，于是就有了<code>Factory-kit</code>，意图定义一个不变的常量来将工匠和工厂区分开来</p>
<h5 id="product">Product</h5>
<p>我们先看产品有哪些：</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Weapon</span> {
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Axe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Weapon</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Axe&quot;</span>;
  }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bow</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Weapon</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bow&quot;</span>;
  }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sword</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Weapon</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Sword&quot;</span>;
  }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">WeaponType</span> {
  SWORD, AXE, BOW
}
</code></pre>
<h5 id="builder">Builder</h5>
<p>再看看工匠，这里用到了 Java8 的函数式特性，传入一个供给者对象</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Builder</span> {
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(WeaponType name, Supplier&lt;Weapon&gt; supplier)</span>;			<span class="hljs-comment">// 4</span>
}
</code></pre>
<h5 id="factory-1">Factory</h5>
<p>接下来就是重点，看看我们的工厂是如何协调工匠和产品的</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WeaponFactory</span> {
  <span class="hljs-comment">// 制造武器，根据传入的WeaponType选取工厂中存在的工匠制造想对应的武器</span>
  Weapon <span class="hljs-title function_">create</span><span class="hljs-params">(WeaponType name)</span>;								<span class="hljs-comment">// 6</span>

  <span class="hljs-comment">// 聚集工匠，factory负责维护一个map，一种武器类型对应一类工匠</span>
  <span class="hljs-keyword">static</span> WeaponFactory <span class="hljs-title function_">factory</span><span class="hljs-params">(Consumer&lt;Builder&gt; consumer)</span> {	<span class="hljs-comment">// 1.2</span>
    Map&lt;WeaponType, Supplier&lt;Weapon&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();	<span class="hljs-comment">// 2</span>
    consumer.accept(map::put);									<span class="hljs-comment">// 3.0</span>
    <span class="hljs-keyword">return</span> name -&gt; map.get(name).get();							<span class="hljs-comment">// 5</span>
  }
}
</code></pre>
<h5 id="main-5">Main</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">WeaponFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> WeaponFactory.factory(builder -&gt; {	<span class="hljs-comment">// 1.1</span>
      builder.add(WeaponType.SWORD, Sword::<span class="hljs-keyword">new</span>);				<span class="hljs-comment">// 3.1</span>
      builder.add(WeaponType.AXE, Axe::<span class="hljs-keyword">new</span>);					<span class="hljs-comment">// 3.2</span>
      builder.add(WeaponType.SPEAR, Spear::<span class="hljs-keyword">new</span>);				<span class="hljs-comment">// 3.3</span>
      builder.add(WeaponType.BOW, Bow::<span class="hljs-keyword">new</span>);					<span class="hljs-comment">// 3.4</span>
    });
    <span class="hljs-type">Weapon</span> <span class="hljs-variable">axe</span> <span class="hljs-operator">=</span> factory.create(WeaponType.AXE);
    System.out.println(axe.toString());
  }
}
</code></pre>
<p>这里有一段稍微难懂的方法引用语法，我们可以这样理解，跟着标号走</p>
<ol>
<li>首先传入一个<code>consumer</code>对象（1.1-1.2），这个对象就是 Builder，它要实现的唯一方法就是<code>add</code>方法，在括号内我们注意到他利用<code>builder</code>调用了多次<code>add</code>方法，将武器类型和武器对象一一对应了起来；</li>
<li>维护一个 map，用作映射武器类型名字和武器制造方法（Suplier）这个武器制造方法可以制造一种武器</li>
<li>3.0 的代码代表，<code>builder.add(a, b)</code>传入的参数 a 和 b 被这个 map 的<code>put</code>方法所接管，在这个意义上，我们在<code>Main</code>中看到的 3.1-3.4 相当于在<code>Factory.factory()</code>方法中调用 map 的<code>put</code>方法，我们看到 3.1-3.4 后一个参数是一个构造方法引用，用于作为 Suplier 对象来直接返回一个武器对象</li>
<li>往上看到的是 Builder 的 add 方法，这个方法的实现被 3.0 接管了</li>
<li>看到这个 return 语句，千万不要会错意，这个 return 语句其实是上面<code>create</code>方法的实现语句，用于返回一件武器</li>
<li>这段实现真的是无比的迷，毫无逻辑可言</li>
</ol>
<p>大致看懂这段语法糖之后，可以自己尝试实现一个平民版的工厂 Kit，函数式编程很大程度上扭曲了 Java 程序编程的直接意图，让程序晦涩难懂，复现难度大。</p>
<h4 id="friendly-factory-kit">Friendly Factory-kit</h4>
<p>下面是我改进的亲民版的<code>Factory-kit</code>，虽然也用到了 Lambda 和方法引用，但是特别强调了面向对象思想，并不难懂</p>
<h5 id="interfaces">Interfaces</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Builder</span> {
    Product <span class="hljs-title function_">build</span><span class="hljs-params">()</span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Product</span> {
}
</code></pre>
<p>两个接口，一个代表工匠，提供一个<code>buili()</code>方法去获取<code>Product</code>，一个<code>Product</code>接口用做类型约束</p>
<h5 id="factory-2">Factory</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span>&lt;PT&gt; {
    <span class="hljs-keyword">private</span> HashMap&lt;PT, Builder&gt; builders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBuilder</span><span class="hljs-params">(PT productType, Builder builder)</span> {
        builders.put(productType, builder);
    }

    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">produce</span><span class="hljs-params">(PT productType)</span> {
        <span class="hljs-keyword">return</span> builders.get(productType).build();
    }
}
</code></pre>
<p>注意<code>addBuilder</code>方法，第二个参数直接就是 Builder，因为你观察 Builder 可以发现，Builder 接口直接就可以是一个<code>Supplier</code>，用以直接生产产品</p>
<h5 id="implements">Implements</h5>
<h6 id="product-implemenets">Product implemenets</h6>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Axe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Product</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Axe&quot;</span>;
  }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bow</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Product</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Bow&quot;</span>;
  }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">WeaponType</span> {
  AXE, BOW
}
</code></pre>
<h6 id="factory-implements">Factory implements</h6>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeaponFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span>&lt;WeaponType&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeaponFactory</span><span class="hljs-params">()</span> {
        addBuilder(WeaponType.AXE, Axe::<span class="hljs-keyword">new</span>);
        addBuilder(WeaponType.BOW, () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bow</span>());
    }
}
</code></pre>
<p>这里稍微用到了一些 Lambda 的语法了，我们在继承<code>Factory</code>的时候，用泛型去规定产品类型，然后在实现子类的构造方法里面注册工匠，我们注意到，传递<code>Builder</code>的时候，第一次传生产<code>Axe</code>对象的<code>Builder</code>的时候，我直接使用了<code>Axe</code>的构造方法引用，这其实是<strong>初始化了一个专门生产<code>Axe</code>对象的<code>Builder</code>对象，这个<code>Builder</code>对象的<code>build</code>方法的实现就是返回生成的<code>Axe</code>对象</strong>，如果不是很好理解，可以看第二次传入生产<code>Bow</code>对象的<code>Builder</code>对象，一看就懂</p>
<h5 id="main-6">Main</h5>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">WeaponFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeaponFactory</span>();
        System.out.println(factory.produce(WeaponType.AXE));
        System.out.println(factory.produce(WeaponType.BOW));
    }
}
</code></pre>
<h4 id="总结-4">总结</h4>
<p>对于工厂方法，因为它的地位太重要，所以我们在设计一个工厂的时候要特别注意方法和其他对象之间的解耦性，让这个工厂通用性更强一些</p>
<hr>
