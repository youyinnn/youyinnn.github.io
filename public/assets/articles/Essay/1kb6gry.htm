<h3 id="前言">前言</h3>
<blockquote>
<p>微服务架构被提出很短的时间内，就被越来越多的开发人员推崇，简单来说其主要的目的是有效的拆分应用，实现敏捷开发和部署 。</p>
<p>本分享即尝试介绍微服务架构的一些实施细节和要求，探询微服务架构的由来，并最终提供我们团队内部的一些实践总结，希望对大家有帮助。</p>
</blockquote>
<h3 id="what---什么是微服务">WHAT - 什么是微服务</h3>
<h4 id="微服务简介">微服务简介</h4>
<p>这次参加 JavaOne2015 最大的困难就是听 Microservice 相关的 session，无论内容多么水，只要题目带 microservice，必定报不上名，可见 Microservice 有多火。最喜欢其中一页。关于这个典故，可以参考[this](
&lt;<a href="http://knowyourmeme.com/memes/you-keep-using-that-word-i-do-not-think-it-means-what-you-think-it-means)%EF%BC%8C%E6%AD%A4%E5%9B%BE%E9%80%82%E7%94%A8%E4%BA%8E%E4%B8%80%E5%88%87%E9%AB%98%E5%A4%A7%E4%B8%8A%E7%9A%84%E5%90%8D%E5%AD%97%E2%80%94%E2%80%94%E6%8A%80%E6%9C%AF%E6%9C%89SOA%EF%BC%8CAgile%EF%BC%8CCLOUD%EF%BC%8CDevOps%E7%AD%89%E7%AD%89%EF%BC%8C%E5%8F%A4%E4%BB%A3%E6%9C%89%E9%81%93%EF%BC%8C%E6%B0%94%EF%BC%8C%E5%85%AB%E5%8D%A6%E7%AD%89%E7%AD%89%E3%80%82%E6%AD%A4%E7%B1%BB%E5%90%8D%E8%AF%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E7%89%B9%E7%82%B9%E5%B0%B1%E6%98%AF">http://knowyourmeme.com/memes/you-keep-using-that-word-i-do-not-think-it-means-what-you-think-it-means)，此图适用于一切高大上的名字——技术有SOA，Agile，CLOUD，DevOps等等，古代有道，气，八卦等等。此类名词的最大特点就是</a> <strong>一解释就懂，一问就不知，一讨论就打架。</strong>
<img src="../../img/59f97219283a8e8cef996531a05a3c7880fb501b.webp" alt="screenshot"></p>
<p>微服务的流行，Martin 功不可没，这老头也是个奇人，特别擅长抽象归纳和制造概念，我觉的这就是最牛逼的 markting 啊，感觉这也是目前国人欠缺的能力。</p>
<blockquote>
<p>Martin Fowler 是国际著名的 OO 专家，敏捷开发方法的创始人之一，现为 ThoughtWorks 公司的首席科学家.福勒（Martin Fowler），在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为 Thought Works 公司的首席科学家。Thought Works 是一家从事企业应用开发和集成的公司。早在 20 世纪 80 年代，Fowler 就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍：《企业应用架构模式》、《UML 精粹》和《重构》等。—— 百度百科</p>
</blockquote>
<p>先来看看传统的 web 开发方式，通过对比比较容易理解什么是 Microservice Architecture。和 Microservice 相对应的，这种方式一般被称为 Monolithic（比较难传神的翻译）。所有的功能打包在一个 WAR 包里，基本没有外部依赖（除了容器），部署在一个 JEE 容器（Tomcat，JBoss，WebLogic）里，包含了 DO/DAO，Service，UI 等所有逻辑。
<img src="../../img/cb87aabb9b184df0edd6769ef877b4b16b200855.webp" alt="screenshot"></p>
<p>Monolithic 比较适合小项目，优点是：</p>
<ul>
<li>开发简单直接，集中式管理</li>
<li>基本不会重复开发</li>
<li>功能都在本地，没有分布式的管理开销和调用开销</li>
</ul>
<p>它的缺点也非常明显，特别对于互联网公司来说（不一一列举了）：</p>
<ul>
<li>开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断</li>
<li>代码维护难：代码功能耦合在一起，新人不知道何从下手</li>
<li>部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长</li>
<li>稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉</li>
<li>扩展性不够：无法满足高并发情况下的业务需求</li>
</ul>
<p>所以，现在主流的设计一般会采用 Microservice Architecture，就是基于微服务的架构。简单来说， <strong>微服务的目的是有效的拆分应用，实现敏捷开发和部署</strong> 。
<img src="../../img/6a2474878e4c1000335770fe64269269f9211d17.webp" alt="screenshot"></p>
<p>用《The art of scalability》一书里提到的 scale cube 比较容易理解如何拆分。你看，我们叫分库分表，别人总结成了 scale cube，这就是抽象的能力啊，把复杂的东西用最简单的概念解释和总结。X 轴代表运行多个负载均衡器之后运行的实例，Y 轴代表将应用进一步分解为微服务（分库），数据量大时，还可以用 Z 轴将服务按数据分区（分表）
<img src="../../img/238adf07b6afdc6ae246e2da83f83ce2e144cbeb.webp" alt="screenshot"></p>
<h4 id="微服务的具体特征">微服务的具体特征</h4>
<p>先看看最官方的定义吧</p>
<blockquote>
<p>The microservice architectural style is an approach to developing a single application as <strong>a suite of small services</strong>, each <strong>running in its own process</strong> and communicating with lightweight mechanisms, often an HTTP resource API. These services are <strong>built around business capabilities</strong> and independently deployable by fully automated deployment machinery. There is <strong>a bare minimum of centralized management of these services</strong> , which may be written in different programming languages and use different data storage technologies.</p>
<pre><code>            -- James Lewis and Martin Fowler
</code></pre>
</blockquote>
<p>把 Martin 老头的定义大概的翻译一下就是下面几条，这个定义还是太抽象是不是，那就对了，就是要务虚，都说明白了谁还找他付费咨询啊，这么贵。</p>
<ol>
<li>一些列的独立的服务共同组成系统</li>
<li>单独部署，跑在自己的进程里</li>
<li>每个服务为独立的业务开发</li>
<li>分布式的管理</li>
</ol>
<p>Martin 自己也说了，每个人对微服务都可以有自己的理解，不过大概的标准还是有一些的。</p>
<ul>
<li>分布式服务组成的系统</li>
<li>按照业务而不是技术来划分组织</li>
<li>做有生命的产品而不是项目</li>
<li>Smart endpoints and dumb pipes（我的理解是强服务个体和弱通信）</li>
<li>自动化运维（DevOps）</li>
<li>容错</li>
<li>快速演化</li>
</ul>
<p>关于微服务的更多理论基础，可以参考<a href="https://yq.aliyun.com/articles/8611">康威定律</a>。</p>
<h4 id="soa-vs-microservice">SOA vs Microservice</h4>
<p>除了 Smart endpoints and dumb pipes 都很容易理解对吗？相信很多人都会问一个问题，这是不是就是 SOA 换了个概念，挂羊头卖狗肉啊，有说法把 Microservice 叫成 Lightway SOA。也有很多传统砖家跳出来说 Microservice 就是 SOA。其实 Martin 也没否认 SOA 和 Microservice 的关系。</p>
<p>我个人理解，Microservice 是 SOA 的传承，但一个最本质的区别就在于 Smart endpoints and dumb pipes，或者说是真正的分布式的、去中心化的。Smart endpoints and dumb pipes 本质就是去 ESB，把所有的“思考”逻辑包括路由、消息解析等放在服务内部（Smart endpoints），去掉一个大一统的 ESB，服务间轻（dumb pipes）通信，是比 SOA 更彻底的拆分。</p>
<h3 id="how---怎么具体实践微服务">HOW - 怎么具体实践微服务</h3>
<p>听上去好像都不错，具体怎么落地啊？这需要回答下面几个问题：</p>
<ul>
<li>客户端如何访问这些服务？</li>
<li>服务之间如何通信？</li>
<li>这么多服务，怎么找?</li>
<li>服务挂了怎么办？</li>
</ul>
<h4 id="客户端如何访问这些服务？">客户端如何访问这些服务？</h4>
<p>原来的 Monolithic 方式开发，所有的服务都是本地的，UI 可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在独立的虚拟机上的 Java 进程了。客户端 UI 如何访问他的？后台有 N 个服务，前台就需要记住管理 N 个服务，一个服务下线/更新/升级，前台就要重新部署，这明显不服务我们拆分的理念，特别当前台是移动应用的时候，通常业务变化的节奏更快。另外，N 个小服务的调用也是一个不小的网络开销。还有一般微服务在系统内部，通常是无状态的，用户登录信息和权限管理最好有一个统一的地方维护管理（OAuth）。</p>
<p>所以，一般在后台 N 个服务和 UI 之间一般会一个代理或者叫 API Gateway，他的作用包括</p>
<ul>
<li>提供统一服务入口，让微服务对前台透明</li>
<li>聚合后台的服务，节省流量，提升性能</li>
<li>提供安全，过滤，流控等 API 管理功能</li>
</ul>
<p>我的理解其实这个 API Gateway 可以有很多广义的实现办法，可以是一个软硬一体的盒子，也可以是一个简单的 MVC 框架，甚至是一个 Node.js 的服务端。他们最重要的作用是为前台（通常是移动应用）提供后台服务的聚合，提供一个统一的服务出口，解除他们之间的耦合，不过 API Gateway 也有可能成为单点故障点或者性能的瓶颈。</p>
<p>一般用过 Taobao Open Platform 的就能很容易的体会，TAO 就是这个 API Gateway。
<img src="../../img/4da28f2382d64d39ee4942c51636af31e9cc1d0b.webp" alt="screenshot"></p>
<h4 id="服务之间如何通信？">服务之间如何通信？</h4>
<p>因为所有的微服务都是独立的 Java 进程跑在独立的虚拟机上，所以服务间的通行就是 IPC（inter process communication），已经有很多成熟的方案。现在基本最通用的有两种方式。这几种方式，展开来讲都可以写本书，而且大家一般都比较熟悉细节了，就不展开讲了。</p>
<ul>
<li>同步调用<ul>
<li>REST（JAX-RS）</li>
<li>RPC（Dubbo）</li>
</ul>
</li>
<li>异步消息调用(Kafka, Notify, MetaQ)</li>
</ul>
<p><img src="../../img/d7e9a881c8940c216e6c1d8cb3bbbe7407e1e63b.webp" alt="screenshot"></p>
<p>一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。RESTful 和 RPC 的比较也是一个很有意思的话题。一般 REST 基于 HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了 HTTP 的 SDK 就能调用，所以相对使用的广一些。RPC 也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。</p>
<p>而异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据最终一致性；还有就是后台服务一般要实现幂等性，因为消息发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的 broker，如果公司内部没有技术积累，对 broker 分布式管理也是一个很大的挑战。</p>
<h4 id="这么多服务，怎么找">这么多服务，怎么找?</h4>
<p>在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？这就是服务发现的问题了。一般有两类做法，也各有优缺点。基本都是通过 zookeeper 等类似技术做服务注册信息的分布式管理。当服务上线时，服务提供者将自己的服务信息注册到 ZK（或类似框架），并通过心跳维持长链接，实时更新链接信息。服务调用者通过 ZK 寻址，根据可定制算法，找到一个服务，还可以将服务信息缓存在本地以提高性能。当服务下线时，ZK 会发通知给服务客户端。</p>
<ul>
<li>客户端做：优点是架构简单，扩展灵活，只对服务注册器依赖。缺点是客户端要维护所有调用服务的地址，有技术难度，一般大公司都有成熟的内部框架支持，比如 Dubbo。</li>
<li>服务端做：优点是简单，所有服务对于前台调用方透明，一般在小公司在云服务上部署的应用采用的比较多。</li>
</ul>
<p><img src="../../img/61decc9c96f96e795ae36353c9cbcc312c035910.webp" alt="screenshot"></p>
<h4 id="这么多服务，服务挂了怎么办？">这么多服务，服务挂了怎么办？</h4>
<p>前面提到，Monolithic 方式开发一个很大的风险是，把所有鸡蛋放在一个篮子里，一荣俱荣，一损俱损。而分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，不过如果没有特别的保障，结局肯定是噩梦。我们刚遇到一个线上故障就是一个很不起眼的 SQL 计数功能，在访问量上升时，导致数据库 load 彪高，影响了所在应用的性能，从而影响所有调用这个应用服务的前台应用。所以当我们的系统是由一系列的服务调用链组成的时候，我们必须确保任一环节出问题都不至于影响整体链路。相应的手段有很多：</p>
<ul>
<li>重试机制</li>
<li>限流</li>
<li>熔断机制</li>
<li>负载均衡</li>
<li>降级（本地缓存）</li>
</ul>
<p>这些方法基本上都很明确通用，就不详细说明了。比如 Netflix 的 Hystrix：<a href="https://github.com/Netflix/Hystrix">https://github.com/Netflix/Hystrix</a>
<img src="../../img/d639a17e4d2c9fc8d0ceebed2eaf32016096c458.webp" alt="screenshot"></p>
<h4 id="why---微服务的应用">WHY - 微服务的应用</h4>
<p><a href="http://microservices.io/patterns/microservices.html">这里</a>有一个图非常好的总结微服务架构需要考虑的问题，包括</p>
<ul>
<li>API Gateway</li>
<li>服务间调用</li>
<li>服务发现</li>
<li>服务容错</li>
<li>服务部署</li>
<li>数据调用</li>
</ul>
<p><img src="../../img/766c31d336cfe1e455547fdf5f3a3751f62bdd59.webp" alt="screenshot"></p>
<p>微服务的优点和缺点（或者说挑战）一样明显。</p>
<ul>
<li>优点<ul>
<li>开发简单</li>
<li>技术栈灵活</li>
<li>服务独立无依赖</li>
<li>独立按需扩展</li>
<li>可用性高</li>
</ul>
</li>
<li>缺点（挑战）<ul>
<li>多服务运维难度</li>
<li>系统部署依赖</li>
<li>服务间通信成本</li>
<li>数据一致性</li>
<li>系统集成测试</li>
<li>重复工作</li>
<li>性能监控</li>
</ul>
</li>
</ul>
<p>没有最好的，只有适合自己的。</p>
<ul>
<li>对于大的互联网公司，微服务架构是血液，是习惯，每家公司都有自己的套路和架构，细节有不同，但是核心理念是通的。</li>
<li>对于一般的公司而言，实践微服务有非常大的技术挑战，于是乎才有了这么多 IT 供应商考虑这里的商机。微服务比较适合未来有一定的扩展复杂度，且有很大用户增量预期的应用，说人话就是新兴的互联网公司。创业初期，不可能买大量的机器或者很贵的机器，但是又必须考虑应对成功后的巨量的用户，微服务架构成了最好的选择。
<img src="../../img/052b1cebf73e0b31c502341e0e3cc916a3da2a25.webp" alt="screenshot"></li>
</ul>
<h3 id="so-what---思考">So What - 思考</h3>
<p>看到上面的图，不是不觉得特别的熟悉？其实我们 N 年前就用的滚瓜烂熟了好不好？裤子都拖了，你就给我看这个？</p>
<p><img src=".webphttps://camo.githubusercontent.com/e5151c52066f1dd92fbae7ed40f6cc0f0d410fa0/68747470733a2f2f7261772e6769746875622e636f6d2f4e6574666c69782f726563697065732d7273732f6d61737465722f696d616765732f526563697065735f5253532e706e67" alt="screenshot">
from: <a href="https://github.com/Netflix/recipes-rss/wiki/Architecture">https://github.com/Netflix/recipes-rss/wiki/Architecture</a></p>
<p>其实本来所谓的微服务就是对互联网在应用技术的一个总结归纳，IT 厂商鼓吹所有概念无非是为了生意（business），SOA 是，Cloud 是，Microservice 也是。下面玩笑很有意思的概括了这个情况（我加了第一条线，原图见<a href="http://blog.gardeviance.org/2012/07/adoption-cycles.html">这里</a>）
<img src="../../img/f9684c79f476a27982f3285cfb9b5b6eb7e29517.webp" alt="screenshot"></p>
<p>所以微服对我们的思考我觉得更多的是思维上的，对已微服务架构， <strong>技术上不是问题，意识比工具重要。</strong></p>
<ul>
<li>按照业务 或者客户需求组织资源（这是最难的）</li>
<li>做有生命的产品，而不是项目</li>
<li>头狼战队，全栈化</li>
<li>后台服务贯彻 Single Responsibility Principle</li>
<li>VM-&gt;Docker （to PE）</li>
<li>DevOps (to PE)</li>
</ul>
<p>同时，对于开发同学，有这么多的中间件和强大的 PE 支持固然是好事，我们也需要深入去了解这些中间件背后的原理，知其然知其所以然，设想下，如果我们是一个小公司的 CTO，离开的阿里的大环境，在有限的技术资源如何通过开源技术实施微服务？</p>
<p>最后，一般提到微服务都离不开 DevOps 和 Docker，理解微服务架构是核心，devops 和 docker 是工具，是手段。下次在抽时间再学习整理下。
<img src="../../img/2ada4ac057eaf561f8862572bf6327845c482ca7.webp" alt="screenshot"></p>
<blockquote>
<p>转载自：<a href="https://yq.aliyun.com/articles/2764">https://yq.aliyun.com/articles/2764</a></p>
</blockquote>
