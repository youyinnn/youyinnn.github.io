<h3 id="26-remove-duplicated-from-sorted-arrayeasy">26. Remove Duplicated From Sorted Array(Easy)</h3>
<p>Given a sorted array <em>nums</em>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn&#x27;t matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn&#x27;t matter what values are set beyond the returned length.
</code></pre>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// nums is passed in by reference. (i.e., without making a copy)</span>
<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> removeDuplicates(nums);

<span class="hljs-comment">// any modification to nums in your function would be known by the caller.</span>
<span class="hljs-comment">// using the length returned by your function, it prints the first len elements.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre>
<h4 id="brute-force">Brute Force</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, set = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">if</span> (range &lt; nums.length - <span class="hljs-number">1</span> &amp;&amp;
            nums[range] == nums[range + <span class="hljs-number">1</span>]) {
            range++;
        } <span class="hljs-keyword">else</span> {
            nums[set] = nums[range];
            set++;
            range++;
            len++;
        }
    }
    <span class="hljs-keyword">return</span> len;
}
</code></pre>
<h3 id="27-remove-elementeasy">27. Remove Element(Easy)</h3>
<p>Given an array <em>nums</em> and a value <em>val</em>, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn&#39;t matter what you leave beyond the new length.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn&#x27;t matter what you leave beyond the returned length.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn&#x27;t matter what values are set beyond the returned length.
</code></pre>
<p><strong>Clarification:</strong></p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<h4 id="brute-force-1">Brute Force</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">if</span> (nums[i] != val) {
            nums[len++] = nums[i];
        }
    }
    <span class="hljs-keyword">return</span> len;
}
</code></pre>
<h3 id="28-implement-strstr-easy">28. Implement strStr() (Easy)</h3>
<p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/">strStr()</a>.</p>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
Output: 2
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
Output: -1
</code></pre>
<p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C&#39;s <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java&#39;s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a>.</p>
<p>è¿™é¢˜å…¶å®å°±æ˜¯å­—ç¬¦ä¸²åŒ¹é…ï¼Œæ‰€ä»¥æ²¡ä»€ä¹ˆå¤šè¯´çš„ï¼Œè¦ä¹ˆæš´åŠ›è§£è¦ä¹ˆ kmpï¼Œæ¯”è¾ƒé—æ†¾çš„æ˜¯ï¼ŒLeetcode çš„ case ä¸å¤Ÿå¤šï¼Œäºæ˜¯æš´åŠ›è§£çš„ Runtime å±…ç„¶æ¯” KMP è§£çš„ Runtime è¿˜è¦å¿«</p>
<h4 id="brute-force---on--m">Brute Force - O(n * m)</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> {
    <span class="hljs-keyword">if</span> (needle.isEmpty()) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-type">char</span>[] t = haystack.toCharArray();
    <span class="hljs-type">char</span>[] p = needle.toCharArray();
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length;
    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n - m; i++){
        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(j &lt; m &amp;&amp; p[j] == t[i + j]){
            j++;
            <span class="hljs-keyword">if</span> (j == m) <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre>
<h4 id="kmp---on--m">KMP - O(n + m)</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> {
    <span class="hljs-keyword">if</span> (needle.isEmpty()) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> kmp(haystack.toCharArray(), needle.toCharArray());
}

<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmp</span><span class="hljs-params">(<span class="hljs-type">char</span>[] t, <span class="hljs-type">char</span>[] p)</span> {
    <span class="hljs-type">int</span>[] next = nextVal(p);
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) {
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || t[i] == p[j]) {
            <span class="hljs-comment">// æœ‰åŒ¹é…å°±++</span>
            i++;
            j++;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// å¦åˆ™å°±æŒ‰ç…§nextå»ç§»ä½j</span>
            j = next[j];
        }
    }
    <span class="hljs-keyword">if</span> (j == p.length) {
        <span class="hljs-keyword">return</span> i - j;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] nextVal(<span class="hljs-type">char</span>[] p) {
    <span class="hljs-type">int</span>[] nextVal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[p.length];
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
    nextVal[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (j &lt; p.length - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (k == -<span class="hljs-number">1</span> || p[j] == p[k]) {
            j++;
            k++;
            <span class="hljs-keyword">if</span> (p[j] != p[k]) {
                nextVal[j] = k;
            } <span class="hljs-keyword">else</span> {
                nextVal[j] = nextVal[k];
            }
        } <span class="hljs-keyword">else</span> {
            k = nextVal[k];
        }
    }
    <span class="hljs-keyword">return</span> nextVal;
}
</code></pre>
<h3 id="29-divide-two-integer-medium">29. Divide Two Integer (Medium)</h3>
<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p>
<p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p>
<p>The integer division should truncate toward zero.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: dividend = 10, divisor = 3
Output: 3
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: dividend = 7, divisor = -3
Output: -2
</code></pre>
<p><strong>Note:</strong></p>
<ul>
<li>Both dividend and divisor will be 32-bit signed integers.</li>
<li>The divisor will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [âˆ’231, 231 âˆ’ 1]. For the purpose of this problem, assume that your function returns 231 âˆ’ 1 when the division result overflows.</li>
</ul>
<p>ä¸èƒ½ç”¨ä¹˜é™¤ç¬¦å·ã€ä¸èƒ½ç”¨ Longï¼Œè¡Œå§ï¼Œç”¨ä½è¿ç®—è¯•è¯•ï¼Œä¸¤å€ä¸¤å€åœ°è¿ç®—ï¼Œæ€»æ¯”æš´åŠ›ä¸€ä¸ªä¸€ä¸ªçš„å‡è¦å¿«å¤šäº†</p>
<p>ä½†æ˜¯æ€ä¹ˆè¯´ï¼Œè¿™é¢˜ä¹Ÿæ˜¯åƒåœ¾é¢˜ï¼Œ500+ğŸ‘ï¼Œ2700+çš„ğŸ‘</p>
<h4 id="bit-operation-beat-100">Bit operation (Beat 100%)</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span> {
    <span class="hljs-keyword">if</span>(dividend ==  Integer.MIN_VALUE &amp;&amp; divisor == -<span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;
    }

    <span class="hljs-type">boolean</span> <span class="hljs-variable">isNeg</span> <span class="hljs-operator">=</span> (dividend &lt; <span class="hljs-number">0</span>) ^ (divisor &lt; <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span>(dividend &gt; <span class="hljs-number">0</span>) dividend = -dividend;
    <span class="hljs-keyword">if</span>(divisor &gt; <span class="hljs-number">0</span>) divisor = -divisor;

    <span class="hljs-keyword">return</span> isNeg? -div(dividend, divisor) : div(dividend, divisor);
}
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> divid, <span class="hljs-type">int</span> divis)</span>{
    <span class="hljs-keyword">if</span>(divid &gt; divis) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">curSum</span> <span class="hljs-operator">=</span> divis &lt;&lt; <span class="hljs-number">1</span>, prevSum = divis, q = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span>(divid &lt;= curSum &amp;&amp; curSum &lt; prevSum){
        prevSum = curSum;
        curSum &lt;&lt;= <span class="hljs-number">1</span>; q &lt;&lt;= <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> q + div(divid - prevSum, divis);
}
</code></pre>
<h3 id="30-substring-with-concatenation-of-all-wordshard-">30. Substring with Concatenation of All Words(Hard !!)</h3>
<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input:
  s = &quot;barfoothefoobarman&quot;,
  words = [&quot;foo&quot;,&quot;bar&quot;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.
The output order does not matter, returning [9,0] is fine too.
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input:
  s = &quot;wordgoodgoodgoodbestword&quot;,
  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]
Output: []
</code></pre>
<p>è¿™é¢˜ï¼Œå˜æ€éš¾ï¼Œé¦–å…ˆ words èƒ½å…¨æ’åˆ—å‡º nï¼ç§ patternï¼Œå¦‚æœè¿™é¢˜ç”¨å…¨æ’åˆ—å»åšï¼Œç„¶åæ¯ä¸ªæ’åˆ—å» indexOfï¼Œé‚£è‚¯å®š TLEï¼Œå…ˆä¸è¯´ indexOf çš„æ•ˆç‡ï¼Œå°±æ˜¯éé€’å½’çš„å…¨æ’åˆ—ï¼Œä¸€æ—¶åŠä¼šä¹Ÿå†™ä¸å‡ºæ¥ï¼Œé€’å½’å…¨æ’åˆ—ç»å£ TLE</p>
<p>ä¸ç”¨å…¨æ’åˆ—ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»æ¦‚ç‡çš„è§’åº¦æ¥æ€è€ƒä¸€ä¸‹ï¼Œå‡å¦‚æˆ‘ä»¬æŠŠå…¨æ’åˆ—çš„ä¸€ä¸ªè§£ç§°ä¸ºä¸€ä¸ª<strong>pattern</strong></p>
<p>ä»ç¬¬äºŒä¸ªä¾‹å­æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œä¸€ä¸ªå¯èƒ½çš„<strong>pattern</strong>å¿…ç„¶åŒ…å«æ‰€æœ‰å•è¯å‡ºç°çš„é¢‘æ•°ï¼›è¿™æ˜¯ç¬¬ä¸€ä¸ªå…³é”®ç‚¹ï¼›</p>
<p>ç¬¬äºŒä¸ªç‚¹å°±æ˜¯ï¼Œæˆ‘ä»¬å¤„ç†å­—ç¬¦ä¸²åŒ¹é…çš„æ—¶å€™ï¼Œä¸å…ä¼šå…·è±¡åŒ–ä¸€ä¸ªæ»‘åŠ¨çª—å£å‡ºæ¥ï¼Œè¿™ä¸ªæ»‘åŠ¨çª—å£é˜”ç€ s ä¸²ä¸­çš„ä¸€ä¸ªå’Œ<strong>pattern</strong>ä¸€æ ·é•¿çš„å­ä¸²ï¼›</p>
<p>é‚£ä¹ˆä¸€ä¸ªæ˜æ˜¾çš„æ€è·¯æ˜¯ï¼šæˆ‘ä»¬çŸ¥é“ words ä¸­çš„å•è¯éƒ½æ˜¯ä¸€æ ·é•¿çš„ï¼Œå‡å¦‚è¯´çª—å£ä¸­çš„å­ä¸²ï¼Œä»å¤´å¼€å§‹æ¯ä¸ªä¸€ä¸ª word é•¿åº¦ï¼Œéƒ½æœ‰ä¸€ä¸ªå•è¯åŒ¹é…åˆ° words ä¸­çš„ wordï¼Œè€Œä¸”æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªä¸´æ—¶çš„ words é¢‘æ•°è®¡æ•°å™¨ï¼Œæ¯åŒ¹é…åˆ°ä¸€ä¸ªå•è¯å°±å¢åŠ è¿™ä¸ªé¢‘æ•°è®¡æ•°</p>
<p>äºæ˜¯åˆ°æœ€åå°±åªä¼šæœ‰ä¸‰ç§å¯èƒ½ï¼š</p>
<ol>
<li>çª—å£ä¸­çš„æŸä¸ª word å¹¶æ²¡æœ‰åœ¨ words ä¸­è®°è¿‡é¢‘æ•°ï¼›</li>
<li>çª—å£ä¸­çš„æŸä¸ª word ä¸´æ—¶å‡ºç°çš„é¢‘æ•°è¶…è¿‡ words ä¸­è®°è¿‡é¢‘æ•°ï¼›</li>
<li>çª—å£ä¸­æœ€åä¸€ä¸ª word éƒ½æ²¡æœ‰å‡ºç°ä¸Šé¢ä¸¤ä¸ªå¯èƒ½ï¼›é‚£ä¹ˆè¿™å°±æ˜¯ä¸€ä¸ªè§£ï¼</li>
</ol>
<p>äºæ˜¯æˆ‘ä»¬å¤„ç†é—®é¢˜çš„å…³é”®å°±åœ¨äºï¼Œå¦‚ä½•<strong>é¿å…é‡å¤çš„å•è¯å¯¹æ¯”è€Œæ»‘åŠ¨çª—å£</strong></p>
<p>å…¶å®æˆ‘è‡ªå·±æƒ³æ˜¯å·²ç»æƒ³åˆ°äº†é¢‘æ•°è®°å½•ï¼Œç„¶åæ»‘åŠ¨çª—å£äº†ï¼Œä½†æ˜¯æˆ‘åªèƒ½ i++åœ°æ»‘åŠ¨çª—å£ï¼Œæ•ˆç‡æ…¢äº†è®¸å¤šï¼Œå…ˆæ”¾ä¸Šæˆ‘çš„è§£</p>
<h4 id="my-solution-550ms-beat-90">My Solution (550+ms Beat 9.0%)</h4>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring</span><span class="hljs-params">(String s, String[] words)</span> {
    LinkedList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    <span class="hljs-keyword">if</span> (words.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> ans;
    }
    <span class="hljs-type">int</span> <span class="hljs-variable">wordLength</span> <span class="hljs-operator">=</span> words[<span class="hljs-number">0</span>].length();
    HashMap&lt;String, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(words.length);
    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (String word : words) {
        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> countMap.get(word);
        <span class="hljs-keyword">if</span> (integer != <span class="hljs-literal">null</span>) {
            countMap.put(word, ++integer);
        } <span class="hljs-keyword">else</span> {
            countMap.put(word, <span class="hljs-number">1</span>);
        }
        count++;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length() - wordLength + <span class="hljs-number">1</span>; i++) {
        <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> s.substring(i, i + wordLength);
        <span class="hljs-type">Integer</span> <span class="hljs-variable">firstCount</span> <span class="hljs-operator">=</span> countMap.get(first);
        <span class="hljs-type">int</span> <span class="hljs-variable">tmpCount</span> <span class="hljs-operator">=</span> count;
        <span class="hljs-keyword">if</span> (firstCount != <span class="hljs-literal">null</span>) {
            HashMap&lt;String, Integer&gt; tmp = (HashMap&lt;String, Integer&gt;) countMap.clone();
            tmp.put(first, --firstCount);
            tmpCount--;
            <span class="hljs-type">int</span> <span class="hljs-variable">tmpI</span> <span class="hljs-operator">=</span> i;
            <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">if</span> (tmpCount == <span class="hljs-number">0</span>) {
                    ans.add(i);
                    <span class="hljs-keyword">break</span>;
                } <span class="hljs-keyword">else</span> {
                    tmpI = tmpI + wordLength;
                    <span class="hljs-keyword">if</span> (tmpI &lt;= s.length() - wordLength) {
                        <span class="hljs-type">String</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> s.substring(tmpI, tmpI + wordLength);
                        <span class="hljs-type">Integer</span> <span class="hljs-variable">nextCount</span> <span class="hljs-operator">=</span> tmp.get(next);
                        <span class="hljs-keyword">if</span> (nextCount != <span class="hljs-literal">null</span> &amp;&amp; nextCount != <span class="hljs-number">0</span>) {
                            tmp.put(next, --nextCount);
                            tmpCount--;
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-keyword">break</span>;
                        }
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">break</span>;
                    }
                }
            } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);
        }
    }
    <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<h4 id="elegant-solution-9ms-beat-996">Elegant Solution (9ms Beat 99.6%)</h4>
<p>leetcode ä¸Šæ•ˆç‡æœ€å¿«çš„è§£ï¼Œç”¨ä¸€ç§éš¾ä»¥æƒ³è±¡çš„æ–¹å¼å»æ»‘åŠ¨çª—å£ï¼Œä¼˜é›…è€Œæ™¦æ¶©</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findSubstring2</span><span class="hljs-params">(String s, String[] words)</span> {
    List&lt;Integer&gt; indexes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">if</span> (words.length == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> indexes;
    }
    <span class="hljs-type">int</span> <span class="hljs-variable">wordLength</span> <span class="hljs-operator">=</span> words[<span class="hljs-number">0</span>].length();
    <span class="hljs-type">int</span> <span class="hljs-variable">patternLength</span> <span class="hljs-operator">=</span> wordLength * words.length;
    <span class="hljs-keyword">if</span> (patternLength &gt; s.length()) {
        <span class="hljs-keyword">return</span> indexes;
    }

    Map&lt;String, Integer&gt; strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(words.length);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; words.length; ++i) {
        strings.put(words[i], strings.getOrDefault(words[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
    }

    Map&lt;String, Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; wordLength; ++k) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt;= s.length() - patternLength; i += wordLength) {
            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + patternLength;
            <span class="hljs-keyword">for</span> (; j &gt; i; j -= wordLength) {
                <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> s.substring(j - wordLength, j);
                <span class="hljs-keyword">if</span> (temp.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>
                        &gt; strings.getOrDefault(word, <span class="hljs-number">0</span>)) {
                    i = j - wordLength;
                    <span class="hljs-keyword">break</span>;
                }
                temp.put(word, temp.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">if</span> (j == i) {
                indexes.add(i);
            }
            temp.clear();
        }
    }
    <span class="hljs-keyword">return</span> indexes;
}
</code></pre>
<p>å‡å¦‚æˆ‘ä»¬ä¸€ä¸ªå•è¯çš„é•¿åº¦æ˜¯<code>wordLength</code>ï¼Œä¸€ä¸ª pattern çš„é•¿åº¦æ˜¯<code>patternLength</code></p>
<p>18 è¡Œå¼€å§‹æ˜¯ç²¾é«“ï¼Œç”¨äº† 3 ä¸ª for å»åšæ»‘åŠ¨çª—å£ï¼Œå…¶ä¸­ï¼š</p>
<ul>
<li><p>ç¬¬ä¸€ä¸ª for é•¿åº¦æ˜¯å•è¯çš„é•¿åº¦ï¼Œå®ƒå¯ä»¥å¤„ç†åå·®ï¼Œå¯ä»¥ç†è§£ä¸ºæ»‘åŠ¨çª—å£çš„å‡ºå‘ç‚¹ï¼Œå› ä¸ºæˆ‘ä»¬<strong>æ»‘åŠ¨çª—å£çš„é•¿åº¦æ€»æ˜¯å•è¯é•¿åº¦çš„å€æ•°ï¼ˆ<code>j = i + patternLength</code>ï¼‰ï¼Œå¹¶ä¸”æ€»æ˜¯ä»¥å•è¯é•¿åº¦çš„å€æ•°ä¸ºè·ç¦»åšæ»‘åŠ¨ï¼ˆ<code>i += wordLength</code>ï¼‰</strong>ï¼Œæƒ³è±¡ä¸€ä¸‹å°±çŸ¥é“äº†ï¼Œæ¯”å¦‚ï¼š</p>
<p><code>s = â€œaasosfoobarâ€ words = [&quot;foo&quot;, &quot;bar&quot;]</code>çš„æ—¶å€™ï¼Œç¬¬ä¸€ä¸ªç¬¬ä¸€ä¸ªå¾ªç¯è¡¨ç¤ºåªéœ€è¦æ¯æ¬¡ä»<strong>ç¬¬ä¸€ä¸ª a</strong>æˆ–è€…<strong>ç¬¬äºŒä¸ª a</strong>æˆ–<strong>ç¬¬ä¸‰ä¸ª s</strong>å¼€å§‹å¾€åæ»‘åŠ¨çª—å£å°±è¡Œäº†ï¼Œå› ä¸º<strong>ç¬¬å››ä¸ª o</strong>å¦‚æœä¹Ÿéœ€è¦æ»‘åŠ¨çš„è¯ï¼Œå®ƒå¾—åˆ°çš„ç»“æœä¼šæœ‰ä¸€éƒ¨åˆ†å’Œ<strong>ç¬¬ä¸€ä¸ª a</strong>é‡å ï¼›å†å…¶æ¬¡ï¼Œå¦‚æœè¦çª—å£æ»‘åŠ¨åˆ°è§£<code>foobar</code>å¤„çš„è¯ï¼Œå¿…é¡»ä»<strong>ç¬¬ä¸‰ä¸ª s</strong>ä¸ºèµ·ç‚¹ï¼Œå¯¹æ¯”ä¸¤æ¬¡ï¼ˆ<strong>æ»‘åŠ¨ä¸¤ä¸ªå•è¯é•¿åº¦è·ç¦»</strong>ï¼‰æ‰æ»‘åŠ¨åˆ°æ­£è§£å¤„ï¼›</p>
</li>
<li><p>ç¬¬äºŒä¸ª for å¾ªç¯æ˜¯ç”¨äºæ»‘åŠ¨çª—å£è·ç¦»çš„ï¼›</p>
</li>
<li><p>ç¬¬ä¸‰ä¸ª for å¾ªç¯ä¹Ÿæ˜¯ç²¾é«“ï¼Œæ˜¯ç”¨äºå¯¹æ¯”çª—å£é‡Œçš„å•è¯å‡ºç°çš„é¢‘æ•°çš„ï¼Œæ ¹æ®é¢‘æ•°ç»“æœæ¥<strong>è®°å½•è§£æˆ–è€…å†³å®šä¸‹ä¸€æ¬¡æ»‘åŠ¨çª—å£çš„èµ·ç‚¹</strong></p>
<p>ä¸ºä»€ä¹ˆè¿™é‡Œè¦å†³å®šä¸‹ä¸€æ¬¡æ»‘åŠ¨çª—å£çš„èµ·ç‚¹ï¼ŸåŸå› å¾ˆç®€å•ï¼Œåœ¨å¤„ç†çš„æ—¶å€™æˆ‘ä»¬å·²ç»çŸ¥é“å½“å‰çª—å£<strong>å°¾éƒ¨</strong>æœ‰å‡ ç»„<strong>è¿ç»­</strong>å•è¯æ˜¯<strong>å‡ºç°åœ¨ words</strong>é‡Œçš„ï¼Œè€Œå½“å‰çª—å£<strong>å¤´éƒ¨</strong>å¯èƒ½æœ‰å‡ ç»„å•è¯æ˜¯<strong>ä¸å‡ºç°åœ¨ words</strong>é‡Œçš„ï¼Œå¦‚æœæœ‰ä¸å‡ºç°åœ¨ words ä¸­çš„å•è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸‹ä¸€æ¬¡æ»‘åŠ¨çª—å£çš„èµ·ç‚¹å¯ä»¥ä»å½“å‰çª—å£ä¸­<strong>å°¾éƒ¨è¿ç»­å‘½ä¸­</strong>çš„åœ°æ–¹å¼€å§‹ç»§ç»­å¯¹æ¯”çª—å£ï¼Œå› ä¸ºè¿™éƒ¨åˆ†è¿ç»­çš„å‘½ä¸­å•è¯åœ¨ä¸‹ä¸€ä¸ªçª—å£ä¸­å¯èƒ½æ˜¯ä¸€ä¸ªè§£ï¼›</p>
</li>
</ul>
<p>åˆ†æèµ·æ¥æ¯”è¾ƒå¤æ‚ï¼Œå®ç°èµ·æ¥å°±æ›´ç²¾å¦™äº†ï¼Œæˆ‘ä»¬ä»ç¬¬ä¸‰ä¸ª for å¾ªç¯ä¸­å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬æ˜¯ä»çª—å£çš„åé¢å¾€å‰æ¯”è¾ƒçš„ï¼ˆ<code>j -= wordLength</code>ï¼‰ï¼Œå¦‚æœæ¯”è¾ƒåˆ°æ²¡æœ‰å‘½ä¸­çš„å•è¯ï¼Œé‚£ä¹ˆ<strong>å½“å‰çš„ j</strong>ï¼Œå°±æ˜¯ä¸‹ä¸€æ¬¡çª—å£çš„èµ·ç‚¹ï¼Œä¸ºä»€ä¹ˆè¦<code>i = j - wordLength</code> ï¼Ÿå› ä¸ºä¸‹ä¸€æ¬¡ i å¾ªç¯ä¹‹å‰ä¼šæ‰§è¡Œä¸€æ¬¡<code>i += wordLength</code></p>
<p>ç„¶å 30 è¡Œå¤„ï¼Œå¦‚æœ j å·²ç»å’Œ i ä¸€æ ·äº†ï¼Œé‚£ä¹ˆè¯´æ˜ä»çª—å£çš„æœ€ååˆ°æœ€å‰éƒ½å‘½ä¸­äº†ï¼Œå¹¶ä¸”ç¬¦åˆé¢‘æ•°é™åˆ¶ï¼Œäºæ˜¯è¿™æ˜¯ä¸€ç»„åˆæ³•çš„è§£</p>
