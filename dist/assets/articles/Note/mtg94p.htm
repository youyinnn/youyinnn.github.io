<h4 id="目录">目录</h4>
<ul>
<li>eclipse 快捷键</li>
<li>数组的使用</li>
<li>初始化</li>
<li>for-each 遍历</li>
<li>使用底层 API 快速复制</li>
<li>搭配 Arrays 类进行二分查找和排序</li>
<li>String 类</li>
<li>截取/替换/匹配</li>
<li>转其他类型</li>
<li>分割/简单的单词提取/大小写字母转换</li>
<li>StringBuffer 和 StringBuilder 类</li>
<li>Math 类/Random 类</li>
<li>两个大数类</li>
<li>集合框架的基本使用/及自定义排序的比较器实现:</li>
<li>ArrayList:放置/索引/移除/遍历</li>
<li>HashSet/TreeSet:放置/索引/移除/遍历</li>
<li>HashMap:放置/索引/移除/遍历</li>
<li>Stack/Vector:结构特性使用到算法当中去</li>
<li>搭配 Collections 类进行:</li>
<li>二分查找(针对 List 且需要实现比较器)</li>
<li>最大最小值(针对 List 和 Set 且需要实现比较器)</li>
<li>快速替换(replaceAll,针对 List)</li>
<li>逆转顺序(reverse,针对 List)</li>
<li>距离轮换(rotate,针对 List)</li>
<li>排序(针对 List)</li>
<li>交换位置(针对 List)</li>
<li>数组和集合框架之间的转换</li>
<li>输入输出挂</li>
<li>快速进制转换</li>
<li>小数点精度处理</li>
</ul>
<hr>
<h4 id="1-eclipse-快捷使用暴富">1. Eclipse 快捷使用暴富</h4>
<h5 id="11-开启自动代码提示">1.1 开启自动代码提示</h5>
<p>默认是只有.符号触发, 我们把所有字母的大小写和.一起加入代码提示的触发:</p>
<ul>
<li>开启路径:Window-&gt;Perferences-&gt;Java-&gt;Editor-&gt;Content Assist 栏目, 在这个框里把字母大小写敲个遍, <strong>不要忘记把点符号&quot;.&quot;也加上</strong>:
<img src="../../img/cf472e6b33efa166407c366d667ded0c.webp" alt="1"></li>
</ul>
<h5 id="12-快捷键优化">1.2 快捷键优化</h5>
<h6 id="121-run-快捷键修改">1.2.1 Run 快捷键修改</h6>
<ul>
<li>开启路径:Window-&gt;Perferences-&gt;Keys</li>
<li>在 Keys 的搜索框里搜:run, 看到有图标的这个就是了, 默认是 Ctrl+F11, 但是这个键位跨度有点大, 我习惯改为 Alt+3
<img src="../../img/c1a3c5f51a5e9863949608354f979d95.webp" alt="2"></li>
</ul>
<h6 id="122-debug-快捷键修改">1.2.2 Debug 快捷键修改</h6>
<ul>
<li>虽然说没啥事也用不上 Debug, 但是我还是习惯改为 Alt+4</li>
</ul>
<h6 id="123-重复当前行">1.2.3 重复当前行</h6>
<ul>
<li>在 Keys 的搜索框里搜:duplicate, 同一个方法调用多次的时候, 需要快捷重复当前行, 我习惯改为 Ctrl+D</li>
</ul>
<h6 id="124-上下移动某行代码">1.2.4 上下移动某行代码</h6>
<ul>
<li>原来的快捷键就挺科学的了, alt+方向键上下</li>
</ul>
<h5 id="13-代码模板快捷使用">1.3 代码模板快捷使用</h5>
<h6 id="131-systemoutprintln">1.3.1 System.out.println();</h6>
<ul>
<li><p>默认是 sysout 呼出, 可以改为 sys, 看个人习惯- -
<img src="../../img/1ff57526c65c8fea970940226be8e74f.webp" alt="3"></p>
</li>
<li><p>修改配置路径:Window-&gt;搜索框搜索:Templates, 找到 Java-&gt;Editor-&gt;Templates
<img src="../../img/61305b96fed7d551bff912f41a30ae3e.webp" alt="4"></p>
</li>
<li><p>双击之后就可以改, 它只是增加了一个 而不是把原来的改了
<img src="../../img/6d8d94bba53204980044b88d8a8db804.webp" alt="5"></p>
</li>
</ul>
<h6 id="132-for-循环while-循环等">1.3.2 for 循环/while 循环等</h6>
<p>从上面的 Templates 中可以找到许多代码段, 自己试着呼出就好;
<img src="../../img/50a894e8516a818c2bba882008417f78.webp" alt="6"></p>
<hr>
<h4 id="2-数组的使用">2. 数组的使用</h4>
<h5 id="21-初始化">2.1 初始化</h5>
<pre><code class="hljs language-java">        <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
        <span class="hljs-type">double</span>[] b = {<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>};
        <span class="hljs-type">float</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">float</span>[<span class="hljs-number">3</span>];
</code></pre>
<h5 id="22-for-each-循环快速遍历">2.2 for-each 循环快速遍历</h5>
<pre><code class="hljs language-java">        <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : a) {
            System.out.println(i);
        }
</code></pre>
<blockquote>
<p>后面对于 List 和 Set 等容器类, 也可以用 for-each 循环来遍历, 需要特别注意的是, 这个语法只能用来遍历, 并不能用来访问修改, 如果在遍历的过程中你修改了要遍历的数组或者容器, 则会报错;</p>
</blockquote>
<h5 id="23-底层-api-快速复制数组">2.3 底层 API 快速复制数组</h5>
<pre><code class="hljs language-java">        <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
        <span class="hljs-type">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];
        System.arraycopy(a, <span class="hljs-number">0</span>, d, <span class="hljs-number">0</span>, a.length);
</code></pre>
<h6 id="数组复制-api">数组复制 API</h6>
<p><code>public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</code></p>
<p>参数：</p>
<ul>
<li>src - 源数组。</li>
<li>srcPos - 源数组中的起始位置。</li>
<li>dest - 目标数组。</li>
<li>destPos - 目标数据中的起始位置。</li>
<li>length - 要复制的数组元素的数量。</li>
</ul>
<h5 id="24-搭配-arrays-类">2.4 搭配 Arrays 类</h5>
<h6 id="241-二分查找">2.4.1 二分查找</h6>
<pre><code class="hljs language-java">        <span class="hljs-type">double</span>[] b = {<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>};
        System.out.println(Arrays.binarySearch(b, <span class="hljs-number">1.0</span>));
</code></pre>
<p>该 API 最好仅用于基本数据类型数组的二分查找, 虽然自定义类型也可以, 但是你还不如把自定义类存 List 里, 用 Collections 配套的二分查找;</p>
<h6 id="242-升序排序">2.4.2 升序排序</h6>
<pre><code class="hljs language-java">        <span class="hljs-type">int</span>[] e = {<span class="hljs-number">4</span>,<span class="hljs-number">66</span>,<span class="hljs-number">234</span>,<span class="hljs-number">32</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">23</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>};
        Arrays.sort(e);
        System.out.println(Arrays.toString(e));
</code></pre>
<p>该 API 是对源数组进行排序, 所以调用之后 e 里面的元素顺序变为自然升序;</p>
<hr>
<h4 id="3-string-类的使用">3. String 类的使用</h4>
<h5 id="31-截取替换匹配">3.1 截取/替换/匹配</h5>
<pre><code class="hljs language-java">        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello LanQiaoBei&quot;</span>;
        System.out.println(a.substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>));
        System.out.println(a.replace(<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>));
        System.out.println(a.replaceAll(<span class="hljs-string">&quot;[a-z]&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>));
        System.out.println(a.replace(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>));
        System.out.println(a.replaceFirst(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>));
        System.out.println(a.contains(<span class="hljs-string">&quot;Lan&quot;</span>));
        System.out.println(a.indexOf(<span class="hljs-string">&quot;Lan&quot;</span>));
        System.out.println(a.lastIndexOf(<span class="hljs-string">&#x27;e&#x27;</span>));
</code></pre>
<p>结果</p>
<pre><code class="hljs language-console">Hello
Eello LanQiaoBei
H++++ L++Q+++B++
H*llo LanQiaoB*i
H+llo LanQiaoBei
true
6
14
</code></pre>
<h6 id="截取字串-api">截取字串 API</h6>
<p><code>public String substring(int beginIndex,int endIndex)</code></p>
<p>参数：</p>
<ul>
<li>beginIndex - 起始索引（包括）。</li>
<li>endIndex - 结束索引（不包括）。</li>
</ul>
<p>剩下的的 API 很简单, 需要注意: 1.是 replaceAll 的第一个参数传的是一个正则表达式; 2.有的是替换所有,有的是只替换第一次匹配到的;
3.indexOf 和 lastIndexOf 的 API 还有许多重写方法;</p>
<h5 id="32-string-及其他基本类型之间的互转">3.2 String 及其他基本类型之间的互转</h5>
<pre><code class="hljs language-java">        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.parseInt(b);
        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(i);
</code></pre>
<p>其他类型转换同理, 关键是使用基本数据类型的包装类提供的静态方法和 String 提供的静态方法;</p>
<h5 id="33-分割简单的单词提取大小写字母转换">3.3 分割/简单的单词提取/大小写字母转换</h5>
<pre><code class="hljs language-java">        <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello my name is LanQiaoBei!&quot;</span>;
        String[] splitText = text.split(<span class="hljs-string">&quot; &quot;</span>);
        System.out.println(Arrays.toString(splitText));
        <span class="hljs-keyword">for</span> (String word : splitText) {
            System.out.println(word.toLowerCase());
        }
</code></pre>
<p>结果:</p>
<pre><code class="hljs language-console">[Hello, my, name, is, LanQiaoBei!]
hello
my
name
is
lanqiaobei!
</code></pre>
<h6 id="分割-api">分割 API</h6>
<p><code>public String[] split(String regex)</code></p>
<p>参数：</p>
<ul>
<li>regex - 定界正则表达式</li>
</ul>
<p>上面的单词分割, 以一个空格为正则表达式去匹配分割,分割出的部分按照顺序放置在数组中;</p>
<hr>
<h4 id="4-stringbuffer-和-stringbuilder">4. StringBuffer 和 StringBuilder</h4>
<h5 id="41-介绍">4.1 介绍</h5>
<p>这两个类主要是在处理字符和字符串的时候给一个缓冲区, 针对这个缓冲区我们可以在对整个源串进行很顺利的插入删除替换, 两个类的用法一直, 只是线程安全上的区别, 在算法比赛中可以随意选;</p>
<pre><code class="hljs language-java">        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;&quot;</span>);
        sb.append(<span class="hljs-string">&quot;Hello&quot;</span>).append(<span class="hljs-string">&quot;my&quot;</span>).append(<span class="hljs-string">&quot;name&quot;</span>).append(<span class="hljs-string">&quot;is&quot;</span>).append(<span class="hljs-string">&quot;youyinnn&quot;</span>);
        System.out.println(sb);
        sb.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot; &quot;</span>)
                .insert(<span class="hljs-number">8</span>, <span class="hljs-string">&quot; &quot;</span>)
                .insert(<span class="hljs-number">13</span>,<span class="hljs-string">&quot; &quot;</span>)
                .insert(<span class="hljs-number">16</span>, <span class="hljs-string">&quot; &quot;</span>)
                .insert(sb.length() , <span class="hljs-string">&quot;!&quot;</span>);
        System.out.println(sb);
        System.out.println(sb.delete(sb.length() - <span class="hljs-number">1</span>, sb.length()));
        System.out.println(sb.reverse());
</code></pre>
<p>特别要注意,这两个类的对象方法是设计成链式调用的, 比如上面的 append 可以链式调用;
主要的方法也就 insert/append/delete, 其他方法都和 String 差不多;</p>
<hr>
<h4 id="5-math-和-random">5. Math 和 Random</h4>
<h5 id="51-math-的基本使用">5.1 Math 的基本使用</h5>
<pre><code class="hljs language-java">        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">abs</span> <span class="hljs-operator">=</span> Math.abs(a);
        System.out.println(abs);
        <span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
        <span class="hljs-type">double</span> <span class="hljs-variable">pow</span> <span class="hljs-operator">=</span> Math.pow(c, b);
        System.out.println(pow);
        System.out.println(Math.random());
</code></pre>
<p>知道绝对值/次方/获取 0-1.0 之间的随机数即可;</p>
<h5 id="52-random-类">5.2 Random 类</h5>
<p>看一下 API 即可, 各种 next 方法都跟简单;</p>
<h4 id="6-biginteger-和-bigdecimal">6. BigInteger 和 BigDecimal</h4>
<h5 id="61-了解-java-基本数据类型的精度表示范围">6.1 了解 Java 基本数据类型的精度表示范围</h5>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">位数</th>
<th align="center">最大值</th>
<th align="center">最小值</th>
<th align="center">默认值</th>
<th align="center">补充说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">8 位</td>
<td align="center">127(2^7-1)</td>
<td align="center">-128(-2^7)</td>
<td align="center">0</td>
<td align="center">有符号/二进制补码表示</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16 位</td>
<td align="center">32767(2^15-1)</td>
<td align="center">-32768(-2^15)</td>
<td align="center">0</td>
<td align="center">有符号/二进制补码表示</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32 位</td>
<td align="center">2,147,483,647（2^31 - 1）</td>
<td align="center">-2,147,483,648（-2^31）</td>
<td align="center">0</td>
<td align="center">有符号/二进制补码表示</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">64 位</td>
<td align="center">9,223,372,036,854,775,807（2^63 -1）</td>
<td align="center">-9,223,372,036,854,775,808（-2^63）</td>
<td align="center">0L</td>
<td align="center">有符号/二进制补码表示</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32 位</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0.0f</td>
<td align="center">单精度、32 位、符合 IEEE 754 标准的浮点数</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64 位</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0.0d</td>
<td align="center">双精度、64 位、符合 IEEE 754 标准的浮点数</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1 位</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">false</td>
<td align="center">只有两个取值 true/fasle</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">16 位</td>
<td align="center">\uffff</td>
<td align="center">\u0000</td>
<td align="center">-</td>
<td align="center">16 位 Unicode 字符</td>
</tr>
</tbody></table>
<p>可以看到, 基本数据类型要表示的数的范围还有限, 整数太短, 浮点数无法实现精度控制,因此需要大整数和大浮点数来充足表示大数据和精确的大浮点数;</p>
<h5 id="61-biginteger-大整数">6.1 BigInteger 大整数</h5>
<pre><code class="hljs language-java">        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;1000000000000000000000000000&quot;</span> +
                <span class="hljs-string">&quot;000000000000000000000000000000000000000&quot;</span> +
                <span class="hljs-string">&quot;000000000000000000000000000000000000000&quot;</span> +
                <span class="hljs-string">&quot;000000000000000000000000000000000000000&quot;</span> +
                <span class="hljs-string">&quot;000000000000000000000000000000000000000&quot;</span> +
                <span class="hljs-string">&quot;000000000000000000000000000000000000000&quot;</span> +
                <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>);
        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> i.add(BigInteger.ONE);
        System.out.println(add);
</code></pre>
<p>注意: 1.大数类的构造就传一个纯数字字符串就好了; 2.因为大数类不是基本数据类型, 所以不能用符号去进行算数运算, 所以大数类的方法提供了加减乘除绝对值模运算和各种逻辑运算,; 3.大整数还有四个静态常量可以引用, 0 和 10 和正负 1;</p>
<h5 id="62-bigdecimal-大浮点数">6.2 BigDecimal 大浮点数</h5>
<p>同理大整数, 略;</p>
<h4 id="7-集合框架">7. 集合框架</h4>
<h5 id="70-概念规定">7.0 概念规定</h5>
<ul>
<li>有序: 放入元素的顺序和元素在容器里存放的顺序一致, 如连续 add 3,1,2, 其底层三个元素的存放顺序也是 3,1,2;</li>
<li>无序: 放入元素的顺序和元素在容器里存放的顺序不一致, 即元素在容器中的放置顺序是和容器规定的排序规则所决定的, 如连续 add 3,1,2, 若是存放在 TreeSet 中, 则存放顺序会根据元素的&quot;自然属性&quot;排序, 可以是 1,2,3; 默认是升序, 你也可以在构造 TreeSet 的时候给一个降序的比较器, 则存放顺序可以是 3,2,1;</li>
</ul>
<h5 id="71-arraylist">7.1 ArrayList</h5>
<p>其实 List 还有其他的实现比如 LinkedList 链表, 但是用的多的就 ArrayList, 底层对应数据结构里面的顺序表, 是用数组实现的表;</p>
<pre><code class="hljs language-java">        ArrayList&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; ++i) {
            integers.add(i);
        }
        <span class="hljs-keyword">for</span> (Integer integer : integers) {
            System.out.print(integer + <span class="hljs-string">&quot; &quot;</span>);
        }
        System.out.println();
        System.out.println(integers.contains(<span class="hljs-number">5</span>));
        System.out.println(integers.size());
        System.out.println(integers.indexOf(<span class="hljs-number">6</span>));
        integers.remove(<span class="hljs-number">0</span>);
        System.out.println(integers);
        System.out.println(integers.get(<span class="hljs-number">8</span>));
</code></pre>
<p>结果:</p>
<pre><code class="hljs language-console">0 1 2 3 4 5 6 7 8 9
true
10
6
[1, 2, 3, 4, 5, 6, 7, 8, 9]
9
</code></pre>
<p>具体的自己看 API, <strong>主要用到的特性就是这个容器我可以根据下表去访问元素, 或者操作某个下标的元素</strong>;</p>
<h5 id="72-hashsettreeset比较器">7.2 HashSet/TreeSet/比较器</h5>
<p><strong>Set 主要就是用到其自动排序, 和集合元素唯一性的特性</strong></p>
<p>HashSet:HashSet 的放置顺序是按照哈希表来放置的;</p>
<pre><code class="hljs language-java">        HashSet&lt;Double&gt; doubles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        doubles.add(<span class="hljs-number">5.68</span>);
        doubles.add(<span class="hljs-number">3.25</span>);
        doubles.add(<span class="hljs-number">7.41</span>);
        doubles.add(<span class="hljs-number">5.68</span>);
        System.out.println(doubles);
</code></pre>
<p>结果:</p>
<pre><code class="hljs language-console">[7.41, 5.68, 3.25]
</code></pre>
<p>这里就很自然而然地去重了, 5.68 只添加好了一次, 而且遍历出来的容器元素是无序的;</p>
<p>TreeSet:TreeSet 的放置顺序是按照元素的&quot;自然顺序&quot;放置的, 只有数类型的基本数据类型才有&quot;自然顺序&quot;, 即默认按照数的升序排序;</p>
<pre><code class="hljs language-java">        TreeSet&lt;Integer&gt; t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();
        t1.add(<span class="hljs-number">8</span>);
        t1.add(<span class="hljs-number">4</span>);
        t1.add(<span class="hljs-number">9</span>);
        t1.add(<span class="hljs-number">0</span>);
        System.out.println(t1);
</code></pre>
<p>结果:</p>
<pre><code class="hljs language-console">[0, 4, 8, 9]
</code></pre>
<p>若我们想自定义排序规则, 则需要实现比较器, 比较器的实现有两种:</p>
<ul>
<li>一种是内部实现, 需要实现 Comparable 接口, 即你要将比较方法写在你要排序的类中, 这种方法需要修改该类的源代码;</li>
<li>一种是外部实现, 需要实现 Comparator 接口, 即单独写一个类, 这个类专门用来写比较方法, 不需要改比较类的源代码;</li>
</ul>
<p>例如我们上述的 TreeSet 是按照数的升序排列, 我下面实现一个降序比较器:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> {
        <span class="hljs-keyword">if</span> (o1 &gt; o2) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1 &lt; o2) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
}
</code></pre>
<p>然后我们在构造 TreeSet 的时候传入该比较器对象:</p>
<pre><code class="hljs language-java">        TreeSet&lt;Integer&gt; t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntComparator</span>());
        t1.add(<span class="hljs-number">8</span>);
        t1.add(<span class="hljs-number">4</span>);
        t1.add(<span class="hljs-number">9</span>);
        t1.add(<span class="hljs-number">0</span>);
        System.out.println(t1);
</code></pre>
<p>结果:</p>
<pre><code class="hljs language-console">[9, 8, 4, 0]
</code></pre>
<p>对于 Set, 我们可操作的方法就很少, 一般在经过了排序和去重的场景之后, 如果我们还要对某个元素进行操作的话, 可以把该 Set 对象传到 ArrayList 的构造方法里, 用 ArrayList 结构去处理元素;</p>
<pre><code class="hljs language-java">    ArrayList&lt;Double&gt; doubles1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(doubles);
</code></pre>
<h5 id="73-hashmap">7.3 HashMap</h5>
<p>Map 就用的比较少了;</p>
<pre><code class="hljs language-java">        HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-number">19</span>, <span class="hljs-string">&quot;a&quot;</span>);
        map.put(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;b&quot;</span>);
        map.put(<span class="hljs-number">19</span>, <span class="hljs-string">&quot;c&quot;</span>);
        map.put(<span class="hljs-number">8</span>, <span class="hljs-string">&quot;e&quot;</span>);
        <span class="hljs-keyword">for</span> (Integer key : map.keySet()) {
            System.out.println(key + <span class="hljs-string">&quot; : &quot;</span> + map.get(key));
        }
        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
            System.out.println(entry.getKey() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());
        }
</code></pre>
<p>结果:</p>
<pre><code class="hljs language-console">19 : c
8 : e
9 : b
19 : c
8 : e
9 : b
</code></pre>
<p>先说 map, map 其实存储的是 key-value 组成的键值对其中:</p>
<ul>
<li>key 在 map 中是用 Set 存储的, 所以不能存在多个 key, 如上面我放了两个 key19, 但是 map 中存了后面的那个 value:c</li>
<li>map 有多种遍历方法, 我上面举例了两个, 一个是根据 key 的集合去遍历 key 对应的 value, 另一种是使用 Map 对象中的内部类, 每一个 Map 对象都有一个 Map.Entry 对象, 这个对象可以理解将为 key 和 value 绑在一起的那根链子, 我牵起这根链子我就可以拿到链子两头的东西;</li>
</ul>
<h5 id="74-搭配-collections">7.4 搭配 Collections</h5>
<p>自己看 API, 主要操作的就是 List, 二分查找, 自定义排序, 逆转, 替换, 复制等操作;</p>
<h5 id="75-数组和集合框架之间的转换">7.5 数组和集合框架之间的转换</h5>
<pre><code class="hljs language-java">        Integer[] a = {<span class="hljs-number">1</span> , <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
        <span class="hljs-comment">// 数组转ArrayList</span>
        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(a));
        <span class="hljs-comment">// ArrayList转数组</span>
        Integer[] objects = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[list.size()]);
</code></pre>
<h5 id="76-stack-和-vector">7.6 Stack 和 Vector</h5>
<p>这两个是比较老的容器类, 完全可以使用 ArrayList 替代;</p>
<h4 id="8-输入输出挂">8. 输入输出挂</h4>
<p>一般很少会用这个, 所谓输出输出挂就是, 一般的<code>System.out</code>这个输出流, 以及<code>Scanner in = new Scanner(System.in)</code>这种输入方式, 并不是最快的输入输出方式, 如果我们写的程序比较差, 运行时间长的话, 我们就需要使用更快输入输出去减少这两方面所耗费的时间, 我们把最快的输入输出方式称之为输入输出挂;</p>
<p>输入挂:</p>
<pre><code class="hljs language-java">        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span> (System.in);<span class="hljs-comment">//基本方法</span>
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(System.in));<span class="hljs-comment">//更快</span>
</code></pre>
<p>输出挂:</p>
<pre><code class="hljs language-java">        System.out.println(n); <span class="hljs-comment">//基本的输出方法</span>
        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(System.out));<span class="hljs-comment">//使用缓存加速，比直接使用System.out快</span>
        out.println(n);
</code></pre>
<h4 id="9-快速进制转换">9. 快速进制转换</h4>
<pre><code class="hljs language-java">        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;
        <span class="hljs-comment">//a是10进制数 把a转换为3进制数的String类型</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.toString(a,<span class="hljs-number">3</span>);
        System.out.println(b);
        <span class="hljs-comment">//把String类型的b当作3进制数转换为10进制数</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Integer.parseInt(b,<span class="hljs-number">3</span>);
        System.out.println(c);
        <span class="hljs-comment">//快速转换10进制为2进制字符串</span>
        System.out.println(Integer.toBinaryString(a));
        <span class="hljs-comment">//快速转换10进制到16进制字符串</span>
        System.out.println(Integer.toHexString(<span class="hljs-number">127</span>));
        <span class="hljs-comment">//快速转换10进制到8进制字符串</span>
        System.out.println(Integer.toOctalString(<span class="hljs-number">9</span>));
</code></pre>
<p>结果:</p>
<pre><code class="hljs language-console">20
6
110
7f
11
</code></pre>
<h4 id="10-小数点精度处理">10. 小数点精度处理</h4>
<p>小精度小数点</p>
<pre><code class="hljs language-java">        <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.258</span>;
        <span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, a);
        System.out.println(format);
</code></pre>
<p>结果:</p>
<pre><code class="hljs language-console">1.26
</code></pre>
<p>使用大浮点数 API 处理:</p>
<pre><code class="hljs language-java">        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span>
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(
                        <span class="hljs-string">&quot;100000000000000000000000&quot;</span> +
                                <span class="hljs-string">&quot;000000000000000000000&quot;</span> +
                                <span class="hljs-string">&quot;000000000000000000000&quot;</span> +
                                <span class="hljs-string">&quot;000000000000000000000&quot;</span> +
                                <span class="hljs-string">&quot;00000000000000000000.&quot;</span> +
                                <span class="hljs-string">&quot;66666666666666666666&quot;</span>);

        <span class="hljs-comment">//四舍五入</span>
        System.out.println(b.setScale(<span class="hljs-number">5</span>, BigDecimal.ROUND_UP));
        <span class="hljs-comment">//截断</span>
        System.out.println(b.setScale(<span class="hljs-number">5</span>, BigDecimal.ROUND_DOWN));
</code></pre>
