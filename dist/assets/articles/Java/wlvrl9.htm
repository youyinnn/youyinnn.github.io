<h3 id="introduction">Introduction</h3>
<p>之前在搜 OOM 的时候，无意中发现了<a href="https://plumbr.io/">https://plumbr.io/</a>这个网站，它们的产品就是做内存监控工具之类的，于是官网上也有很多关于 JVM 的 GC 方面的技术博客，简直和挖到宝藏了一样- -</p>
<p>本篇主要是针对对象在堆上的分代和 GC 事件再做一些细致的了解，主要也是参考网站里的内容</p>
<h3 id="object-generation">Object Generation</h3>
<p>从我们熟悉的开始，堆内存大致可以分为三个区域，Young——新生代、Turned——老年代、PermGen——永久代</p>
<p>其中新生代里又默认以 8：1：1 分为 Eden：Survivor：Survivor</p>
<p><img src="../../img/20190318213039.png" alt=""></p>
<h4 id="eden">Eden</h4>
<p>在以前一篇<a href="./18669ga.html">关于 JVM 的对象创建与访问</a>里提到过的 TLAB（Thead Local Allocatipn Buffer），它主要用于解决对象分配的时候需要先划定一些内存空间，一个内存空间仅允许一个线程进行操作，这样就可以避免用同步的<strong>高耗时</strong>代价去保证对象分配的正常进行</p>
<p>于是 Eden 空间进一步划分一个或者多个 TLAB 区域，并且保留一块公共区域，当 TLAB 空间不够分配对象的时候，会选择到公共区域继续分配，如果这里也没有空间了的话，那就会出发一次年轻代的 GC，也就是<strong>Minor GC</strong></p>
<p>这里有个 GC 的细节，也是之前没提到过的，我们说 GC 的基本操作是，扫描引用链，然后清除掉和根引用无关的对象，但是我们需要知道，对象之间的引用是可以跨代的，比如新生代对象可以挂在老年代对象上，所以一次直白的<strong>Reachability Analysis</strong>，可能会跨代进行</p>
<p><img src="../../img/20190318214251.png" alt=""></p>
<p>但是这样做的话，<strong>分代 GC</strong>就没有意义了，于是 JVM 在这里使用了一个小伎俩：_card-marking_，详细可以参考<a href="http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html">The JVM Write Barrier - Card Marking</a>，JVM 用这个算法粗略地将 Eden 区的有可能有跨代引用的对象进行标记，然后把它们移到 Survivor 区，然后剩下的对象就容易清理掉了——是不是很眼熟？这就是<strong>标记-复制</strong>算法</p>
<h4 id="survivor">Survivor</h4>
<p>紧接着 Eden，是两个 Survivor 区，这两个区域也各自拥有姓名，**&quot;from&quot;<strong>和</strong>&quot;to&quot;<strong>，前面也提到过了，其中一个区域应该总是空的，所以实际上 Eden 区能用的最大空间是分配的</strong>90%**</p>
<p>当年轻代开始 GC 的时候，所有存活的年轻代会从 Eden 和 from 区域复制到 to 区域，有的年轻代对象也会从 from 区域直接分配到老年代，因为在这存活了 15 次，然后原先的 from 和 to 会互换身份；</p>
<p><img src="../../img/20190318223935.png" alt=""></p>
<p>再提一嘴，15 次是默认值，可以用参数调整，然后大对象会更早的进入老年代，不受 age 限制，这个在前面也说过了</p>
<h4 id="old-generation">Old Generation</h4>
<p>这部分的对象大多数长期存活的，或者是占用空间有点大的对象，而这里的 GC 算法也并不能简单地进行<strong>标记-复制</strong>，而是尽可能的用移动去减小对象之间的碎片空间</p>
<p>老年代的回收算法通常是根据不同的基础去确定的，但是原理上都是如下步骤：</p>
<ul>
<li>根据 GC Root，为对象标记可达性检测；</li>
<li>删除不可达对象；</li>
<li>压缩这些存活对象，让他们尽量靠近彼此，靠近空间的开端；</li>
</ul>
<h4 id="permgen--metaspace">PermGen &amp; Metaspace</h4>
<p>这两个就不再解释了，之前研究字符串的时候，有写过相关的：<a href="./46bhg0.html">The Revelation of Java String</a></p>
<h3 id="gc-events">GC Events</h3>
<h4 id="minor-gc">Minor GC</h4>
<p><strong>Minor GC</strong>发生在年轻代，它的概念和意图其实也就这么简单，但是还有一些细节需要我们了解一下：</p>
<ol>
<li><strong>Minor GC</strong>发生在新对象无法分配内存的时候，所以在对象创建频率高的时候，<strong>Minor GC</strong>也更频发；</li>
<li>老年代到新生代的引用会被视为<strong>GC Root</strong>，新生代到老年代的引用会被忽略掉，然后移动到 Survivor 区；</li>
<li>需要明确的是：<strong>Minor GC</strong>也会触发<strong>“大暂停”</strong>，会停止所有的线程，但是一般来说，如果绝大部分对象都被视为垃圾而不必进行复制的话，那么这个暂停延迟基本上可以忽略不记，反之需要在复制的过程中多消耗一些延迟</li>
</ol>
<h4 id="major-gc-vs-full-gc">Major GC vs Full GC</h4>
<p>虽然没有明确的文档或者规范定义出<strong>Major GC</strong>和<strong>Full GC</strong>，但我们还是可以参照<strong>Minor GC</strong>的定义方向，定义出这两种事件：</p>
<ul>
<li><strong>Major GC</strong>：清理老年代；</li>
<li><strong>Full GC</strong>：清理整个 Heap，新老年代；</li>
</ul>
<p>但我们还是不能完全将他们分开来，在很多情况下，<strong>Major GC</strong>都是由<strong>Minor GC</strong>触发的；但是另一方面，现代的 GC 算法比如<strong>G1</strong>，就是只进行了<strong>“部分清理”</strong>；</p>
<p>所以在这个问题上，我们的重心应该从<strong>“这个是 Major GC 还是 Full GC”</strong>变为<strong>“是否会触发大暂停，还是这次 GC 能和程序同步进行”</strong></p>
