<p>本篇开始了解 MySQL 中 InnoDB 引擎的索引，索引是 MySQL 里非常重要的部分，它的出现极大地提升了 MySQL 处理数据的性能，而且索引使用的好坏也决定着一个系统的执行效率</p>
<p>因此，想要高效地使用 MySQL 数据库，合理地创建索引，甚至是合理地编写 SQL 语句，都需要先了解索引在 MySQL 中的行为以及原理</p>
<p>InnoDB 的索引常见的有：B+树索引、全文索引、哈希索引</p>
<p>之前我们说过哈希索引，它是引擎自适应的，所以我们并不需要关心该索引的管理；而 B+树索引是引擎使用地最多的索引数据结构，其构造类似于二叉树，根据键值快速找到数据，但是要理解它我们要注意两个问题：</p>
<ol>
<li>B+树里的“B”不是代表二叉，而是代表平衡，以为它是从平衡二叉树演化到 B 树再演化而来；</li>
<li>B+树索引并不直接找到给定键值的具体行，只能找到数据的<strong>所在页</strong>，然后该页加载进内存，再从内存中查找数据；</li>
</ol>
<h3 id="b树与索引概述">B+树与索引概述</h3>
<p>B+树的出现，是为磁盘这类直接存去辅助设备而设计的一种平衡查找树，其目的是为了降低查找次数，因为在磁盘上一次查找就需要一次磁盘 IO，只有尽量减少 IO 时间才能提高效率，所以要一次性尽可能 IO 到合适的数据集，我们把这种能力形容为<strong>“高扇出性”</strong></p>
<p>本篇不介绍 B+树的特性、结构、操作原理，因为也挺复杂的；</p>
<p>因为高扇出性，因此在数据库中，B+树的高度一般都在 2~4 层，也就是说查找某一键值最多只需要 2 到 4 次磁盘 IO</p>
<p><img src="../../img/20200614143631.webp" alt></p>
<p style="text-align: center">一棵高度为2的B+树</p>

<h4 id="聚集索引（clustered-index）">聚集索引（Clustered Index）</h4>
<p>InnoDB 存储引擎是索组织表，即数据是按照主键的顺序存放的，而聚集索引就是按照每张表的主键构造的一棵 B+树（每张表有且仅有一个聚集索引），其叶子节点存放的即为<strong>整张表的行记录数据</strong>，因此聚集索引的叶子节点也被称为数据页，因此每个数据页都由双向链表互相连通</p>
<p>聚集索引设计的优点：</p>
<ol>
<li>因为双向链表，聚集索引虽然逻辑上连续，物理上不要求一定连续；</li>
<li>对主键的<strong>排序查找</strong>和<strong>范围查找</strong>速度非常快；</li>
<li>先天支持查询的顺序排序，因为索引键就是顺序的；</li>
</ol>
<h4 id="辅助索引（secondary-index）">辅助索引（Secondary Index）</h4>
<p>对于辅助索引，叶子节点并不包含记录的全部数据，它主要包含一个<strong>书签（bookmark）</strong>，该书签用来告诉引擎在哪里可以找到和索引对应的行数据，也就是该书签就是相应的<strong>聚集索引键</strong>；辅助索引的存在并不影响聚集索引的组织，所以可以有多个辅助索引</p>
<p>当通过辅助索引寻找数据的时候，引擎会遍历辅助索引并得到主键索引的主键，再通过主键索引来找到完整的记录，比如说高度为 3 的辅助索引，找到高度为 3 的主键索引，总边查找次数为 6，因此需要 6 次逻辑 IO 才能得到最终的数据页</p>
<h4 id="相关-sql">相关 SQL</h4>
<pre><code class="hljs language-bash">mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; show columns from mytable;
+-------+----------+------+-----+---------+----------------+
| Field | Type     | Null | Key | Default | Extra          |
+-------+----------+------+-----+---------+----------------+
| a     | int(11)  | NO   | PRI | &lt;null&gt;  | auto_increment |
| b     | char(20) | NO   |     | &lt;null&gt;  |                |
| c     | char(30) | YES  |     | &lt;null&gt;  |                |
| d     | int(11)  | NO   | PRI | &lt;null&gt;  |                |
+-------+----------+------+-----+---------+----------------+

mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; show index from mytable;
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| mytable | 0          | PRIMARY  | 1            | a           | A         | 0           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
| mytable | 0          | PRIMARY  | 2            | d           | A         | 0           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</code></pre>
<p>一般来说，在创建表的时候，指定了的主键就会有与之对应的聚集索引创建，而我们可以通过 ALTER TABLE 命令对数据表的字段进行主键约束的增删来控制聚集索引的增删，上面展示了一个拥有两个主键的表也有两个 Primary 索引；</p>
<p>我们也可以索引一个列的开头部分数据，比如对 e 的 1000 长度的数据只取前 100 范围的字段：</p>
<pre><code class="hljs language-bash">mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; alter table mytable
                           -&gt; add column e varchar(1000);

mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; show columns from mytable;
+-------+---------------+------+-----+---------+----------------+
| Field | Type          | Null | Key | Default | Extra          |
+-------+---------------+------+-----+---------+----------------+
| a     | int(11)       | NO   | PRI | &lt;null&gt;  | auto_increment |
| b     | char(20)      | NO   |     | &lt;null&gt;  |                |
| c     | char(30)      | YES  |     | &lt;null&gt;  |                |
| d     | int(11)       | NO   | PRI | &lt;null&gt;  |                |
| e     | varchar(1000) | YES  |     | &lt;null&gt;  |                |
+-------+---------------+------+-----+---------+----------------+

mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; alter table mytable
                           -&gt; add key idx_e (e(100));

mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; show columns from mytable;
+-------+---------------+------+-----+---------+----------------+
| Field | Type          | Null | Key | Default | Extra          |
+-------+---------------+------+-----+---------+----------------+
| a     | int(11)       | NO   | PRI | &lt;null&gt;  | auto_increment |
| b     | char(20)      | NO   |     | &lt;null&gt;  |                |
| c     | char(30)      | YES  |     | &lt;null&gt;  |                |
| d     | int(11)       | NO   | PRI | &lt;null&gt;  |                |
| e     | varchar(1000) | YES  | MUL | &lt;null&gt;  |                |
+-------+---------------+------+-----+---------+----------------+

mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; alter table mytable
                           -&gt; add key idx_b_c (b, c);

mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; show index from mytable;
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| mytable | 0          | PRIMARY  | 1            | a           | A         | 0           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
| mytable | 0          | PRIMARY  | 2            | d           | A         | 0           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
| mytable | 1          | idx_e    | 1            | e           | A         | 0           | 100      | &lt;null&gt; | YES  | BTREE      |         |               |
| mytable | 1          | idx_b_c  | 1            | b           | A         | 0           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
| mytable | 1          | idx_b_c  | 2            | c           | A         | 0           | &lt;null&gt;   | &lt;null&gt; | YES  | BTREE      |         |               |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</code></pre>
<p>我们还需要注意到，索引信息的各个列分别有以下含义：</p>
<ol>
<li>table，索引所在的表名；</li>
<li>Non_unique：非唯一索引；</li>
<li>Key_name：索引名称，用户可以通过这个名字来执行 Drop Index；</li>
<li>Seq_in_index：索引中该列的位置；</li>
<li>Column_name：索引列的名称，观察联合索引<code>idx_a_c</code>；</li>
<li>Collation：列以什么方式存储在索引中，可以是 A 或者 Null，B+树索引总是 A（表示是顺序的），如果是 Hash 索引这里就是 Null；</li>
<li><strong>Cardinality：这个值很重要</strong>，表示索引中唯一值的数目的估计值；</li>
<li>Sub_part：是否列的部分被索引，观察<code>idx_e</code>，这里的值是 100，表示列的左前缀 100；如果 Null，则表示索引整个列；</li>
<li>Packed：关键字是否被压缩；</li>
<li>Null：索引列是否含有空值；</li>
<li>Index_type：索引类型，B+树就都是 BTREE；</li>
<li>Comment：注释；</li>
</ol>
<h5 id="cardinality">Cardinality</h5>
<p>Cardinality 这个值很重要，优化器会根据这个值来判断是否使用这个索引，但因为不能在每次索引更新的时候就更新这个值，索引这个值并不是精准的，如果需要更新这个值，可以使用<code>analyze table</code>命令</p>
<p>在某些情况下，该值可能为 Null，可能是因为发生索引建立了但是没有用到的情况，还是使用上面的命令来更新这个值；</p>
<p>但并不是在所有查询条件中出现的列都需要上索引，一般的经验是，在访问表中很少一部分的时候，使用 B+树索引还有意义</p>
<p>比如一些<strong>低选择性</strong>的字段：性别、地区、类型等等，有时候根据这些字段范围进行查询可能会得到整半张表，因此这时候 B+树索引的作用是没有必要的，相反，<strong>在某个值取值范围很广</strong>的时候，属于<strong>高选择性</strong>的时候，适合建立 B+树索引</p>
<p><strong>重点</strong></p>
<p>这也是 Cardinality 这个值代表的意思，如果有<code>Cardinality / n_rows_in_table</code>一值非常接近 0，那么说明该索引对应的字段属于低选择性，建议删除；而当这个值接近 1 的时候，说明索引的效率还不错；</p>
<p>但由于不是每次更新索引都更新该值，所以该值具有延迟，而且数据量越多的数据表该值就越延迟更新</p>
<h4 id="对于-key-值">*对于 Key 值</h4>
<p>转载自：<a href="https://www.cnblogs.com/yy20141204bb/p/8421338.html">https://www.cnblogs.com/yy20141204bb/p/8421338.html</a></p>
<ol>
<li><p>如果 Key 是空的, 那么该列值的可以重复, 表示该列没有索引, 或者是一个非唯一的复合索引的非前导列；</p>
</li>
<li><p>如果 Key 是<strong>PRI</strong>, 那么该列是主键的组成部分；</p>
</li>
<li><p>如果 Key 是<strong>UNI</strong>, 那么该列是一个唯一值索引的第一列(前导列),并别不能含有空值(NULL)；</p>
</li>
<li><p>如果 Key 是<strong>MUL</strong>, 那么该列的值可以重复, 该列是一个非唯一索引的前导列(第一列)或者是一个唯一性索引的组成部分但是可以含有空值 NULL。</p>
</li>
</ol>
<p>如果对于一个列的定义，同时满足上述 4 种情况的多种，比如一个列既是<strong>PRI</strong>,又是<strong>UNI</strong>，那么&quot;desc 表名&quot;的时候，显示的 Key 值按照优先级来显示 <strong>PRI-&gt;UNI-&gt;MUL</strong>。那么此时，显示<strong>PRI</strong>。</p>
<p>一个唯一性索引列可以显示为<strong>PRI</strong>,并且该列不能含有空值，同时该表没有主键。</p>
<p>一个唯一性索引列可以显示为<strong>MUL</strong>, 如果多列构成了一个唯一性复合索引，因为虽然索引的多列组合是唯一的，比如 ID+NAME 是唯一的，但是没一个单独的列依然可以有重复的值，只要 ID+NAME 是唯一的即可。</p>
<h3 id="索引的使用概述">索引的使用概述</h3>
<h4 id="联合索引">联合索引</h4>
<p>联合索引是指对表上的多个列进行索引，我们之前有创建过联合索引的例子，它和创建单个索引没有区别，单个索引可以看出是联合索引元素为 1 的特例；</p>
<pre><code class="hljs language-bash">mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; create table mytable2 (
                           -&gt;   a int,
                           -&gt;   b int,
                           -&gt;   primary key (a),
                           -&gt;   key idx_a_b (a, b)
                           -&gt; );

mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; show columns from mytable2;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| a     | int(11) | NO   | PRI | &lt;null&gt;  |       |
| b     | int(11) | YES  |     | &lt;null&gt;  |       |
+-------+---------+------+-----+---------+-------+

mysql root@youyinnn.top:<span class="hljs-built_in">test</span>&gt; show index from mytable2;
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| mytable2 | 0          | PRIMARY  | 1            | a           | A         | 0           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
| mytable2 | 1          | idx_a_b  | 1            | a           | A         | 0           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
| mytable2 | 1          | idx_a_b  | 2            | b           | A         | 0           | &lt;null&gt;   | &lt;null&gt; | YES  | BTREE      |         |               |
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
</code></pre>
<p>联合索引的触发例子：</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span>xxx <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span>xxx;
</code></pre>
<p>这样的句子显然是可以使用<code>idx_a_b</code>的</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span>xxx;
</code></pre>
<p>也可以使用联合索引，因为 a 字段是主键，是顺序的，而下面这个语句就不会使用到联合索引，因为在没有键值 a 确定的情况下，联合索引（a，b）中单独看 b 是非顺序的：</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span>xxx;
</code></pre>
<p>对此情况，书上举例的解释为：</p>
<p><img src="../../img/20200614171318.webp" alt></p>
<p style="text-align: center">多键值的B+树</p>
对于第三条语句，但看键值中的b元素：1、2、1、4、2，显然是不连续的，所以不使用该联合索引

<p>但是对于这样的语句：</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span>xxx <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b;
</code></pre>
<p>联合索引在这里也起到了预排序的作用，因为在 a 键值确定的情况下，b 键值是有序的，所以这样的索引使用会减少<code>filesort</code>的操作</p>
<h4 id="索引覆盖">索引覆盖</h4>
<p><strong>*覆盖索引不是索引类型，而是优化器的索引选择行为！</strong></p>
<p>InnoDB 支持索引覆盖，即从辅助索引就能直接得到记录，而不需要查询聚集索引，它的好处是该辅助索引不会包含整行记录的所有信息，因此大小会比聚集索引小很多，以此减少大量 IO 时间；</p>
<p>特别是辅助索引，由于它存的是主键，很多查询都可以通过辅助联合索引来完成查询</p>
<p>比如有主键：a、b，辅助索引 c，因为辅助索引 c 的存放数据为<code>(a, b, c)</code>，所以一些对于主键的查询可以直接根据辅助索引的查询：</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> a <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> c <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;123&#x27;</span>;
</code></pre>
<p>还有就是对于一些统计语句</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> table_name;
</code></pre>
<p>引擎并不会选择聚集索引来进行统计，如果有辅助索引，则可以通过辅助索引来完成统计</p>
<p>再比如，若有联合索引<code>idx_a_b</code></p>
<p>如果统计：</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> mytable
    <span class="hljs-keyword">where</span> b <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">&lt;=</span> <span class="hljs-number">5000</span>;
</code></pre>
<p>这样的语句，虽然没有 b 的单独索引，但是因为是统计语句，所以可以<strong>“选择使用”</strong>刚才的联合索引来完成这一操作，这个<strong>“选择使用”</strong>的过程就是<strong>覆盖索引</strong></p>
<h4 id="优化器不使用索引的情况">优化器不使用索引的情况</h4>
<p>有时候优化器并不会选择辅助索引取找数据，而是直接进行全表扫描（直接查询聚集索引）来查询，这种情况多发生与范围查找、JOIN 链接操作</p>
<p>有的时候我们有<strong>某非主键字段进行范围查找整行数据（select *）</strong>的情况，对某个非主键字段进行范围查找，这时候虽然该字段可能有辅助索引，但是辅助索引并不能包含整行信息，于是查到辅助索引还要再查一次聚集索引，因为是书签，所以在磁盘上进行的是离散的而不是顺序的读操作，这时候优化器会选择直接利用聚集索引来依次查找</p>
<p>比如：</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> order_tb <span class="hljs-keyword">where</span> orderid <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span> <span class="hljs-keyword">and</span> orderid <span class="hljs-operator">&lt;</span> <span class="hljs-number">20000</span>;
</code></pre>
<p>在这样的情况下，如果用户觉得磁盘速度不是问题，可以使用<code>force index</code>来强制使用某个索引来查询</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> order_tb force index(orderID) <span class="hljs-keyword">where</span> orderid <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span> <span class="hljs-keyword">and</span> orderid <span class="hljs-operator">&lt;</span> <span class="hljs-number">20000</span>;
</code></pre>
<p>当然还可以给数据库提供索引建议，可以用 SQL 语句创建<code>Index Hint</code>，但是最终选择哪个索引还是由优化器决定</p>
<h3 id="mysql-中哈希算法概述">MySQL 中哈希算法概述</h3>
<h4 id="innodb-缓冲池里的哈希">InnoDB 缓冲池里的哈希</h4>
<p>之前说过，有的索引页可能会建立为自适应哈希索引，但其实在 InnoDB 引擎中另一个地方也用到了哈希算法，那就是<strong>在缓冲池找页</strong>的时候</p>
<p>缓冲池中存储页的结构是数组加链表，利用链表来解决哈希冲突，而引擎的存储表空间都有一个 space_id，引擎根据这个 id 再加上一定的偏移算法来散列到各个槽去</p>
<h4 id="自适应哈希索引">自适应哈希索引</h4>
<p>数据库行为，DBA 不能干预；而且哈希索引只能用于等值查询，不能用于其他类型查询，比如范围查找；</p>
<h3 id="全文索引概述">全文索引概述</h3>
<p>之前有创建过部分范围索引，在 InnoDB 的之前的版本是不对长文字列进行索引创建，也就是不支持全文索引，只有 MyISAM 支持，从 InnoDB 1.2.x 开始支持全文索引</p>
<p>但是 InnoDB 的全文索引用起来还是有限制：</p>
<ol>
<li>每张表只能有一个全文检索的索引；</li>
<li>多列组成的全文所以的索引列必须使用相同的字符集和排序规则；</li>
<li>不支持没有单词定界符的语言，如中日韩文；</li>
</ol>
<p>关于全文索引其实书上还有很多内容，这里不再深入</p>
