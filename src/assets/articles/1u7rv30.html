
          <h3 id="e25a21eb">Introduction</h3><p>我们对Lock和AQS有了一定的了解了之后，可以尝试着接触一些Lock+AQS的基本实现了，本篇会了解到最基本的同步组件<code>ReentrantLock</code>和<code>ReentrantReadWriteLock</code>，前者提供了排他锁的实现，并且支持重入，后者在前者的基础上，支持锁的分级，写锁排他读锁共享。特别的，重入锁的获取还有公平和非公平之分，我们先从这部分入手。</p>

          <h4 id="a54a5ee">Fair Lock &amp; Nonfair Lock</h4><p>公平锁：锁的获取次序和请求锁的时间顺序一致，即在绝对的时间里，等待时间越久的线程越先获取到锁。</p>
<p>非公平锁：锁的获取和瞬间的竞争有关，一瞬间谁运气好就能获取到锁，而且锁的获取即同步状态的获取，刚获取到同步状态的线程，再次获取到状态的机会比较大。</p>
<p>说明：虽然非公平锁可能会造成“饥饿”情况，但是大多数情况下还是非公平锁用的多，因为公平锁在释放锁又再获取锁的时候，总是会<strong>切换线程</strong>，而非公平锁一段时间内很可能总是那一个线程不停放锁持锁，<strong>线程切换的开销小就意味着——吞吐量大</strong></p>
<p>再说多一点，公平性和非公平性是<strong>“针对未入队结点”</strong>和<strong>“已入队结点”</strong>而言，上一篇文章已经提到过，<strong>同步队列</strong>中的结点都是公平获取锁的，遵从FIFO，至于具体的体现，继续往下读，读到FairSync的<code>tryAcquire</code>和<code>hasQueuedPredecessors</code>方法就知道了</p>

          <h4 id="d3b7ceda">ReentrantLock</h4><p>重入锁可以通过构造器来决定公平机制，默认是非公平锁：</p>
<pre><code class="language-java">public ReentrantLock() {
    sync = new NonfairSync();
}
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<p>ReentrantLock中有3个简单的内部类，<code>FairSync</code>/<code>NonfairSync</code>以及<code>Sync</code>，后者是前两个的父类，</p>
<pre><code class="language-java">abstract static class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = -5179523762034025860L;
    
    abstract void lock();
    
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0) // overflow
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }

    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }

    // other method..
}
</code></pre>
<p>一个抽象的lock方法，以及一个非公平的<code>tryAcquire</code>和<code>tryRelease</code>，可以在这看到，在重入锁中：<strong>state代表占锁的线程重入次数（用层数应该更好理解）</strong></p>
<p>观察<code>nonfairTryAcquire</code>方法，当state为0的时候，代表没有线程获取到锁，但是同时可能有多个线程在竞争同步状态，所以使用CAS来设置state，设置成功的线程会设置AQS的独占线程为当前线程，此时state为1；下次再来的时候，如果是自己获取自己，那么现在的state加上aquire数量，设置为新的state，并且此时没有竞争，所以常规设置state即可；</p>
<p>即在某一绝对时刻，如果state为0，任何线程都能够和同步队列中的头结点竞争state，一旦竞争到了就获取到了锁，不用入队；</p>
<p>观察<code>tryRelease</code>方法，如果不是持锁线程掉用的话，则什么都不干，否则现在的state减去releases数量，直到为0的时候，才移除AQS的独占线程；</p>
<p>再来看看<code>Sync</code>的子类之一：<code>NonfairSync</code></p>
<pre><code class="language-java">static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
</code></pre>
<p>非常简单的实现，并且在<code>lock</code>方法中会尝试一次快速地获取同步状态，获取到就贼赚，获取不到就乖乖<code>acquire</code> 去，<code>tryAcquire</code>则是直接调用父类提供的非公平<code>nonfairTryAcquire</code>，如果获取不到，下场一样是进入同步队列尾部排队</p>
<p>最后是<code>FairSync</code></p>
<pre><code class="language-java">static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &amp;&amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
}
</code></pre>
<p>我们只需要注意到，它的<code>tryAcquire</code>方法和父类的非公平获取几乎如出一撤，仅是在CAS竞争之前，先要判断一下当前线程所在队列中的结点是否有前驱（<code>hasQueuedPredecessors</code>），如果没有就可以开始CAS获取，保证总是最早入队的结点有权获取同步状态；</p>
<p>我们再深入一下<code>hasQueuedPredcessors</code></p>
<pre><code class="language-java">public final boolean hasQueuedPredecessors() {
    // The correctness of this depends on head being initialized
    // before tail and on head.next being accurate if the current
    // thread is first in queue.
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &amp;&amp;
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
</code></pre>
<p>判断head是否等于tail：</p>
<ol>
<li><p>若等于，则条件结束，方法返回fasle</p>
<blockquote>
<p>等于的含义有2层，一是队列里没有任何结点的时候，head=tail=null，这时候方法返回false，代表进入方法的线程是整个系统第一次访问该锁的线程，则可以获取同步状态；</p>
<p>二是队列中只有一个结点，这个结点即是head又是tail；</p>
</blockquote>
</li>
<li><p>若不等于，则看head是否有后继：</p>
<ol>
<li>若没有后继，则条件结束，方法返回true，回到上层方法，<code>tryAcquire</code>返回false；</li>
<li>若有后继，如果head的后继不是当前线程的话，方法返回true，回到上层方法，<code>tryAcquire</code>返回false；</li>
<li>若有后继，且head后继是当前线程，则方法返回false，回到上层方法，当前线程可以尝试获取同步状态；</li>
</ol>
</li>
</ol>

          <h5 id="2e8d59c4">Real meaning of &quot;fair&quot;</h5><p>读完上面的方法之后，接下来这句话非常重要：为什么之前说，公平性和非公平性是<strong>“针对未入队结点”</strong>和<strong>“已入队结点”</strong>而言？因为<strong>已入队的结点之间不存在竞争</strong>，竞争仅仅是队列前几个结点和未入队的新线程而言：</p>
<ul>
<li>如果是公平锁，未入队的新线程在<code>hasQueuePredecessors</code>方法之后，肯定是false，导致<code>tryAcquire</code>方法必定返回false，导致这个新线程必定组成结点然后入队排队，<strong>即不入队的线程没有参与同步资源竞争的权利</strong>；</li>
<li>如果是非公平锁，未入队的新线程有机会和已入队的一起竞争同步资源；所以才叫非公平！</li>
</ul>
<p>所以不要误解非公平锁的情况下，后排队的结点线程也能很<strong>“不公平”</strong>地比先排队的结点线程先获得同步状态，这是不可能的；</p>

          <h4 id="e99414ec">ReentrantReadWriteLock</h4><p>在Lock接口之前，我们使用等待通知的设计机制可以简单地实现一个读写场景，当写线程开始的时候，所有后续读写线程都进入等待，写操作完成之后，通知唤醒等待中的其他线程；而当有一个读线程在读取的时候，写线程进入等待；</p>
<p>基于这样的逻辑，才能避免脏读</p>
<p>所以读写锁的基本思想是：<strong>写锁的优先度高于读锁，可以多读，只能单写；</strong></p>
<p><strong>换句话说，写锁是独占锁，读锁是共享锁</strong>，而上面说的<code>ReentrantLock</code>则是排他锁，在一般场景下，读写锁的性能会比排他锁好，因为绝大部分场景是读操作远多于写操作的；</p>
<p>使用读写锁的时候，只需要在读操作的时候获取读锁，写操作的时候获取写锁就可以了，比<code>synchronized</code>关键字加等待通知方法更加简单明了</p>
<p><code>ReentrantReadWirteLock</code>是读写锁的一种，其特性如：</p>
<ul>
<li>可重入</li>
<li>公平性选择</li>
<li>遵循获取写锁、获取读锁再释放写锁的顺序，写锁可降级称为读锁</li>
</ul>
<p>另外它还提供了外部监控内部锁状态的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>int getReadLockCount()</code></td>
<td><strong>返回当前读锁被获取到的次数</strong>，该次数不等于获取读锁的线程数，比如仅一个线程连续重入了n次，则返回n；该方法会返回<strong>所有线程持有的当前读锁的层数</strong>，比如线程A获取3次，释放1次，线程B获取5次释放2次，则该方法会返回3-1+5-2=<strong>5层</strong>；</td>
</tr>
<tr>
<td><code>int getReadHoldCount()</code></td>
<td><strong>返回当前线程获取到读锁的次数</strong>，该方法在Java6之后加入，通过<strong>ThreadLocal</strong>实现；该方法返回<strong>当前线程持有该锁的层数</strong>，比如线程A获取该锁5次释放<strong>2层</strong>，则在A锁该方法返回3，同时B线程获取该锁4次释放4次，则在B线程该方法返回<strong>0层</strong>；</td>
</tr>
<tr>
<td><code>boolean isWirteLocked()</code></td>
<td><strong>判断写锁是否被获取到；</strong></td>
</tr>
<tr>
<td><code>int getWriteHoldCount()</code></td>
<td><strong>判断当前写锁被获取的次数；</strong></td>
</tr>
</tbody></table>

          <h5 id="1e8ba163">Read Write State Design</h5><p>我们来思考一下，对于一个读写锁来说，它应当将读写分离为2把锁，但是读写锁的排队应该排在同一队，所以读写锁的AQS应该是同一个实例，所以问题来了，如何在一个AQS实例上的一个state变量中表示读与写两种同步状态？老爷子给出了这样的答案：</p>
<pre class="nhi">
    int value
    |&lt;-----------------------------32------------------------------&gt;|
    ┌---------------------------------------------------------------┐
    |0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|
    └---------------------------------------------------------------┘
                    |                                 ↓
                    |                ┌-------------------------------┐
                    ↓                |0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|
    ┌-------------------------------┐└-------------------------------┘
    |0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|               低16位表示写状态 = 3
    └-------------------------------┘
                   高16位表示读状态 = 2
</pre>

<p>通过位运算，假设当前同步状态值为S，那么写状态就等于S &amp; 0x0000FFFF（高16位清零），读状态等于S &gt;&gt;&gt; 16（无符号补位0右移16位）</p>
<p>当写状态要增加1的时候，直接S + 1，当读状态要增加1的是，直接S + 0x00010000就行</p>

          <h5 id="8b5c222f">Structure</h5><pre><code class="language-java">public class ReentrantReadWriteLock
        implements ReadWriteLock, java.io.Serializable {

    private final ReentrantReadWriteLock.ReadLock readerLock;
    private final ReentrantReadWriteLock.WriteLock writerLock;
    final Sync sync;

    public ReentrantReadWriteLock() {this(false);}
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }

    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
    
    // ...
}
</code></pre>
<p>这是重入读写锁的整体结构，可以看到ReentrantReadWriteLock仅仅只是实现了ReadWriteLock接口而已，这个接口仅定义了获取ReadLock和WriteLock的方法，真正的锁实现是<code>ReentrantReadWriteLock.ReadLock</code>和<code>ReentrantReadWriteLock.WriteLock</code>，而这两个锁实现，用的是同一个<code>Sync</code>实例，<code>Sync</code>实例即实现了AQS的公平锁或者非公平锁</p>

          <h5 id="57694f90">Fair &amp; NonFair</h5><p>我们先来看非公平锁和公平锁的实现：</p>
<pre><code class="language-java">static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -8159625535654395037L;
    final boolean writerShouldBlock() {
        return false; // writers can always barge
    }
    final boolean readerShouldBlock() {
        return apparentlyFirstQueuedIsExclusive();
    }
}

static final class FairSync extends Sync {
    private static final long serialVersionUID = -2274990926593161451L;
    final boolean writerShouldBlock() {return hasQueuedPredecessors();}
    final boolean readerShouldBlock() {return hasQueuedPredecessors();}
}
</code></pre>
<p>读写锁中的公平性主要体现在是否要阻塞读写线程这方面，对于公平锁而言，无论读写线程，都要判断<code>hasQueeudPredecessors</code>这个方法我们上面讲过了，关键是非公平锁，对于写锁是否应该block来说，它总是不应该被block住，而读锁则需要判断<code>apparentlyFirstQueuedIsExclusive</code>方法，</p>
<pre><code class="language-java">final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null &amp;&amp;
        (s = h.next)  != null &amp;&amp;
        !s.isShared()         &amp;&amp;
        s.thread != null;
}
</code></pre>
<p>如果队列中的第一个等待结点明显是是独占式锁的结点的话，就返回true，两个方法连起来的意思是，如果队列中的第一个结点是写锁（独占锁）的话，读锁应该被Block住</p>

          <h5 id="cbb26554">Sync in ReentrantReadWriteLock</h5><pre><code class="language-java">abstract static class Sync extends AbstractQueuedSynchronizer {
    static final int SHARED_SHIFT   = 16;
    static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);
    static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;
    static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;

    static int sharedCount(int c)    { return c &gt;&gt;&gt; SHARED_SHIFT; }
    static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }

    Sync() {
        readHolds = new ThreadLocalHoldCounter();
        setState(getState()); // ensures visibility of readHolds
    }

    abstract boolean readerShouldBlock();
    abstract boolean writerShouldBlock();

    // .. HolderCounter 相关方法暂时略
    
    protected final boolean tryRelease(int releases) { 
        // .. 
    }
    protected final boolean tryAcquire(int acquires) {
        // ..
    }
    protected final boolean tryReleaseShared(int unused) {
        // ..
    }
    protected final int tryAcquireShared(int unused) {
        // ..
    }
    final int fullTryAcquireShared(Thread current) {
        // ..
    }
    final boolean tryWriteLock() {
        // ..
    }
    final boolean tryReadLock() {
        // ..
    }
    
    // .. 锁状态 相关方法暂时略
    
    final int getCount() { return getState(); }
}
</code></pre>
<p>重入读写锁中的<code>Sync</code>类提供的功能比较多，它同时实现了读锁和写锁的管理操作，我们先分析这部分，略去的部分我在注释中说明了</p>
<p>读写状态的管理就是通过位运算去实现的，读写锁的层数也是通过位运算state变量算出来的，这里不再赘述；写锁的tryRelease方法和<code>ReentrantLock</code>基本一致；</p>
<p>我们接着看写锁的try：</p>
<pre><code class="language-java">protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
</code></pre>
<p>老爷子特地写下了一段WalkThrough注释，指出了本方法要处理的情况：</p>
<ol>
<li>如果读写状态都不为零，且当前线程不是该AQS的独占线程，则不能获取写锁；</li>
<li>如果状态满值了，也获取不了写锁；</li>
<li>如果不是上面2种情况，则该线程应该在公平性的指导下<code>writerShouldBlock</code>合法竞争独占锁；</li>
</ol>
<p>再来看读锁的，再看读锁之前，我们要了解一下<code>Sync</code>的几个变量和类：</p>
<pre><code class="language-java">static final class HoldCounter {
    int count = 0;
    // Use id, not reference, to avoid garbage retention
    final long tid = getThreadId(Thread.currentThread());
}

static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; {
    public HoldCounter initialValue() {return new HoldCounter();}
}

private transient ThreadLocalHoldCounter readHolds;

private transient HoldCounter cachedHoldCounter;

private transient Thread firstReader = null;
private transient int firstReaderHoldCount;
</code></pre>
<p>有一个<code>HoldCounter</code>类，用于存储每个线程自己的读层数，然后通过ThreadLocal来管理</p>
<ul>
<li><code>readHolds</code>：一个ThreadLocal实例，保存了所有读线程的HoldCounter</li>
<li><code>cachedHoldCounter</code>：表示最后一个成功acquire到readLock的线程的holdCount</li>
<li><code>firstReader</code>：是第一个acquire到读锁的线程</li>
<li><code>firstReaderHoldCount</code>：是<code>firstReader</code>的holdCount</li>
</ul>
<p>然后是读try：</p>
<pre><code class="language-java">protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    int r = sharedCount(c);
    if (!readerShouldBlock() &amp;&amp;
        r &lt; MAX_COUNT &amp;&amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
</code></pre>
<p>WalkThrough：</p>
<ol>
<li>如果写锁被其它线程获取了，则不能获取读锁；</li>
<li>否则就在公平性的指导下<code>writerShouldBlock</code>，如果允许竞争，则判断是否超量读，如果没超量，则尝试CAS设置读状态，这三个条件过了之后，line:11~line:24是快速地进行tryAcquireShared，它并没有检查重入情况下的acquire，所以它将完整地holdCount检查等工作推迟到了<code>fullTryAcquireShared</code>中去了，因为典型的情况下都是非重入地使用；</li>
<li>如果前2步都不对，那么就开始完整的<code>fullTryAcquireShared</code>，它将会处理之前的CAS失败，已经第二步没有处理好的读重入的情况；</li>
</ol>
<p>关于<code>fullTryAcquireShared</code>的更详细的逻辑，我觉得比较复杂，不太想深究，到此为止</p>
<p>最后回到<code>Sync</code>类最后2个方法：</p>
<ul>
<li><code>tryWriteLock</code>：和<code>tryAcquire</code>相比仅仅少了<code>writerShouldBlock</code></li>
<li><code>tryReadLock</code>：和<code>tryAcquire</code>相比仅仅少了<code>readerShouldBlock</code></li>
</ul>

          <h5 id="80ffda47">ReadLock &amp; WriteLock in ReentrantReadWirteLock</h5><p>大致读下了上面的<code>Sync</code>之后，剩下的<code>ReadLock </code>&amp; <code>WriteLock </code>其实就很简单了</p>
<pre><code class="language-java">public static class ReadLock implements Lock, java.io.Serializable {
    private final Sync sync;
    protected ReadLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    public void lock() {sync.acquireShared(1);}
    public boolean tryLock() {return sync.tryReadLock();}
    public void unlock() {sync.releaseShared(1);}
    
    // 其余release、中断acquire、超时、状态相关方法略
}

public static class WriteLock implements Lock, java.io.Serializable {
    private final Sync sync;
    protected WriteLock(ReentrantReadWriteLock lock) {
        sync = lock.sync;
    }
    public void lock() {sync.acquire(1);}
    public boolean tryLock() {return sync.tryWriteLock();}
    public void unlock() {sync.release(1);}
    
    // 其余release、中断acquire、超时、状态相关方法略
}
</code></pre>

          <h5 id="32367de4">Write Lock Degradation</h5><p>虽然写锁在被某一个线程持有的时候，其他线程的读锁请求和写锁请求都会被阻塞，但是同一线程的读写锁请求是不会被阻塞的；</p>
<p>而读写锁中的<strong>锁降级</strong>是指：同一个线程在持有写锁的情况下，同时获取读锁，再释放写锁；</p>
<p>这样做是<strong>保证数据可见性</strong>，因为当A线程在持有写锁的时候，这时候其他线程的读写操请求都会被阻塞，这时候A线程再获取读锁然后释放写锁，那么在A线程持有读锁的情况下，A线程最后一次修改过的数据就对其他线程可见（其他线程的读请求会被唤醒）</p>
<pre><code class="language-java">readLock.unLock();
writeLock.lock();
try{
    // update 
    data.update();
    readLock.lock();
} finally {
    writeLoce.unLock();
}
</code></pre>

          <h3 id="26845fc6">Conclusion</h3><p>上一篇文章我们在分析<code>SynchronizedQueue</code>的时候同时也分析了共享式获取和释放等方法，这些方法就是就是给读写锁来实现写锁的</p>
<p>关于重入锁和读写锁的原理方面，我觉得要注意以下几点：</p>
<ol>
<li><code>Lock</code>接口、<code>AbstractSynchronizedQueue</code>的关系；</li>
<li>CAS更改State；</li>
<li>同步队列的原理<ol>
<li>结构；</li>
<li>自旋、等待；</li>
<li>共享式锁的<em><strong>Propagation</strong></em>；</li>
</ol>
</li>
<li>锁重入的过程；</li>
<li>公平/非公平的原理；</li>
<li>读锁写锁的工作流程于应用设计；</li>
<li>写锁的降级；</li>
</ol>
<p>虽然<em>《艺术》</em>书上没有关于读写锁的更多源码讲解，但是有了之前重入锁的讲解分析经历，还是能自己把读写锁的源码分析了一遍</p>
