
          <h3 id="111f5fe1">31. Next Permutation(Medium)</h3><p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be <strong>in-place</strong> and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<pre><code>1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1
</code></pre>

          <h4 id="2944baa3">From Back(7ms)</h4><p>不难，找规律找出来就好了，首先弄清楚字典顺序是怎么回事，比如序列1 2 3 4，往后的序列是</p>
<pre><code>1 2 3 4  ┌→ 2 1 3 4  ┌→ 3 1 2 4  ┌→ 4 1 2 3
1 2 4 3  |  2 1 4 3  |  3 1 4 2  |  4 1 3 2
1 3 2 4  |  2 3 1 4  |  3 2 1 4  |  4 2 1 3
1 3 4 2  |  2 3 4 1  |  3 2 4 1  |  4 2 3 1
1 4 2 3  |  2 4 1 3  |  3 4 1 2  |  4 3 1 2
1 4 3 2 -┘  2 4 3 1 -┘  3 4 2 1 -┘  4 3 2 1
</code></pre>
<p>多看几组我们可以发现，如果我们从后往前找到<strong>顺序</strong>的一对，比如4 1 3 2中，1和3是顺序的，那么如果将1和<strong>它的下一个自然数交换位置</strong>，然后<strong>将该位置往后的序列自然排序</strong>，就可以得到下一组自然序列，比如1在当前序列中的下一个自然数是2，于是交换得到4 2 3 1，然后再对2后面的序列进行排序，如此得到4 2 1 3</p>
<p>于是代码为：</p>
<pre><code class="language-java">public void nextPermutation(int[] nums) {
    for (int i = nums.length - 1; i &gt;= 0; i--) {
        int b = nums[i];
        if (i == 0) {
            Arrays.sort(nums, i, nums.length);
            break;
        }
        int a = nums[i - 1];
        if (a &lt; b) {
            int theBiggerOneIndex = findTheBiggerOne(nums, i - 1, nums.length - 1, a);
            swap(nums, i - 1, theBiggerOneIndex);
            Arrays.sort(nums, i, nums.length);
            break;
        }
    }
}

private void swap(int[] nums, int a, int b) {
    int tmp = nums[a];
    nums[a] = nums[b];
    nums[b] = tmp;
}

private int findTheBiggerOne(int[] nums, int start, int end, int target) {
    for (int i = end; i &gt;= start; i--) {
        if (nums[i] &gt; target) {
            return i;
        }
    }
    return start;
}
</code></pre>

          <h3 id="cb3d2344">32. Longest Valid Parentheses(Hard)</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: &quot;(()&quot;
Output: 2
Explanation: The longest valid parentheses substring is &quot;()&quot;
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: &quot;)()())&quot;
Output: 4
Explanation: The longest valid parentheses substring is &quot;()()&quot;
</code></pre>
<p>这题，本来还想用找<strong>Q5最长回文数</strong>的套路去做的，不行，而且这题有更简单的方法</p>

          <h4 id="13dd55ef">DP</h4><p>想不到吧？这题居然可以dp，牛皮吧？根据官方给的solution，我优化了代码，以一种更简单的方式去用dp解这道题，我们先看几个例子：</p>
<pre><code class="language-java">1.假如我们有：
                ( ) ( )
    -------------------
                0 2 0 4
    -------------------
match:            2   2
                  +   +
before match:     ?   2
    
对于最后一个4，我们可以做这样的解释：
1）因为它和前一个字符match了，所以算2个长度；
2）因为在这2个长度之前，紧前面也有一个长度为2的合法子串，所以这两紧挨着的串长度可以加在一起；

2.为了方便处理before match，我们在每个处理串前加上一个+号，于是：
               + ( ) ( )
    --------------------
               0 0 2 0 4
    --------------------
match:             2   2
                   +   +
before match:      0   2
    
3.再看另外一个例子：
              + ( ( ) ) ( ( ) )
    ---------------------------
              0 0 0 2 4 0 0 2 8
    ---------------------------
match:              2 2     2 2
                    + +     + +
inside:             0 2     0 2
                    + +     + +
before match:       0 0     0 4
    
对于第一个4：
它前面一个符号是闭口，且这个闭口符号有效值为2，于是当前闭口要考虑的有效开口，
应该往前数2+1位，也就是下标为1的位置，如果这个位置是开口，那么证明match，
且before match的有效值为0，于是它的有效值就是2+2+0

同理8：
它前面一个符号是闭口，且这个闭口符号有效值是2，于是当前闭口要考虑的有效开口，
应该往前数2+1位，也就是下标为5的位置，如果这个位置是开口，那么证明match，
且before match的有效值为4，于是它的有效值就是2+2+4
</code></pre>
<p>于是我们可以看出规律：</p>
<ul>
<li>开口有效值都是0</li>
<li>闭口：<ul>
<li>如果前一位是开口，那么直接match到2个长度，然后再连上这对开闭口<strong>紧前的符号</strong>的有效值；</li>
<li>如果前以为是闭口，那么说明有可能是大包小的情况，所以<strong>以前一位闭口的有效值为参考</strong>，在这个有效值<strong>再前一位（这里记为far match）</strong>与当前闭口做match：<ul>
<li>如果不match，那么当前闭口有效值为0；</li>
<li>否则match值2加上前一位闭口有效值再加上<strong>far match的紧前的符号</strong>的有效值，就是当前闭口的有效值；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>于是代码：</p>
<pre><code class="language-java">public int longestValidParentheses(String s) {
    int maxMatch = 0;
    s = &quot;+&quot; + s;
    int[] dp = new int[s.length()];
    char[] chars = s.toCharArray();
    for (int i = 2; i &lt; chars.length; i++) {
        char now = chars[i];
        if (now == &#39;)&#39;) {
            char pre = chars[i - 1];
            if (pre == &#39;(&#39;) {
                dp[i] = 2 + dp[i - 2];
            } else if (chars[i - dp[i - 1] - 1] == &#39;(&#39;){
                dp[i] = 2 + dp[i - 1] + dp[i - dp[i - 1] - 2];
            }
        }
        maxMatch = Math.max(dp[i], maxMatch);
    }
    return maxMatch;
}
</code></pre>

          <h3 id="339b7937">33. Search in Rotated sorted Array (Medium)</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm&#39;s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
</code></pre>

          <h4 id="66c3e55a">Find The Rotate Pivot With Binary- O(logn)</h4><p>这题唯一的技巧就是，如何找到被轴转过的有序数组的轴，找到轴就能对轴两边进行二分法了</p>

          <h5 id="ffa69656">Find Pivot</h5><p>精髓，真的很直白的技巧，这也可以作为<strong>“找到被轴转过的有序数组的轴”</strong>的题解</p>
<pre><code class="language-java">private int findPivot(int[] nums) {
    int low = 0, high = nums.length - 1, mid;
    while (low &lt; high) {
        mid = (high + low) / 2;
        if (nums[mid] &gt; nums[high]) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}
</code></pre>

          <h5 id="fe9f50fd">With Pivot</h5><pre><code class="language-java">public int search(int[] nums, int target) {
    if (nums.length == 0) {
        return -1;
    }
    int rs;
    if (nums[0] &lt;= nums[nums.length - 1]) {
        rs = Arrays.binarySearch(nums, target);
        return rs &lt; 0 ? -1 : rs;
    }
    int pivot = findPivot(nums);

    if (nums[pivot] &lt;= target &amp;&amp; nums[nums.length - 1] &gt;= target) {
        rs = Arrays.binarySearch(nums, pivot, nums.length, target);
    } else {
        rs = Arrays.binarySearch(nums, 0, pivot, target);
    }
    return rs &lt; 0 ? -1 : rs;
}
</code></pre>

          <h3 id="29034c07">34. Find First And Last Position Of Element In Sorted Array</h3><p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p>
<p>Your algorithm&#39;s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
</code></pre>
<pre><code class="language-java">public int[] searchRange(int[] nums, int target) {
   int search = Arrays.binarySearch(nums, target);
    if (search &lt; 0) {
        return new int[]{-1, -1};
    } else {
        int first = search, tmpFirst = search;
        while (tmpFirst &gt;= 0) {
            tmpFirst = Arrays.binarySearch(nums, 0, tmpFirst, target);
            if (tmpFirst &gt;= 0) {
                first = tmpFirst;
            }
        }
        int last = search, tmpLast = search;
        while (tmpLast &gt;= 0 &amp;&amp; tmpLast &lt; nums.length) {
            tmpLast = Arrays.binarySearch(nums, tmpLast + 1, nums.length, target);
            if (tmpLast &gt;= 0) {
                last = tmpLast;
            }
        }
        return new int[]{first, last};
    }
}
</code></pre>
<p>不多说</p>

          <h3 id="b56240c">35. Search Insert Position(Easy)</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1,3,5,6], 5
Output: 2
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: [1,3,5,6], 2
Output: 1
</code></pre>
<pre><code class="language-java">public int searchInsert(int[] nums, int target) {
    int low = 0, high = nums.length - 1, mid = 0;
    while (low &lt;= high) {
        mid = (high + low) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] &gt; target) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return low;
}
</code></pre>
<p>关键：</p>
<ul>
<li>low &lt;= high</li>
<li>返回low</li>
</ul>
