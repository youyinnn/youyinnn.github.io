---
title: MySQL InnoDB引擎概述
categories:
  - db
  - mysql
  - engines
tags:
  - mysql-engins
  - innodb
series: 《MySQL技术内幕：InnoDB存储引擎》笔记
date: 2020-6-11 19:12:14
---

### 介绍

本篇主要介绍了 MySQL 系统的核心引擎之一：**_InnoDB_**，本系列所有的内容是基于姜承尧老师所著*《MySQL 技术内幕：InnoDB 存储引擎》*再加上整理的网络笔记、MySQL5.7 的[官方文档](https://dev.mysql.com/doc/refman/5.7/en/)和自己的一些理解

### InnoDB 引擎

MySQL5.5.8 以后的默认引擎，支持事务、行锁设计、外键、全文索引、非锁定读（默认读操作不会产生锁）；

使用多版本并发控制（MVCC）来支持高并发性，并实现了 4 中标准的隔离级别，能避免幻读；还提供了许多其他的特性来支持高性能高并发；

### 体系架构

![](../../img/20200611211157.png)

引擎的内存中主要包含以下工作区域：

1. 线程维护区域/线程所需内部数据结构区域
2. 数据缓存，数据修改之后并不是马上进入磁盘文件，而是先缓存在这里；
3. 重做日志（redo log）缓冲；

### 后台线程的分类

1. **Master Thread**：核心线程，主要负责将缓冲池中的数据异步地刷新到磁盘，保证数据一致性，具体表现为：**刷脏页（InnoDB 1.2.x 之后被独立为 Page Cleaner Thread）、合并插入缓冲、回收 Undo 页（InnoDB 1.1 之后被独立为 Purge Thread）**；
2. **IO Thread**：引擎使用了大量的 AIO 技术来处理写 IO 请求，以提高数据库的性能，该线程的工作是**处理这些 IO 的回调**；而在 Windows 系统中，IO 线程的数量可以调整；
3. **Purge Thread**：（InnoDB 1.1 引入）事务被提交后，其所使用的 undolog 可能不再被需要，该线程是负责**回收**这些被分配的 undo 页；该线程的线程数也支持配置；减轻 Master Thread 的负担，提高性能；
4. **Page Cleaner Thread**：（InnoDB 1.2.x 引入），主要完成**脏页的刷新**操作，减轻 Master Thread 的负担，提高性能；

### 内存/内存对象

### 缓冲池

InnoDB 是基于磁盘文件存储的引擎，并将数据按页分配和管理。而由于 CPU 和磁盘的 IO 差距，想要提高性能，肯定是要利用系统内存区弥补 IO 差距的，所以我们可以简单地将缓冲池理解为磁盘数据文件的内存映射

#### 基本逻辑和内容

**读操作**：系统启动的时候，会缓存（FIX）部分页到缓冲池里，在读页的时候，首先去缓冲池里找，如果找到了就直接读取，否则就从磁盘上读

**写操作**：首先修改缓冲池中的页，然后再以一定频率刷新到次磁盘上，而且不是一有页更新就刷，而是根据一种叫**Checkpoint**的机制来刷

缓冲池的内存大小也直接影响了数据库的性能，我们也可以再配置中调节它的大小，也能够调节缓冲池的实例个数，多缓冲池实例的好处是每个页会更散列地分配到不同实例当中，好处是减少内部资源竞争

缓冲池的内存数据对象如下：

![](../../img/20200611215932.png)

#### 缓冲算法

对于缓冲池的管理，引擎使用了基本的三种算法来完成：**LRU List、Free List、Flush List**

假设我们知道基本的 LRU 缓存算法，但再 InnoDB 中的 LRU 算法又不太一样，它提供了一个**_midpoint_**来处理使用频率更新时，节点的放置策略：在新读取到页的时候，虽然是最新访问的，但是并不是放到队列的头部，而是放在大概中间的位置，默认是列表长度的 5/8 处，这个值也是可以进行配置的

而我们把这个点之前的页称为 new 列表，表示是使用频繁的热点数据，后面的称为 old 列表

InnoDB 之所以对算法进行改进的原因是：某些 SQL 操作可以能会把相当一部分的页甚至是所有页都刷出去，如果热点数据放在头部，那么它有可能最早被刷出，而下一次需要的时候，又从磁盘读取，非常影响性能

**Free 列表是干嘛的呢？**

在数据库刚启动的时候，LRU 列表是空的，没有任何的页，因为这时候页都在 Free 列表中。当需要从缓冲池中分页的时候，首先从 Free 列表中查找是否有可用的空闲页，有就直接将该页从 Free 列表移动到 LRU 列表

**Flush 列表和脏页**

在 LRU 列表中的页被修改之后，该页被称为脏页，这时候该页的数据和磁盘上对应的映射数据不一致，于是引擎通过 Checkpoint 机制将脏页刷回磁盘，我们把脏页都放在 Flush 列表中

_注意：脏页即存在 LRU 列表中，页存在 Flush 列表中，两者逻辑上分工不同_

#### 重做日志缓冲（redo log buffer）

在一个事务的过程中，引擎会先把重做日志放到缓冲区，然后再按照频率刷新到重做日志文件。在这样的场景下，重做日志缓存一般不会占用太多内存，保证每秒的事务量在这个范围内就好，默认的 8M，也是能够配置的

> 重做日志刷新的时机：
>
> 1. Master Thread 每一秒都刷一次；
> 2. 每个事务提交的时候也会刷；
> 3. 重做日志空间剩余空间小于 1/2 的时候，也会刷；

#### 额外的内存

剩下还有一些额外内存，用于分配数据库所需的对象、数据结构等，用于记录锁信息和 LRU 以及等待的信息

### Checkpoint 机制

之前说过，缓冲池的为了弥补 CPU 速度和磁盘速度而存在的，因此页操作都是先在缓冲池中完成，这种页叫脏页（缓冲池中页的版本比磁盘上的新）

当出现脏页的时候，需要把数据刷回磁盘，但不能每出现一次脏页就刷回，这样会增加 IO 的压力，从而性能会很差；同时，如果在刷页的时候系统挂了，那么数据就难以恢复；大部分数据库系统采用了**_Write Ahead Log_**的策略，即先写重做日志，再修改页，在出意外的时候，可用日志恢复；

但是这样又会带来新的问题：

1. **缓冲池中脏页过多，重做日志的体积也会很大！**万一宕机，那数据恢复的时间会很长，因为要从整个重做日志从头开始重做；
2. **缓冲池容量不是无限大的，重做日志的体积也不能无限大！**所以必须找合适的时机强制将脏页刷到磁盘，保证缓冲池和重做日志体积不会压力过大；

所以 Checkpoint 技术的出现主要是为了解决：

1. 缩短**数据恢复**的时间；

   > 当系统挂掉的时候，数据库**不需要**重做所有的日志，checkpoint 之前的页已经刷回磁盘；只需要恢复**checkpoint 后面的页**就行；

2. **缓冲池不够用**的时候，将脏页刷到磁盘；

   > 缓冲池不够用的时候，LRU 算法会溢出最近少使用的页，如果这个页是脏页，那么需要强制执行 checkpoint，将脏页刷回磁盘

3. **重做日志不可用**的时候，刷新脏页；

   > 在重做日志不够用的时候，强制产生 checkpoint，将缓冲池的页至少刷新到当前重做日志的位置；

于是 Checkpoint 机制的行为就了然了：**将缓冲池中的脏页刷到磁盘！**而它真正要关心的无非是**每次要刷多次脏页、每次刷哪些脏页、什么时候应该要刷脏页**了。

InnoDB 的 Checkpont 分为 2 种：

1. Sharp Checkpoint：数据库即将关闭的时候将所有的脏页刷回磁盘；
2. Fuzzy Checkpoint：运行时的 Checkpoint，每次只刷新部分脏页，保证数据库可用性；

### Master Thread(before 1.1)

Master Thread 具有最高的线程优先级，其内部由多个循环组成：主循环（loop）、后台循环（backgroud loop）、暂停循环（suspend loop）。主线程会根据数据库的状态在不同下循环之间进行切换

而我们先分析 InnoDB1.1 之前，Master Thread 的工作细节，再回头看，Master 线程中的哪些工作被独立为线程

#### Loop

主循环的工作有 2 部分：

1. 每秒一次：
   - （总是）将重做日志（redo log）缓存刷到磁盘，即使事务还没提交；
   - （可能）合并插入缓冲，是否发生看 IO 的次数，次数小就可用执行合并；
   - （可能）最多刷 100 个脏页到磁盘，是否发生看脏页比例，超过某个阈值就刷；
   - （可能）如果当前用户没有活动，切换到后台循环；
2. 每 10 秒一次：
   - （可能）刷 100 个脏页；
   - （总是）合并若干个插入缓冲；
   - （总是）刷重做日志（redo log）到磁盘；
   - （总是）删除无用的 Undo 页；
   - （总是）刷 100 个脏页或者 10 个脏页到磁盘；

在 InnoDB 版本迭代之后，每秒次可以刷不只 100 页脏页，可以自己在配置中调节，其中阈值也能够进行调节

除此之外，我们把删除 Undo 页的操作称为**“full purge”**，在引擎版本升级的时候，删除多少页 Undo 页也能够配置

#### Background Loop

如果当前用户没有活动，或者数据库要关闭了，那么就会切换到这个循环，它的工作有：

1. （总是）删除无用的 Undo 页；
2. （总是）合并 20 个插入缓冲；
3. （总是）跳回主循环；
4. （可能）刷 100 页直到符合条件（在 flush loop 还在主线程的版本的时候，这会跳转到 flush loop）

如果 flush loop 也没有什么可以做的了，主线程就会切换到 suspend loop，将线程挂起，等待事件发生

#### Version

- InnoDB 1.1 开始，回收 Undo 页的工作独立为**_Purge Thread_**；
- InnoDB 1.2 开始，刷脏页的工作独立为**_Page Cleaner Thread_**;

### InnoDB 关键特性

#### 插入缓冲（Insert Buffer）

听名字可能会让人以为它是缓冲池的一部分，但其实它和数据页一样，是物理页的一个组成部分，它的作用是为了提高插入操作的性能

了解插入缓冲之前，我们先来了解一下引擎是如何根据索引插入行记录的：

- **在一般情况下**，主键是行的唯一标识符，所以插入顺序一般是按照主键递增的顺序执行，不需要磁盘随机读取，若主键支持自动增长，那么这类情况的插入效率非常快；对于这样的**按照表的主键构造的索引**，我们称为**聚集索引**；
- **但是每张表中不一定只有聚集索引**，可能还有多个**非聚集的辅助索引**，比如需要按照某个字段进行查找，而且某个字段不是唯一的，这样就会产生非聚集索引；而在插入的时候，数据页虽然还是按照主键顺序存放，但是非聚集索引的叶子节点就不是顺序的了，这时候就需要**离散地**访问非聚集索引页，导致插入性能会有所下降（**由 B+树的特性决定的非聚集索引插入的离散性**）；
- **某些情况下**，非聚集索引也可能是顺序的或者说较为顺序，在插入索引值的时候手动保证绝对顺序（比如字段存的是绝对时间）；

于是对于非聚集索引的插入或者更新操作，InnoDB 设计的**Insert Buffer**就会起到作用：

- 对于非聚集索引的插入或者更新，不是直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中：
  - 若在，则直接插入；
  - 否则，先放到一个**Insert Buffer**对象中；
- 然后再以一定频率和特定情况将**Insert Buffer**和辅助索引子节点进行**merge**操作；这时通常能够将多个插入操作合并到一个操作中（如果是针对同一张索引页的话），这就大大提高非聚集索引的插入性能；

然而插入缓冲是需要条件的，只有符合以下条件的插入操作才能触发插入缓冲：

1. 索引是辅助索引（not primary key）；
2. 索引不是唯一的（not unique）；

##### 结构

Insert Buffer 的数据结构是一棵 B+树，而且是全局共享的，负责对所有表的辅助索引进行 Insert Buffer

#### 改动缓冲（Change Buffer）

Change Buffer 可以理解为 Insert Buffer 的升级，它对更新操作都进行缓冲——INSERT、DELETE、UPDATE，分别对应 Insert Buffer、Delete Buffer、Purge Buffer；它面向的依然是非唯一的辅助索引

#### 合并插入缓冲

接下来我们了解 Insert Buffer 的合并时机：

- 辅助索引页被读取到缓冲池时；

  > 比如在执行 Select 操作的时候，先检查 Insert Buffer Bitmap，然后确认该辅助页在不在树上，在树上就把该页记录插入到辅助索引页中

- Insert Buffer Bitmap 页追踪到该辅助索引页已无可用空间的时候；

- 钟点工 Master Thread 在认真地工作；

#### 两次写（Doublewrite）

主要是保证数据页的可靠性，当数据库在写操作的中间时候发生宕机，这种情况叫做分写失败

我们之前了解过，重做日志中记录的是对该页的物理操作，但是如果这个页本身已经发生了损坏，再重做的意义就不大了，于是可用在**应用重做日志之前**，先准备一个页的副本，当写入失效的时候，先通过副本还原页，再进行重做，这就是**两次写**技术

我们先来看看 doublewrite 的架构

![](../../img/20200612112402.png)

doublewrite 由两部分组成：内存中的 doublewrite buffer，另一部分是物理磁盘上共享表空间中连续的 128 页，大小都是 2MB

在对脏页刷新的时候，不直接写到磁盘，而是先将脏页复制到内存中的 doublewrite buffer，然后通过该 buffer 分写两次，每次 1MB 顺序地写入共享表空间磁盘，然后马上调用 fsync 函数，同步磁盘

在这个过程中，因为 doublewrite 页是连续的，所以写入过程是顺序的，执行非常快；写完 doublewrite 页之后，再将 doublewrite buffer 中的页写如各个表空间文件中；

如果要恢复数据，InnoDB 可用从共享表空间中的 doublewrite 页中找到该页的副本，将其复制到表空间文件，再应用重做日志

#### 自适应哈希索引（Adaptive Hash Index）

一般情况下，索引页都是 B+树结构，虽然已经非常快了，但是随机访问还是没有哈希快，InnoDB 引擎会对表上索引页的查询进行监控，如果觉得建立哈希索引可以提示速度，则简历哈希索引，这个哈希索引是从 B+树页构造而来，所以建立的速度非常快

但是 AHI 的建立条件非常多但是这些条件不太需要用户去关心，引擎默认开启 AHI 的建立；

#### 异步 IO（Async IO）

AIO 对应的是 SIO（Sync IO），AIO 的优势是充分利用线程的优势，异步读取多个对象；其另一个优势就是可以合并多个 IO 操作，也能够提高性能；

需要注意的是，AIO 需要操作系统提供 Native 支持，Windows 和 Linus 都行，Max OS 不行；

#### 刷新邻接页（Flush Neighbor Page）

再刷脏页的时候，引擎会检测该页所在区域（extent）的所有页，如果是脏页，那么一起刷新，这样做的好处的可以合并 IO，但是对于读写速度比较快的磁盘，应用这个特性可能会带来一些问题，于是推荐在机械磁盘开启这个设置，在 SSD 等高速磁盘关闭该设置
