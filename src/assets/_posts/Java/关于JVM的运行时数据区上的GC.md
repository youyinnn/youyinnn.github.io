---
title: 关于JVM的运行时数据区上的GC
categories:
  - java
  - jvm
  - gc
comments: true
date: 2018-11-14 22:45:00
tags:
  - jvm
  - gc
  - reference-type
  - finalize
series: JVM
---

### Introduction

本篇主要介绍什么是 GC，GC 一般发生在哪里，GC 在这些地方都干些什么

顺带简单提一下四种**引用类型**以及`finalize()`方法

### About Garbage Collection

你已经是一个成熟的 JVM 了，应该自己学会智能 GC 了

> 说起 GC，很多人把这项技术当作 Java 语言的伴生产物。事实上，GC 的历史比 Java 更久远，1960 年诞生于 MIT 的 Lisp 语言是第一门真正使用内存动态分配和垃圾收集技术的语言。当 Lisp 还在胚胎时期的时候，人们就在思考 GC 需要完成的事情：
>
> - 哪些内存需要回收？
> - 什么时候回收？
> - 如何回收？
>
> 经过半个多世纪的发展，目前内存的动态分配和内存回收技术已经非常成熟了，一切看起来都进入了“自动化”时代，那我们为什么还要去了解 GC 和内存分配呢？——当需要排查各种内存溢出、内存泄漏问题的时候，当垃圾收集称为系统达到**更高并发量**的瓶颈的时候，我们就需要对这些自动化的技术实施必要的监控和调节。

我们前面知道了 JVM 的内存区域会分成：Java 堆、方法区、栈（本地方法栈、虚拟机栈）、程序计数器，我们一个一个来看

- 栈（本地方法栈、虚拟机栈）、程序计数器：

  这部分的内存是线程私有的，随线程生，随线程灭，特别是**每一个栈帧需要多少内存是在类结构确定的时候就已经定下来的了（基本）**所以这部分的内存分配和回收都具备**确定性**，我们并不能在这部分的内存做出更多的考虑了

- 堆和方法区：

  对象的内存分配、常量的内存分配、类的加载和卸载，这部分内存是运行时动态变化的，这也正是 GC 要关注的，一般我们说 GC 就是在管理这部分的内存

### Heap Area's GC

因为堆是对象分配的主要区域，所以堆的垃圾回收非常重要，这里面也有很多值得深入的地方：

- 对象回收判断；
- 基本垃圾回收思路；
- 垃圾回收算法在 JVM 中的实现——垃圾回收器；

### Method Area's GC

我们知道，方法区（永久代）里面主要存放两部分东西：类信息和运行时常量。

一般我们说垃圾回收都是在堆里去回收，在新生代中回收垃圾，这部分的回收效率非常高，而永久代的回收效率就远低于此。

因为永久代主要回收 2 样东西：**废弃常量和无用的类**

对于废弃常量的回收判定，基本和对象回收差不多，看引用就好了

而对于无用类的判定就需要谨慎对待了，要想回收一个类，该类必须满足一下 3 个条件：

1. 该类所有的实例都已经被回收
2. 加载该类的 ClassLoader 已经被回收
3. 该类对应的 Class 对象没有在任何地方被引用到，无法在代码中通过反射访问到该类的方法

就算满足了这些条件，也仅仅是可以回收而已，而具体是否回收该类......作者也没有说- -

### Reference Tips: reference type

关于 Java 中的引用，不是直接引用这么简单，无论是哪种存活判断，都和引用有关

在 JDK1.2 之前，引用只有一种定义：reference 类型中存储的是另一块空间的地址，就代表是一个引用

这样的定义存粹，但是比较狭隘，一个对象可能会有“要你的时候你得在，不要的时候就管你死活”的备胎状态，这样尴尬的情况就需要更进一步地去进行引用描述了

我们希望能考虑到：系统内存充足的时候，你可以在这玩；内存紧张的时候，您还是请回吧；这样的情况

所以在 JDK1.2 之后增强了引用的概念，分别有强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），引用强度依次减弱

1. Strong Reference：描述必须的对象。有明确的赋值语句声明的对象引用，无论如何只要没有断开引用就不会被 GC 回收
2. Soft Reference：描述有用但是非必须的对象。可以通过实现`SoftReference`接口来表示存在软引用关联的对象，**在系统将要内存溢出的时候，把这些对象标进可回收范围内进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常**
3. Weak Reference：描述非必须的对象。可以通过实现`WeakReference`接口来表示存在弱引用关联的对象，这些对象只能生存到下次 GC 之前，无论内存是否紧张
4. Phantom Reference：可以通过实现`PhantomReference`接口来表示存在虚引用关联的对象，存在虚引用的对象不会在声明周期和 GC 策略上有任何的影响，仅仅是在这个对象被 GC 的时候收到一个系统通知而已

### GC Process & Object's finalize Method

即使对象已经具备回收条件，执行了 GC 之后也不是马上就回收内存的，要宣告一个对象死亡，至少需要经历两次标记：

1. 如果对象在进行 RA 之后发现没有 Reference Chian，那么他会被**第一次标记**，并且执行一次筛选，筛选的细节：

   > **\* 对象是否有必要执行 finalize 方法：**
   >
   > 1. 当对象没有覆盖 finalize 方法的时候
   > 2. 当对象已经被 JVM 调用过一次 finalize 方法的时候
   >
   >    以上两种情况都是——**没有必要执行 finalize 方法**
   >
   > **\* 当有必要执行 finalize 方法的时候:**
   >
   > 1. 将对象放置到一个`F-Queue`队列中，并在稍后由一个由 JVM 建立、低优先级的 Finalizer 线程去处理它
   >
   > 2. 开始处理`F-Queue`，对于每个对象，仅 call 一次它们的 finalize 方法，call 的结果如何并不关心，注意是 call，这是一个 trigger，而不是执行，也就是不会等待 finalize 方法结束，GC 和 JVM 都没有义务要等待一个对象的 finalize 方法；
   >
   >    这时候对象可以在 finalize 方法中自救自己，为自己建立一个引用

2. 对对象进行**第二次标记**：如果有第一次标记且进行 RA 之后还没有引用关联的话，就 mark 第二次且进行回收

需要特别说明的是：

> finalize 方法并不是用来自救用的，也不推荐使用这个方法，它是 Java 为了迎合 C/C++程序员的产物、妥协
>
> 因为它运行代价高昂、不稳定、且无调用顺序保证
