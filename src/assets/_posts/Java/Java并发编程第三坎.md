---
title: Java并发编程第三坎
categories:
  - java
  - concurrency
  - 《艺术》与《技术》
comments: true
tags:
  - java
  - thread
  - CAS
  - 锁分类
date: 2018-7-18 14:15:22
series: 并发
---

### 前言

前两篇基本说了线程的基本概念和基本使用，这回说说 Java 并发编程第三坎，关于锁的好多基本概念的提前了解

在讲锁之前，我们还需要介绍一个很重要的原理——CAS（Compare And Swap）操作，这个操作是保证并发过程中每个操作具有**“原子性”**的利器

- **关键概念说明：**临界区、排他锁、共享式锁、Java 对象头
- **什么是 CAS 操作：**原子性、CAS

暂时只有这些概念，如果有什么提前概念我会继续补充

---

### 关键概念说明

#### 临界区

在操作系统的解释上，临界区代表的是**“不允许多个进程访问的资源叫临界资源，而访问临界资源的代码段叫临界区”**

而在这里，我们可以笼统地说：**锁包括的范围就是临界区，临界区的资源需要保证内存可见性，需要对所有线程任何时刻都保持一致性**

#### 锁的分类

##### 独占锁/共享锁

独占式锁，一旦一个线程获取到了这个锁而单独进入临界区，其他线程在拿锁线程没放锁之前只能在锁外阻塞。

而所谓共享式锁就是，可以有多个线程同时获取到锁而共同进入临界区，一般这部分线程都有着共同的特性，而没有这些特性的其他线程则在锁外阻塞，需要保证的是持有锁的这些线程对临界区的操作要同步，也就是说要么这些线程只能读，这些一般这个时候临界区就失去了临界区的意义，要么这些线程在临界区内进行的写操作之间也要保持同步，但是这没有太大的意义

举个例子，读者/写者模式中，同一篇文章允许多个读者同时读，新写者阻塞直到没有读者读（看似好像和实际遇到的读写者模式不大一样），对于读者之间来说，这就是**共享式锁**，但是同一时刻只能有一个写者写，新的写者和新的读者只能阻塞，对于写者之间来说，这就是**独占式锁**

在上面的例子中，读者线程之间共性就是只能读取临界资源，同一时刻只存在读取操作的话，不会造成内存可见性问题，所以读者线程可以共享（关于什么是**内存可见性问题**，在内存模型的部分会讲解到，这里就简单理解为**脏读问题**）

对于例子中读者可以阻塞写者的说法，有的人可能想不通，我们投入到场景中去看：

> - Github 上有一篇 issue，你可以看到，这算是**“读 a”**
> - 你可以编辑，这算是**“写 a”**
> - 但实际上的临界资源是存放在 Github 服务器上的，这里才真正运用到了**读写者模式**，我们刷一个 issue 页的时候，首先请求到服务端，服务端对临界资源进行**“读 b”**操作
> - 在无阻塞的情况下，**“读 b”**操作把读出的临界资源 issue 内容，复制了一份，响应给请求方浏览器，所以我们在浏览器上读取到的资源，并不是临界资源，而是临界资源在**“读 b”**操作中复制出来的副本而已
> - 所以**“读 a”**操作其实读的是副本内容并不存在临界资源的抢夺
> - 同理， 我们**“写 a”**也是对副本进行写操作，然后把写好的内容发送给服务端，由服务端对临界资源进行**“写 b”**操作，这时如果有其他的**“读 b”**操作，**“写 b”**会阻塞

##### 公平锁/非公平锁

公平锁就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。

默认情况下` ReentrantLock` 和`synchronized` 都是非公平锁。`ReentrantLock` 可以设置成公平锁。

##### 可重入锁

可重入锁是指，已获得锁的线程再次访问锁时可以进入该锁，Java 中绝大部分的锁场景都是可重入的，其标准实现是`ReentrantLock`，最基本的`synchronized`关键字也是

不可重入锁，即每把锁只能由一个线程获取一次，该线程想要第二次获取该锁则会阻塞，很容易造成死锁；

##### 读写锁

读写锁 `ReadWriteLock `可以优雅地实现对资源的访问控制，具体实现为 `ReentrantReadWriteLock`。读写锁提供了读锁和写锁两把锁，在读数据时使用读锁，在写数据时使用写锁。

读写锁允许有多个读操作同时进行，但只允许有一个写操作执行。如果写锁没有加锁，则读锁不会阻塞，否则需要等待写入完成。

##### 乐观锁/悲观锁

悲观锁对并发冲突持悲观态度，先取锁后访问数据，能够较大程度确保数据安全性。

而乐观锁认为数据冲突的概率比较低，可以尽可能多地访问数据，只有在最终提交数据进行持久化时才获取锁。

悲观锁总是先获取锁，会增加很多额外的开销，也增加了死锁的几率。尤其是对于读操作，不会修改数据，使用悲观锁大大增加系统的响应时间。

乐观锁最后一步才提交数据，死锁的几率比较低，但是如果有多个事务同时处理相同数据也有几率会冲突甚至导致系统异常。

传统关系型数据库常常使用悲观锁，以提高数据安全性。使用乐观锁的场景，通常用版本号来确保数据安全。

##### 自旋锁

自旋锁会让处于等待状态的线程执行空循环一段时间，执行完空循环后如果能够获取锁就立即获取锁，否则才挂起线程。

使用自旋锁，能够降低等待线程被挂起的概率。线程进入阻塞状态再次唤醒，需要在用户态和内核态之间进行切换，自旋锁避免了进入内核态，因此有比较好的性能。

自旋锁适用于竞争不激烈且线程任务执行时间短的场景。但是对于竞争激烈或者任务执行时间长的场景，不适合使用自旋锁，否则会浪费 CPU 时间片。

##### 轮询锁与定时锁

轮询锁是通过线程不断尝试获取锁来实现的，可以避免发生死锁，可以更好地处理错误场景。Java 中可以通过调用锁的` tryLock` 方法来进行轮询。tryLock 方法还提供了一种支持定时的实现，可以通过参数指定获取锁的等待时间。如果可以立即获取锁那就立即返回，否则等待一段时间后返回。

##### 分段锁

`ConcurrentHashMap`是 Java 5 中支持高并发、高吞吐量的线程安全`HashMap`实现。

我们以`ConcurrentHashMap`来说一下分段锁的含义以及设计思想，`ConcurrentHashMap`中的分段锁称为 Segment，类似于`HashMap`（JDK7 与 JDK8 中`HashMap`的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表；同时又是一个`ReentrantLock`（Segment 继承了`ReentrantLock`)。

当需要 put 元素的时候，并不是对整个 hashmap 进行加锁，而是先通过 hashcode 来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

但是，在统计 size 的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

#### Java 对象头

用于存储 Java 对象的一些控制信息，在并发的过程中，锁的记录会经常性地和对象头中的一些标志位打交道，特别是在使用 synchronized 关键字的时候，具体的位置是放在对象头的**Mark Word**内容当中

所以对于 Java 来说，synchronized 用的锁是存在**Java 对象头**里的，这部分就不细说了

#### 脏读

脏读即是读线程读取到了写线程未释放锁之前的数据（也就是数据还没有被提交），一旦写线程在提交之前的写操作发生了错误，那么该版本的数据无效且不应该被读取到，还要进行数据回滚

比如在读写场景的时候，如果只有这两个独立数据只有写锁，而没有读锁，当写锁要对数据 A 和 B 从 v1 更新到 v2 时，并且这时候写锁只写完其中一个数据时（比如只有 A 更新到 v2，B 还在 v1），读线程就进行读取，那么读线程就会读取到 A=v2，B=v1，两个数据的版本不一致，这就是脏数据。

### CAS 操作

##### 什么是 CAS

CAS 即**Compare And Swap**，比较并交换，它的思想是输入两个值，一个旧值（期望的操作前的值）和一个替换旧值的新值，在操作期间先比较旧值和新值，看是否发生了变化，如果**没有变化**才将旧值换成新值，如果发生了变化则不替换

##### 什么是原子性

原子（atomic）的本意是“不能被分割的最小粒子”，而原子操作就是“不可被中断的一个或者一系列操作”，但是在多处理器中实现原子操作是有点困难的

##### 处理器如何实现原子操作

- **处理器会自动保证：**对内存的操作是原子的，则当一个处理器处理一个字节的时候，其他处理器不能访问这个字节的内存地址
- **锁总线：**当一个处理器要操作一个共享变量的时候，会发出一个 LOCK #信号，其他处理器对该变量的操作会阻塞
- **锁缓存：**参考缓存一致性

##### Java 中的 CAS

Java SE1.5 开始，JDK 并发包就提供了一些原子操作的更新器，比如`AtomicBoolean`、`AtomicInteger`、`AtomicLong`等，这些原子包装类还提供了原子的自增自减等方法

##### CAS 的三大问题

1. **ABA 问题：**如果一个值原来是 A，变成了 B，然后又变回了 A，实际上有变化，但是 CAS 是检测不到变化的，要解决这个问题，可以在变量前面追加版本号，每次变化则版本号加 1，在我看来这可以说是双重 CAS，一个只负责给版本号加一，一个复杂监控整个变量值的变化，这样就变成了：1A-2B-3A
2. **自旋消耗：**使用 CAS 一般是搭配上**自旋（即死循环）**来使用，如果长时间自旋 CAS 成功，则会大量消耗 CPU，这个问题并不好解决
3. **只能保证一个变量的原子值：**如果要对多个变量同时保证原子操作，有两种方式，一种是将多个变量聚合成一个变量，第二个是通过锁操作

##### CAS 和 Java 中锁的关系

JVM 中实现了许多锁机制，但是除了偏向锁，其他锁的实现方式几乎都用了循环 CAS，**即当一个线程要进入同步块的时候，使用循环 CAS 的方式来获取锁，当它要退出锁的时候，使用循环 CAS 来释放锁**

---

坐骑已经找到了，皮皮猪，我们走！
