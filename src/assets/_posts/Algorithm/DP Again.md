---
title: DP Again
tags:
  - dp
date: 2019-03-22 14:14:00 +8
---

### Introduction

Êàë‰ª¨ÂÖàÂàÜÊûê Leetcode ÁöÑ 55 È¢òÔºåÊòØ‰ªé 45 È¢ò Jump Game II Ë∑≥ËøáÊù•ÁöÑÔºåÂõ†‰∏∫ËøôÈ¢òÊØî II Ë¶ÅÁÆÄÂçï‰∏ÄÁÇπÔºåÂè™ÈúÄË¶ÅÂà§Êñ≠Â∫èÂàóÊòØÂê¶ËÉΩ jump Âà∞ÁªàÁÇπÂ∞±Ë°åÔºåËÄå 45 È¢òÊòØË¶ÅÊâæÊúÄÂ∞èÁöÑ jump Ê¨°Êï∞Ôºõ

‰∏∫‰ªÄ‰πàËøôÈ¢òË¶ÅÊãøÂá∫ÁØáÂπÖÊù•ÂàÜÊûêÔºüÂõ†‰∏∫ËøôÈ¢òÂåÖÂê´‰∫ÜÂæàÂ§ö‰∏úË•øÔºö

- **Á∫ØÂõûÊ∫Ø**
- **Á∫ØÂõûÊ∫Ø`--->`ÂõûÊ∫Ø Top-down DP**
- **ÂõûÊ∫Ø Top-Down DP`--->`Ëø≠‰ª£ Bottom-up DP**
- **Ëø≠‰ª£ Bottom-up DP`--->`Á∫øÊÄßË¥™Â©™**

ÂàÜÊûêÂÆå‰πãÂêé‰Ω†‰ºöÂèëÁé∞ÔºåÂéüÊù•ÁÆóÊ≥ïÂèØ‰ª•Ëøô‰πàÁæéÂ¶ô üòÉ

### Jump Game

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

**Determine if you are able to reach the last index.**

**Example 1:**

```
Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.:
```

#### 1. Backtracking

Êó†ËÆ∫ÊòØ I ËøòÊòØ IIÔºåÊàëÊúÄÂºÄÂßãÂè™ËÉΩÊÉ≥Âà∞ÁöÑÂ∞±ÊòØÂõûÊ∫ØÊ≥ïÔºåËÄåÂõûÊ∫ØÊ≥ïÁî®‰∫éËß£Ëøô‰∏§È¢òÊòØ‰ºöÁÇ∏ÁöÑÔºåÂõ†‰∏∫Êó∂Èó¥Â§çÊùÇÂ∫¶ÂíåÈÄíÂΩíÊ†àÂ§™Â§ö‰∫ÜÔºåÂçï‰Ωú‰∏∫ DP ÁöÑÁ¨¨‰∏ÄÊ≠•ÔºåÊàë‰ª¨ËøòÊòØÂÖàÊääÂõûÊ∫ØÂÜôÂá∫Êù•

```java
public boolean canJump(int[] nums) {
    return backtracking(nums, 0);
}

private boolean backtracking(int[] nums, int now) {
    if (now == nums.length - 1) {
        return true;
    } else {
        // ‰ªéÂÖÅËÆ∏ÁöÑÊúÄÂ§ßË∑≥Êï∞ÂºÄÂßãË∑≥
        int maxStep = nums[now];
        if (now + maxStep >= nums.length) {
            maxStep = nums.length - now - 1;
        }
        for (int i = maxStep; i >= 1; i--) {
            if (backtracking(nums, now + i)) {
                return true;
            }
        }
    }
    return false;
}
```

**Complexity Analysis**

- Time complexity : **O(2^n)**. There are **2^n** (upper bound) ways of jumping from the first position to the last, where _n_ is the length of array `nums`. For a complete proof, please refer to Appendix A.
- Space complexity : **O(n)**. Recursion requires additional memory for the stack frames.

#### 2. Memorization: DP Top-down

‰πüËÆ∏‰Ω†Â∑≤ÁªèÊÑèËØÜÂà∞‰∫ÜÔºåÊàë‰ª¨‰ªÖ‰ªÖÊòØÊÉ≥Áü•ÈÅìÊØè‰∏Ä‰∏™‰ΩçÁΩÆÊòØÂê¶ËÉΩË∑≥Âà∞ÊúÄÂêé‰∏ÄÊ†ºËÄåÂ∑≤Ôºå‰ΩÜÊòØÊüê‰∏™‰ΩçÁΩÆÂèØËÉΩ‰ºöÊúâ‰ªé‰∏çÂêåÂú∞ÊñπË∑≥ËøáÊù•ÁöÑÔºåÂ¶ÇÊûúÁ¨¨‰∏ÄÊ¨°Ë∑≥ËøáÊù•ÁöÑÊó∂ÂÄôÔºåËøôÊó∂ÂÄôËÇØÂÆö‰∏çÁü•ÈÅìËøô‰∏™‰ΩçÁΩÆËÉΩ‰∏çËÉΩÂà∞ËææÔºåÁÑ∂Âêé‰ªéËøô‰∏™‰ΩçÁΩÆÁªßÁª≠ÂæÄ‰∏ãË∑≥ÁöÑÊó∂ÂÄôÂ∞±ËÉΩÂõûÊ∫ØÂá∫‰∏Ä‰∏™ÁªìÊûúÊù•ÔºåÂ¶ÇÊûúÊàë‰ª¨Â∞ÜËøô‰∏™ÁªìÊûúËÆ∞ÂΩï‰∏ãÊù•ÁöÑËØùÔºåÈÇ£‰πàÁ¨¨‰∫åÊ¨°Êúâ‰ªéÂÖ∂‰ªñÂú∞ÊñπË∑≥ËøáÊù•ÁöÑÊó∂ÂÄôÔºåÊàë‰ª¨Â∞±Áü•ÈÅìËøô‰∏™‰ΩçÁΩÆÂæÄ‰∏ãËµ∞Âà∞Â∫ïÊòØ‰∏™‰ªÄ‰πàÁªìÊûúÔºåËøôÊ†∑Â∞±‰∏çÂøÖÂÜçÁªßÁª≠ÂæÄ‰∏ãË∑≥ÁÑ∂ÂêéÁ≠âÂõûÊ∫Ø‰∫ÜÔºõ

‰∫éÊòØÊàë‰ª¨Â∞ÜÊØè‰∏™‰ΩçÁΩÆÁöÑÂõûÊ∫ØÁªìÊûúËÆ∞ÂøÜÂåñÔºöËÉΩÂà∞ÁªàÁÇπ‰ª£Ë°®**_GOOD_**„ÄÅ‰∏çËÉΩÂà∞ÁªàÁÇπ‰ª£Ë°®**_BAD_**„ÄÅÊ≤°Â∞ùËØïËøá‰ª£Ë°®**_UNKNOWN_**

ÊØîÂ¶Ç Leetcode ‰∏äÁöÑ‰æãÂ≠êÔºö

An example of a memorization table for input array `nums = [2, 4, 2, 1, 0, 2, 0]` can be seen in the diagram below. We write **G** for a _GOOD_ position and **B** for a _BAD_ one. We can see that we cannot start from indices 2, 3 or 4 and eventually reach last index (6), but we can do that from indices 0, 1, 5 and (trivially) 6.

| Index | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| ----- | --- | --- | --- | --- | --- | --- | --- |
| nums  | 2   | 4   | 2   | 1   | 0   | 2   | 0   |
| memo  | G   | G   | B   | B   | B   | G   | G   |

**Steps**

1. Initially, all elements of the `memo` table are **_UNKNOWN_**, except for the last one, which is (trivially) **_GOOD_** (it can reach itself)
2. Modify the backtracking algorithm such that the recursive step first checks if the index is known (**_GOOD_**/ **_BAD_**)
   1. If it is known then return _True_ / _False_
   2. Otherwise perform the backtracking steps as before
3. Once we determine the value of the current index, we store it in the `memo` table

```java
public class Solution {
    enum Index {
        GOOD, BAD, UNKNOWN
    }
    Index[] memo;
    public boolean canJumpFromPosition(int position, int[] nums) {
        if (memo[position] == Index.BAD) {
            return false;
        } else if (memo[position] == Index.GOOD) {
            return true;
        } else {
            int maxStep = Math.min(nums[position], nums.length - position - 1);
            for (int i = maxStep; i > 0; i--) {
                if (canJumpFromPosition(position + i, nums)) {
                    memo[position + maxStep] = Index.GOOD;
                    return true;
                }
            }
            memo[position] = Index.BAD;
            return false;
        }
    }

    public boolean canJump(int[] nums) {
        memo = new Index[nums.length];
        for (int i = 0; i < nums.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[nums.length - 1] = Index.GOOD;
        return canJumpFromPosition(0, nums);
    }
}
```

**Complexity Analysis**

- Time complexity : **O(n^2)** For every element in the array, say `i`, we are looking at the next `nums[i]` elements to its right aiming to find a _GOOD_ index. `nums[i]` can be at most _n_, where _n_ is the length of array `nums`.
- Space complexity : **O(2n) =O(n)**. First n originates from recursion. Second n comes from the usage of the memo table.

ÈÄÅÁÆóÂáèÂ∞ë‰∫ÜÂæàÂ§öÁöÑÂõûÊ∫Ø‰∫ÜÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰πü‰ªé 2 ÁöÑ n Ê¨°ÊñπÈôçÂà∞ n ÁöÑ 2 Ê¨°Êñπ‰∫ÜÔºåËøôÂõûÊèê‰∫§Âà∞ LeetcodeÔºåÊâì‰∫Ü 11.11%

#### 3. Memorization: DP Bottom-up

‰∏äÁØáÁªÉ‰π†ËøáÊå∫Â§ö DP ÁöÑÔºå‰ΩÜÊòØÈÉΩÊ≤°‰ªîÁªÜÁ†îÁ©∂Ëøá**Ëá™È°∂Âêë‰∏ã**Âíå**Ëá™Â∫ïÂêë‰∏ä**ÔºåÊ≠£Â•ΩÂÄüËøôÈ¢òÊù•ÂàÜÊûêÂàÜÊûê

Êàë‰ª¨ÁöÑÈóÆÈ¢òÔºåËã•ÊòØË¶Å‰ªé‰∏ÄÂ§¥Âà∞Âè¶‰∏ÄÂ§¥ÔºåÊØîÂ¶ÇËøô‰∏ÄÈ¢òÔºåÈúÄË¶Å‰ªéËµ∑ÁÇπË∑≥Âà∞ÁªàÁÇπÔºåÁÑ∂Âêé‰ªéÁªàÁÇπÂõûÊ∫ØÂõûÊù•Ôºà‰πüËÆ∏ÊòØË∑≥Âà∞‰∫Ü‰πãÂâçÂõûÊ∫ØÂ•Ω‰∫ÜÁöÑÁªìÊûúÔºâÔºåËøôÊ†∑ÊâçËÉΩÁü•ÈÅìÁªìÊûúÔºåÂΩ¢ÂºèÂåñÁöÑÊÉ≥Ë±°‰∏Ä‰∏ãÔºåÊàë‰ª¨‰∏ªÂä®Âú∞ÂèëÈÄÅËØ∑Ê±ÇÂà∞ÊúçÂä°Á´ØÔºåÁÑ∂ÂêéÊúçÂä°Á´ØËøîÂõûÁªìÊûúÔºåËøôÊòØ‰∏Ä‰∏™ËøáÂéª/ÂõûÊù•ÁöÑËøáÁ®ãÔºõ

Â¶ÇÊûúÊàë‰ª¨ËÉΩÁõ¥Êé•‰ªéÊúçÂä°Á´ØËøîÂõûÁªìÊûúÔºåÈÇ£‰πàÂ∞±Â∞ëËä±‰∏ÄÂçä‰ª•‰∏äÁöÑ effortÔºå‰πüÂ∞±ÊòØËØ¥ÔºåÊàë‰ª¨ÂèØ‰ª•‰ªéÁªàÁÇπÁõ¥Êé•ÂæÄÂõûËµ∞ÔºÅ

Âõ†‰∏∫Êàë‰ª¨Ëµ∑ÁÇπÈÉ®ÂàÜÁöÑÁÇπÁöÑÁªìÊûúÔºåÈÉΩÊòØ‰ªéÁªàÁÇπÈôÑËøëÁöÑÂêéÂçäÊÆµÁÇπÁöÑÁªìÊûúÈÄíÂΩíÂõûÊù•ÁöÑÔºåÊàë‰ª¨ËøôÊ†∑ÂÅöÊòØÊèêÂâç‰ªéÂêéÂçäÊÆµÁÆóÂõûÁªìÊûú

‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÈÄöËøá‰∏§‰∏™ for Âæ™ÁéØÔºåÊ∂àÈô§ÂõûÊ∫ØË∞ÉÁî®Ê†à

```java
enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    public boolean canJump(int[] nums) {
        Index[] memo = new Index[nums.length];
        for (int i = 0; i < nums.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[nums.length - 1] = Index.GOOD;

        for (int i = nums.length - 2; i >= 0; i--) {
            int maxStep = Math.min(nums[i], nums.length - i - 1);
            // ‰ªéÂΩìÂâçpositionÁöÑÁ¨¨‰∏ÄÊ≠•ÂºÄÂßã
            for (int j = i + 1; j <= i + maxStep; j++) {
                if (memo[j] == Index.GOOD) {
                    memo[i] = Index.GOOD;
                    break;
                }
            }
        }

        return memo[0] == Index.GOOD;
    }
}
```

**Complexity Analysis**

- Time complexity : **O(n^2)**. For every element in the array, say `i`, we are looking at the next `nums[i]` elements to its right aiming to find a _GOOD_ index. `nums[i]` can be at most _n_, where _n_ is the length of array `nums`.
- Space complexity : **O(n)**. This comes from the usage of the memo table.

Êàë‰ª¨Âèà‰ºòÂåñ‰∫Ü‰∏Ä‰∏ã DPÔºåËøôÊ¨°Êâì‰∫Ü 30.77%Ôºå‰ºº‰πéËøò‰∏çÈîôÔºåÂÜçÁúãÁúãËÉΩ‰∏çËÉΩÂÜçÊúâ‰ªÄ‰πà‰ºòÂåñÁöÑÂú∞Êñπ

#### 4. Refine The DP

Â¶ÇÊûúÊàë‰ª¨ÂáèË¥üÂéªÂæàÂ§öÈ¢òÁõÆ‰ª•Â§ñÁöÑÊ¶ÇÂøµÁöÑËØùÔºåÊàë‰ª¨Â∞Ü‰ºöÂæóÂà∞‰∏Ä‰∏™ÂæàÁÆÄÂçïÁöÑ Memo Ê®°ÂûãÔºöÂíåËá™Â∫ïÂêë‰∏ä‰∏ÄÊ†∑ÔºåÂè™‰∏çËøáÊàë‰ª¨‰∏çÈúÄË¶ÅËÄÉËôë‰ªÄ‰πà**_UNKNOWN_**

```java
public boolean canJump(int[] nums) {
    boolean[] can = new boolean[nums.length];
    can[nums.length - 1] = true;
    for (int i = nums.length - 2; i >= 0; i--) {
        int steps = nums[i];
        for (int j = i + 1; j < nums.length && j <= i + steps; j++) {
            if  (can[j]) {
                can[i] = true;
                break;
            }
        }
    }
    return can[0];
}
```

ËøôÊ¨°Êâì‰∫Ü 34.76%ÔºåÂà´ÁúãÂíå‰∏äÈù¢ÁöÑÊ≤°ÊèêÂçáÂ§öÂ∞ëÔºåÁõ∏ÊØî‰πã‰∏ãËøôÂ∑≤ÁªèÂáèÂ∞ë‰∫Ü 1 ÂÄç‰ª•‰∏äÁöÑËÄóÊó∂‰∫ÜÔºåÊàë‰ª¨‰ºº‰πéÂ∑≤ÁªèËææÂà∞‰∫ÜËøôÈÅìÈ¢ò DP ÁöÑÊûÅÈôê‰∫ÜÔºåÂÜçÈù† DP ÁöÑÊÄùÁª¥Â∑≤ÁªèÊó†Ê≥ïÂÜçËøõË°å‰ºòÂåñ‰∫ÜÔºåËøôÊó∂ÂÄôÊàëÂëäËØâ‰Ω†ÔºåÂ∑Æ‰∏ÄÊ≠•‰Ω†Â∞±ËÉΩÂ∞ÜËøô‰∏™ DP ËΩ¨‰∏∫Á∫øÊÄßËß£Ê≥ïÔºå‰Ω†ÂèØËÉΩ‰ºöÂ¥©Ê∫É

#### 5. Greedy

‰ªé‰∏äÈù¢ÁöÑ DP Êàë‰ª¨ÂèØ‰ª•ÂèëÁé∞ÔºåÊØèÂΩìÊàë‰ª¨ÁöÑÂà∞Ëææ‰∏Ä‰∏™Êñ∞ÁöÑ‰ΩçÁΩÆÔºàiÔºâÁöÑÊó∂ÂÄôÔºåÂÆÉÂ∞±‰ºöÂæÄÂêéÊâæÔºåÊâæÂà∞‰∏Ä‰∏™ GOOD Â∞± break ÊéâÔºå‰∫éÊòØÊàë‰ª¨Â∞±ËÆ§‰∏∫Ëøô‰∏™Êñ∞‰ΩçÁΩÆ‰πüÊòØ GOODÔºåËÄåËøô‰∏™Ë¢´ÊâæÂà∞ÁöÑ GOODÔºåÂ∞±ÊòØÂΩìÂâçÊñ∞‰ΩçÁΩÆËÉΩ reach Âà∞ÁöÑÁ¨¨‰∏Ä‰∏™ GOODÔºåÂõ†‰∏∫‰∏ÄÊó¶ reach Âà∞Ëøô‰∏™ GOODÔºåÈÇ£‰πàÂÖ∂‰ªñ case Â∞±‰∏çÊØîÂÜçËÄÉËôë‰∫ÜÔºåÊâÄ‰ª•Êàë‰ª¨Êâç breakÔºõ

| Index | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| ----- | --- | --- | --- | --- | --- | --- | --- |
| nums  | 9   | 4   | 2   | 1   | 0   | 2   | 0   |
| memo  | U   | G   | B   | B   | B   | G   | G   |

ÈÇ£‰πàÂ¶ÇÊûúËØ¥ÔºåÊàë‰ª¨ÊØèÊ¨°ÈÉΩËÆ∞ÂΩïÊúÄÂêéÁöÑ GOOD ÁöÑ‰ΩçÁΩÆÔºå‰∫éÊòØÊàë‰ª¨‰ªÖ‰ªÖÈúÄË¶ÅËÆ°ÁÆóÔºå**ÂΩìÂâç‰ΩçÁΩÆËÉΩ‰∏çËÉΩ reach Âà∞Ëøô‰∏™ GOOD**Â∞±Ë°å‰∫ÜÔºåËÄåËøô‰∏ÄÊ≠•ÁîöËá≥‰∏çÈúÄË¶ÅËø≠‰ª£ÔºåÂè™Ë¶ÅÂΩìÂâç‰ΩçÁΩÆËÉΩË∑≥ÁöÑË∑ùÁ¶ªÂ§ß‰∫éÁ≠â‰∫éËøô‰∏™ GOOD ÁöÑ‰ΩçÁΩÆÂ∞±Â•Ω‰∫ÜÔºå‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•‰ªéÂêéÂæÄÂâçÁ∫øÊÄßÂú∞ÂæóÂà∞È¢òËß£Ôºö

```java
public boolean canJump(int[] nums) {
    int lastPos = nums.length - 1;
    for (int i = nums.length - 1; i >= 0; i--) {
        if (i + nums[i] >= lastPos) {
            lastPos = i;
        }
    }
    return lastPos == 0;
}
```

### Jump Game II

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

**Example:**

```
Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

#### 1. Backtracking - O(2^n)

‰∏çÂ§ö BB

```java
public int jump(int[] nums) {
    return dfs(nums, 0, 0, Integer.MAX_VALUE);
}

private int dfs(int[] nums, int now, int jump, int minJump) {
    if (jump >= minJump) {
        return minJump;
    }
    if (now == nums.length - 1) {
        return Math.min(jump, minJump);
    } else {
        int subJump = Integer.MAX_VALUE;
        for (int i = 1; i <= nums[now] && now + i < nums.length; i++) {
            subJump = Math.min(dfs(nums, now + i, jump + 1, minJump), subJump);
        }
        return Math.min(subJump, minJump);
    }
}
```

‰∏çÁî®Â§öÊÉ≥ÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶ÁàÜÊéâ‰∫Ü

#### 2. DP Bottom-up - O (n^2)

```java
public int jump(int[] nums) {
    int[] dp = new int[nums.length];
    for (int i = nums.length - 2; i >= 0; i--) {
        // one jump to the end
        if (i + nums[i] >= nums.length) {
            dp[i] = 1;
        } else {
            // jump max step if it can reach the end
            int tmp = Integer.MAX_VALUE;
            for (int j = i + 1; j <= i + nums[i]; j++) {
                if (dp[j] != Integer.MAX_VALUE) {
                    tmp = Math.min(tmp, dp[j] + 1);
                }
            }
            dp[i] = tmp;
        }
    }
    return dp[0];
}
```

#### 3. BFS - O (n)

ÂèÇËÄÉËá™Ôºö[10-lines C++ (16ms) / Python BFS Solutions with Explanations](<https://leetcode.com/problems/jump-game-ii/discuss/18019/10-lines-C%252B%252B-(16ms)-Python-BFS-Solutions-with-Explanations>)

Â¶ÇÊûúÊàë‰ª¨‰ªÖËßÇÂØüÊ≠•Êï∞ÁöÑÂ¢ûÈïøÁöÑËØùÔºåÊàë‰ª¨ÂÖ∂ÂÆûËÉΩÂ§üÊääÊï∞ÁªÑËßÜ‰∏∫‰∏ÄÊ£µ‰ª•Ë∑≥Êï∞Êù•ÂàÜÂ±ÇÁöÑÊï∞ÁªìÊûÑÔºåËøô‰πüÊòØËøôÈÅìÈ¢òËÉΩÂ§üÁî®ÂπøÂ∫¶‰ºòÂÖàÊêúÁ¥¢Êù•ÊÄùËÄÉÁöÑÂÖ≥ÈîÆÁÇπ

ÊØîÂ¶Ç`nums = [2, 3, 1, 1, 4]`ÔºåÁ¨¨‰∏ÄÂ±ÇÊòØÊàë‰ª¨ÁöÑËµ∑ÁÇπ`2`ÔºåÂÆÉËÉΩÂ§üÂà∞ËææÁöÑ‰∏ã‰∏ÄÂ±ÇÊï∞Â≠óÊúâ`3,1`ÔºåËÄå`3,1`ÁöÑ‰∏ã‰∏ÄË∑≥ËÉΩÂ§üÂà∞ËææÁöÑÊòØ`1,4`Â¶ÇÊ≠§‰∏ÄÊù•Êàë‰ª¨‰ªÖÈúÄË¶ÅË∑≥ 2 Â±ÇÂ∞±ËÉΩÂ§üÂà∞ËææÁªàÁÇπ‰∫ÜÔºõ

ÂÜçÊØîÂ¶Ç`nums = [2, 6, 5, 2, 3, 7, 4, 9, 8, 2, 1, 1]`ÔºåÁ¨¨‰∏ÄÂ±Ç`2`ÔºåÁ¨¨‰∫åÂ±Ç`6, 5`ÔºåÁ¨¨‰∏âÂ±Ç`2,3,7,4,9`ÔºåÂõ†‰∏∫ÊúÄÂ§öËÉΩ‰ªé`i = 1, nums[1] = 6`Ë∑≥Âà∞`nums[1 + 6] = nums[7] = 9`ÔºåÁÑ∂ÂêéÁ¨¨‰∏âÂ±ÇÁöÑÁ¨¨‰∏Ä‰∏™Êï∞ÂøÖÂÆöÊòØÁ¨¨‰∫åÂ±ÇÁªìÂ∞æÁöÑ‰∏ã‰∏Ä‰∏™Êï∞Ôºå‰ª•Ê≠§Á±ªÊé®Á¨¨ÂõõÂ±Ç`2, 1, 1`

```java
public int jump(int[] nums) {
    int jump = 0;
    int start = 0, end = 0;
    // when end reach the final index
    // that means we finish the jump
    while (end < nums.length - 1) {
        // jump first
        jump++;
        // at least one position on next floor
        int tmpEnd = end + 1;
        for (int i = start; i <= end; i++) {
            // hit the final straight
            if (i + nums[i] > nums.length) {
                return jump;
            }
            tmpEnd = Math.max(tmpEnd, i + nums[i]);
        }
        // visit next floor
        start = end + 1;
        end = tmpEnd;
    }
    return jump;
}
```

### Edit Distance

Given two words _word1_ and _word2_, find the minimum number of operations required to convert _word1_ to _word2_.

You have the following 3 operations permitted on a word:

1. Insert a character
2. Delete a character
3. Replace a character

**Example 1:**

```
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
```

**Example 2:**

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

#### DP Top-down For Edit Distance

ËøôÈ¢òÔºå‰πç‰∏ÄÁúã‰∏ÄËÑ∏ÊáµÈÄºÔºåÂíãËøòÊúâ 3 ÁßçÊÉÖÂÜµÔºÅÂíãËøòÈöè‰æø‰ªÄ‰πà‰ΩçÁΩÆÈÉΩËÉΩÊúâËøô‰∏âÁßçÊÉÖÂÜµÔºÅÊÄé‰πàÁé©ÔºÅÁî®‰ªÄ‰πàÊÄùË∑ØÔºÅ

ÊÄùËÄÉÂá†ÂàÜÈíüÂêéÊó†ÊûúÔºåÊûúÊñ≠ÂéªËÆ®ËÆ∫Âå∫ÊâæÊÄùË∑ØÔºåÁÑ∂ÂêéÁúãÂà∞È´òËØÑ DP Ëß£ÔºåÈÜçÈÜêÁÅåÈ°∂- -

ÁÆÄÂçïÊù•ËØ¥ÔºåËôΩÁÑ∂ÂØπÊØîÂà∞Êúâ‰∏çÂêåÊúâ**3**ÁßçÊÉÖÂÜµÔºå‰ΩÜÊòØÊàë‰ª¨ËøòÊòØÂèØ‰ª•ÊåâÁÖßÈ°∫Â∫èÊù•Áªô‰∏§‰∏™ word ÂÅö‰∏Ä‰∏™Áü©ÈòµÔºå‰∫éÊòØÁÜüÊÇâÁöÑÊìç‰ΩúÂ∞±Êù•‰∫ÜÔºå

```java
a = ac, b = ae

     j = 0 1
         a e
i = 0 a  0 1
    1 c  1 1

Êàë‰ª¨ÁúãÂà∞ÔºåÂΩìÊàë‰ª¨Ëµ∞Âà∞i = 1Ôºåj = 1ÁöÑÊó∂ÂÄôÔºåÊàë‰ª¨Êúâ3ÁßçÈÄâÊã©Ôºö
1. Áõ¥Êé•ÊõøÊç¢Ôºå‰∫éÊòØÊìç‰ΩúÊï∞Âú®a -> aÁöÑÂü∫Á°Ä‰∏ä+1Ôºõ
2. Âà†Èô§cÔºåÊàë‰ª¨Âú®ac -> aÂÆåÊàê‰πãÂêéÁöÑÂü∫Á°Ä‰∏äÔºåÁªßÁª≠ËøõË°åa -> aeÔºõ
3. ÊèíÂÖ•eÔºåÊàë‰ª¨Âú®ac -> aecÂÆåÊàê‰πãÂêéÁöÑÂü∫Á°Ä‰∏äÔºåÁªßÁª≠ËøõË°åaec -> aeÔºõ

Ôºà‰∏äÈù¢Ëøô‰∏ÄÂ•óÊòØÂ∑®ÈöæÁêÜËß£ÁöÑÂú∞ÊñπÔºâ

‰∫éÊòØÂú®Ëøô3‰∏™ÈÄâÊã©‰∏≠ÈÄâÊúÄÂ∞èÂÄº
```

Áü©ÈòµÈÉΩÊù•‰∫ÜÔºådp Â∞±ÂÆå‰∫ã‰∫ÜÔºå‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÊÉ≥Ë±°‰∏Ä‰∏ãÁä∂ÊÄÅËΩ¨ÁßªÂÖ¨ÂºèÔºö

```java
String a,b

F(i, j) = {
	if a.charAt(i) == b.charAt(j)
		dp[i][j] = dp[i - 1][j - 1];
	else
        dp[i][j] = min of {
            dp[i - 1][j - 1],	// replace
            dp[i][j - 1],		// insert
            dp[i - 1][j]		// delete
        } + 1
}

base caseÔºö
	dp[i][0] = i;
	dp[0][j] = j;
```

‰∫éÊòØ‰ª£Á†Å‰∏∫Ôºö

```java
public int minDistance(String word1, String word2) {
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];
    for (int i = 0; i <= word1.length(); i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= word2.length(); j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= word1.length(); i++) {
        for (int j = 1; j <= word2.length(); j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                // same as before
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1
                        + Math.min(
                                // replace
                                dp[i - 1][j - 1],
                        Math.min(
                                // delete
                                dp[i - 1][j],
                                // insert
                                dp[i][j - 1]));
            }
        }
    }
    return dp[word1.length()][word2.length()];
}
```

#### DP Bottom-up + Backtracking

Êàë‰ª¨ËøòÂèØ‰ª•Áî®ÂõûÊ∫ØÁöÑÂΩ¢ÂºèÂéªËÆ°ÁÆó dpÔºå‰πüÂ∞±ÊòØËØ¥‰ª•Ëá™Â∫ïÂêë‰∏äÁöÑÊÄùË∑ØÂéªÊ±ÇËß£

```java
public int minDistance(String a, String b) {
    int[][] dp = new int[a.length() + 1][b.length() + 1];
    return dfs(a, b, a.length() - 1, b.length() - 1, dp);
}

private int dfs(String a, String b, int i, int j, int[][] dp) {
    if (i == -1) {
        return j + 1;
    }
    if (j == -1) {
        return i + 1;
    }
    if (dp[i][j] == 0) {
        if (a.charAt(i) == b.charAt(j)) {
            dp[i][j] = dfs(a, b, i - 1, j - 1, dp);
        } else {
            dp[i][j] = 1
                    + Math.min(
                    		dfs(a, b, i - 1, j - 1, dp),
                    Math.min(
                            dfs(a, b, i - 1, j, dp),
                            dfs(a, b, i, j - 1, dp)));
        }
    }
    return dp[i][j];
}
```

### New 21 Game

Alice plays the following game, loosely based on the card game "21".

Alice starts with 0 points, and draws numbers while she has less than K points. During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer. Each draw is independent and the outcomes have equal probabilities.

Alice stops drawing numbers when she gets K or more points. What is the probability that she has N or less points?

Example 1:

> Input: N = 10, K = 1, W = 10
> Output: 1.00000
> Explanation: Alice gets a single card, then stops.

Example 2:

> Input: N = 6, K = 1, W = 10
> Output: 0.60000
> Explanation: Alice gets a single card, then stops.
> In 6 out of W = 10 possibilities, she is at or below N = 6 points.

Example 3:

> Input: N = 21, K = 17, W = 10
> Output: 0.73278
> Note:
>
> 0 <= K <= N <= 10000
> 1 <= W <= 10000
> Answers will be accepted as correct if they are within 10^-5 of the correct answer.
> The judging time limit has been reduced for this question.

#### DP Top-down For 21 Game

ËøôÈ¢òÂàö‰∏äÊâãÁ°ÆÂÆûËøá‰∫éÈöæÔºåÁúã‰∫ÜÂÆòÊñπÈ¢òËß£ÂêéÊâçËÉΩÊúâÊØîËæÉÊ∏ÖÊô∞ÁöÑ‰∫ÜËß£„ÄÇ

È¶ñÂÖàÊàë‰ª¨ÈúÄË¶ÅÁêÜËß£È¢ò‰∏≠ÁöÑ 3 ‰∏™ÂÄºÔºö

- N ÂÄºÔºöËé∑ËÉúÁõÆÊ†áÂàÜÔºåÊÉ≥Ë¶ÅËé∑ËÉúÁöÑËØùÔºåÊàë‰ª¨ÁöÑÁßØÂàÜÂ∞±ÂøÖÈ°ª‰Ωé‰∫éÁ≠â‰∫é NÔºõ
- K ÂÄºÔºöÂÅúÊäΩÂàÜÔºå‰∏ÄÊó¶Êàë‰ª¨ÊúÄÂêé‰∏ÄÊâãÁâåÊäΩÂà∞ÂÜçÁ¥ØÁßØÁßØÂàÜË∂ÖËøá K ÂÄºÔºåÂ∞±ÂÅúÊ≠¢ÊäΩÁâåÔºåÂê¶ÂàôÂøÖÈ°ªÂÜçÊäΩ‰∏ÄÂº†Ôºõ
- W ÂÄºÔºöÁâåÈù¢ÊúÄÂ§ßÂàÜÂÄºÔºåÊàë‰ª¨ÊäΩÁâåËÉΩÂ§üËé∑Âèñ„Äê0~W„ÄëÂÄºÁöÑÁßØÂàÜÔºõ
- Ëµ∑ÂßãÁßØÂàÜÔºö0 ÂàÜÔºõ

ÁÑ∂ÂêéÊàë‰ª¨ÂÜçÊù•ÂàÜÊûê‰æãÂ≠êÔºö

1. K ‰∏∫ 1ÔºåÊÑèÂë≥ÁùÄÊàë‰ª¨ÊúÄÂ§öÂè™ËÉΩÊäΩ‰∏ÄÊ¨°ÁâåÔºåÊúÄÂ§öÁöÑÁßØÂàÜÂè™ËÉΩ‰∏∫ 1~10 ÂàÜÔºåÊÄªÁßØÂàÜ‰Ωé‰∫éÁ≠â‰∫é N ÂÄºÔºà10ÔºâÁöÑÊ¶ÇÁéá‰∏∫ 100%Ôºõ
2. K ‰∏∫ 1ÔºåÊÑèÂë≥ÁùÄÊàë‰ª¨ÊúÄÂ§öÂè™ËÉΩÊäΩ‰∏ÄÊ¨°ÁâåÔºåÊúÄÂ§öÁöÑÁßØÂàÜÂè™ËÉΩ‰∏∫ 1~10 ÂàÜÔºåÊÄªÁßØÂàÜ‰Ωé‰∫éÁ≠â‰∫é N ÂÄºÔºà6ÔºâÁöÑÊ¶ÇÁéá‰∏∫ 60%Ôºõ

ÂÜçÊù•ÂàÜÊûê‰æã 3ÔºåK ‰∏∫ 17 Êó∂ÔºåÊàë‰ª¨ÁúãÊúÄÂêéÂè™ËÉΩÊäΩ‰∏ÄÊâãÁâåÁöÑÊÉÖÂÜµÔºå‰πüÂ∞±ÊòØÁßØÂàÜ‰∏∫ 16 ÁöÑÊó∂ÂÄôÔºåËøôÊó∂ÂÄôÊàë‰ª¨ÊúÄÂ•Ω‰∏ÄÊâãÊäΩÂá∫ÁöÑÁßØÂàÜÊÉÖÂÜµ‰∏∫Ôºö

```graph
‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê‚îå-----‚îê
| ... ||  16 ||  17 ||  18 ||  19 ||  20 ||  21 ||  22 ||  23 ||  24 ||  25 ||  26 | <--- ÊÄªÁßØÂàÜ
‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò‚îî-----‚îò
                 1      1      1      1      1      0      0      0      0      0    <--- ÊòØÂê¶Ëé∑ËÉú
```

‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•Áü•ÈÅìÂú®ÁßØÂàÜÁ≠â‰∫é 16 ÁöÑÊó∂ÂÄôÔºåËé∑ËÉúÁöÑÊ¶ÇÁéáÔºö

Êàë‰ª¨ËÆæ*f(x)*Ôºå‰∏∫ÁßØÂàÜ‰∏∫ x ÁöÑÊó∂ÂÄôÔºåËé∑ËÉúÁöÑÊ¶ÇÁéáÔºå‰∫éÊòØÊúâ

$$
\begin{aligned}
f(16) &= \frac {1} {10} \cdotp (1 + 1+ 1+ 1+ 1 + 0 + 0 + 0 + 0 + 0) \newline
&= \frac {5} {10} = 0.5
\end{aligned}
$$

Âπ∂‰∏îÔºö

$$
f(17) = f(18) = f(19)  = f(20)  = f(21)  = 1 \\  f(22) = f(23) = f(24)  = f(25)  = f(26)  = 0
$$

‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•ÂæóÂà∞ÂàùÊ≠•ÁöÑÁä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ãÔºö

$$
\begin{aligned} f(x) &= \frac {1} {W} \cdotp (f(x + 1) + f(x + 2) + \dotsb + f(x + W)) \\  f(x - 1) &= \frac {1} {W} \cdotp (f(x) + f(x + 1) + \dotsb + f(x + W - 1)) \\ \vdots \\ f(0) &= \frac {1} {W} \cdotp (f(1) + f(2) + \dotsb + f(W)) \end{aligned}
$$

Âà∞ËøôÈáå‰∏∫Ê≠¢ÔºåÂÖ∂ÂÆûÊàë‰ª¨Â∑≤ÁªèËÉΩÂ§üÂÜôÂá∫È¢òËß£‰∫ÜÔºå‰ΩÜÊòØÊàë‰ª¨Ë¶ÅÊòØ‰ª•È´ò‰∏≠ÁîüÁöÑÁúºÂÖâÊù•Áúã‰∏äÈù¢ÁöÑÂÖ¨ÂºèÔºåÊàë‰ª¨‰∏çÈöæÂèëÁé∞ÔºåÂêé‰∏ÄÈ°πÂíåÂâç‰∏ÄÈ°πÁöÑÂÖ¨Âºè‰∏≠ÂÖ∂ÂÆûÊúâÈÉ®ÂàÜ‰∏™ÁªìÊûúÊòØÊúâÈáçÂ§çÁöÑÈÉ®ÂàÜÔºå*f(x)*Âíå*f(x - 1)*‰∏≠ÊúâÈáçÂè†ÁöÑ*f(x + 1) + ... + f(x + W - 1))*Ôºå‰∫éÊòØÊàë‰ª¨ÂèØ‰ª•‰∏§ÂºèÁõ∏ÂáèÊù•ÁÆÄÂåñ‰∏Ä‰∏ãÔºö

$$
\begin{aligned} f(x) - f(x - 1) &= \frac {1} {W} \cdotp (\bcancel{f(x + 1)} + \bcancel{f(x + 2)} + \bcancel{\dotsb} + f(x + W)) \\ &\quad- \frac {1} {W} \cdotp (f(x) + \bcancel{f(x + 1)} + \bcancel{\dotsb} + \bcancel{f(x + W - 1)}) \\ &= \frac {1} {W} \cdotp (f(x + W) - f(x)) \end{aligned}
$$

‰∫éÊòØÊúâÔºö

$$
f(x)  - f(x - 1)  = \frac {1} {W} \cdotp (f(x + W) - f(x))
$$

Âà∞ËøôÈáåÊúâ‰∏§‰∏™ÂåñÁÆÄÈÄâÊã©Ôºö

1. Â¶ÇÊûú*f(x - 1)*Âè≥ÁßªÔºö

   $$
   f(x) = \frac {1} {W} \cdotp (f(x + W) - f(x))  - f(x - 1)
   $$

   ËøôÊ†∑Êó†Ê≥ïÊ±ÇËß£ÔºåÂõ†‰∏∫Êàë‰ª¨ÊòØ‰ªéÂêéÂæÄÂâçÊé®Âà∞ÁöÑËΩ¨ÁßªÂÖ¨ÂºèÔºåÊúÄÁªàÊòØË¶ÅÊé®ÂØºÈÅì*f(0)*ÔºåÊàë‰ª¨Â∏åÊúõÁöÑÊòØË¶ÅÊúâÔºö

   $$
   f(x) = C \cdot f(x + 1) + k
   $$

   ËøôÊ†∑ÁöÑÂÖ¨ÂºèÔºåËøôÊ†∑Êàë‰ª¨ÊâçËÉΩÂÄíÂ∫èÂæ™ÁéØÔºå‰ªéÂêé‰∏ÄÈ°πÊé®Âá∫Ââç‰∏ÄÈ°πÁöÑÂÄºÔºåËßÇÂØü‰∏äÈù¢ÁöÑÂåñÁÆÄÂºèÂèØ‰ª•ÂèëÁé∞ÔºåÂºè‰∏≠Êúâ 3 ‰∏™È´ò‰∏ÄÈ°πÁöÑÂÄºÔºå‰∏Ä‰∏™ÁüÆ‰∏ÄÈ°πÁöÑÂÄºÔºåÊàë‰ª¨ÊääÈ´òÁöÑÈÉΩÊîæÂè≥ËæπÔºåÁüÆÁöÑÂçïÁã¨ÊîæÂ∑¶ËæπÔºå‰∫éÊòØÊúâÁ¨¨‰∫åÁßçÂåñÁÆÄ

2. *f(x - 1)*Âè≥ÁßªÂêéÔºåÂéüÂºèÂè≥ËæπÂ∑¶ÁßªÔºåÊúÄÂêéÂ∑¶Âè≥ÁøªËΩ¨‰∏Ä‰∏ãÔºö

$$
\begin{aligned} f(x - 1) &= f(x) -  \frac {1} {W} \cdotp (f(x + W) - f(x)) \\ f(x) &= f(x + 1) -  \frac {1} {W} \cdotp (f(x + 1 + W) - f(x + 1)) \end{aligned}
$$

‰∏äÂºèÂ∞±ÊòØÊàë‰ª¨ÊúÄÁªàÂæóÂá∫ÁöÑÁÆÄÂåñÁöÑÈÄöÈ°πÂÖ¨ÂºèÔºåÁÑ∂ÂêéÊàë‰ª¨ÂÖ¥È´òÈááÁÉàÂú∞ÂÜôÂá∫È¢òËß£Ôºö

```java
public double new21Game(int n, int k, int w) {
    if (k == 0) return 1.0;
    double[] dp = new double[k + w + 1];
    for (int i = k; i <= k + w - 1 && i <= n; i++) {
        dp[i] = 1.0;
    }
    for (int i = k - 1; i >= 0; i--) {
        dp[i] = dp[i + 1] - (dp[i + w + 1] - dp[i + 1]) / w;
    }
    return dp[0];
}
```

ÁªìÊûúÁàÜÁÇ∏ÔºåËøôÂà∞Â∫ïÊòØ‰∏∫‰ªÄ‰πàÂë¢ÔºüÊºîÁÆó‰∏Ä‰∏ãÔºåÊàë‰ª¨ÂèëÁé∞*dp[16]*Â±ÖÁÑ∂ÁÆóÂá∫ 1.1000000ÔºåÊòæÁÑ∂Âíå‰∫ãÂÆûÁöÑ 0.5 ‰∏çÁ¨¶ÔºåÊàë‰ª¨ÂÅáËÆæÂåñÁÆÄÂêéÈÄöÈ°πÂÖ¨Âºè‰∏çÈÄÇÁî®‰∫é*dp[K-1]*ÔºåÈÇ£‰πàÊàë‰ª¨ÈúÄË¶ÅÂÖàËÆ°ÁÆóÂ•ΩËøô‰∏™ÂÄºÔºåÂÜç‰ªé*dp[K-2]*ÔºåÂºÄÂßãÂéªÂ∞ùËØïÔºåÈÇ£‰πà*dp[K-1]*Á≠â‰∫éÂ§öÂ∞ëÂë¢Ôºü

Êàë‰ª¨Âú®ÂæóÂà∞ 16 ÂàÜÁöÑÊó∂ÂÄôÔºåË∑ùÁ¶ª 21 ÂàÜËøòÊúâ 10 Âº†ÁâåÈáåÊúâ 5 ÁßçËµ¢ÁöÑÂèØËÉΩÔºåÈÇ£Â∞±ÊòØ 21-16+1Ôºå‰πüÂ∞±ÊòØ*N-K+1*ÔºåËÄåÂ¶ÇÊûúËØ¥ËøôÊó∂ÂÄô W Á≠â‰∫é 3ÔºåÈÇ£‰πàÂ∞±ÊúÄÂ§öÂè™Êúâ 3 Âº†ÁâåÈáåÊúâ 3 ÁßçËµ¢ÁöÑÊú∫‰ºöÔºåÊâÄ‰ª•Êàë‰ª¨ÂèØ‰ª•ÂæóÂá∫ÂÖ¨ÂºèÔºö

$$
f(K - 1) = \frac {1} {W} \cdot min(N-K+1, W)
$$

‰∫éÊòØÊàë‰ª¨ÊúÄÁªàÁöÑ‰ª£Á†Å‰∏∫Ôºö

```java
public double new21Game(int n, int k, int w) {
    if (k == 0) return 1.0;
    double[] dp = new double[k + w + 1];
    for (int i = k; i <= k + w - 1 && i <= n; i++) {
        dp[i] = 1.0;
    }
    dp[k - 1] = 1.0 * Math.min(n - k + 1, w) / w;
    for (int i = k - 2; i >= 0; i--) {
        dp[i] = dp[i + 1] - (dp[i + w + 1] - dp[i + 1]) / w;
    }
    return dp[0];
}
```
