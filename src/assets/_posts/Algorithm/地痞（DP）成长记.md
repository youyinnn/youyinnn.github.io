---
title: 地痞（DP）成长记
categories:
  - algorithm
  - dp
comments: true
tags:
  - algorithm
  - dp
date: 2018-8-30 20:58:01
---

### 大声 BB

为了以后看到一道我知道是用 DP 但是不知道如何去 DP 的问题再也不会束手无策

决心做一个地痞，至少下次看到一个 DP 不会再被它 DP

---

### 什么是 DP？

动态规划（Dynamic Programming），最初并不是应用于计算机科学当中，而是一种数学方法，在 20 世纪 50 年代初由美国数学家*Richard Bellman*发明，意图用来求解某类最优问题。

在 DP 的思想当中：如果问题是由交叠的子问题构成的，我们就可以用 DP 去解决这个问题。一般这样的子问题出现在对给定问题的求解**递推关系**中，这个**递推关系**中包含了相同类型的更小子问题的解**（已经解出来了的）**。

DP 建议我们，与其对交叠子问题一次次的求解，还不如将每个子问题的解记录在**一张表**中，这样就可以在表中直接得到原始问题的解。

### DP 怎么操作？

#### 斐波那契引例

我们先来看一个斐波那契数列第 n 个数是多少的例子，寻常**递归解法**：

```java
public int fibonacci(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
```

这个解法的时间复杂度，我们可以从它兵分两路去将它看成是一棵满二叉树：

![img](http://img.mp.sohu.com/upload/20170702/07bc2cc044c245588e0873e773dd9079_th.png)

二叉树的结点就是递归次数，这个结果近似是 2 的 n-1 次方，也就是**O(2^n)**

显然，指数级的效率是非常低的，我们观察一下这棵树，其中有很多结点是重复计算的：

![img](http://img.mp.sohu.com/upload/20170702/148d4dfd369240efbd2e28e0f44e8adc_th.png)

为了避免这种重复计算，我们可以将每个子问题求出的结果，放在**一张表**中，每次求解当前问题的时候，索引表中已经求好的子问题，如果说将**递归法**视为自顶向下的方法，那么这种开辟空间存结果的方法，我们称之为**备忘录法**，这是一种自底向上的考虑方法

```java
public int fibonacci(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    int[] memo = new int[n];
    memo[0] = 0;
    memo[1] = 1;
    int i = 2;
    while(i < n) {
        memo[i++] = memo[i - 1] + memo[i - 2];
    }
    return memo[i];
}
```

这个算法，性能是**O(n)**，但是空间耗费也变成了**O(n)**，说实话，我们一次次备忘，其实真正需要的总不就是 n 的前两个 n-1 和 n-2 么，至于前面的 n-3 一直到 0，其实已经不需要了，所以这**备忘录之法**还是可以进一步优化的，优化了之后，才是真正的、最简单的动态规划

```java
public int fibonacci(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    int n1 = 0;
    int n2 = 1;
    int i = 2;
    int get = 0;
    while(i < n) {
        get = n1 + n2;
        n2 = n1;
        n1 = get;
        i++;
    }
    return get;
}
```

在这样的情况下，既不需要**O(n)**的空间，又可以保持**O(n)**的时间

#### 分析这个引例

通过这个小小的斐波那契，我们经历了从：**递归法**——**备忘录**——**动态规划**等三个阶段，在这个过程中，我们不断得将无意义的计算精简下来，将我们的思维由自顶向下，往前索取子问题的解，转变为自底向上，拿着子问题的解去找原问题的解，从整表的备忘录，到两个变量足矣运算的效率；

#### DP 要素

1. **最优子结构：**我们从最优解，看到什么子问题，比如`Fibonacci(10)=Fibonacci(9)+Fibonacci(8)`
2. **边界：**最低端的子问题，如`Fibonacci(0)=0,Fibonacci(1)=1;`
3. **状态转移公式：**问题求解的公式，我们要靠这个公式去推进结果，如：`Fibonacci(n)=Fibonacci(n-1)+Fibonacci(n-2)`

但是，仅仅做到到以上 3 要素，顶多只是个递归 level，动态规划真正的精髓在于：**减少无用功，利用已做工，权衡时空效率**

我们来练习一下新的题目

#### 练习：上台阶

> 有一座高度是**10**级台阶的楼梯，从下往上走，每跨一步只能向上**1**级或者**2**级台阶。要求用程序来求出一共有多少种走法。

我们从上到下考虑问题，我们要知道最后一步有两个情况，一个是从第 8 阶上 2 级，一个是从第 9 阶上 1 级，所以上到第 10 阶的最后一步可能的情况是这两个情况的总和，于是得出`F(10)=F(9)+F(8)`，这个式子是不是很眼熟？别急，我们得到了**最优子结构**，接下来看边界，我们很容易得知`F(3)=F(2)+F(1)`，于是**边界**`F(2)=2，F(1)=1`，**状态转移公式**也就出来了`F(n)=F(n-1)+F(n-2)`

这道题和斐波那契几乎如出一辙，仅仅是边界数据不一样而已，复现出来的代码

```java
public int climbingWay(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    int n1 = 1;
    int n2 = 2;
    int i = 3;
    int get = 0;
    while(i < n) {
        get = n1 + n2;
        n2 = n1;
        n1 = get;
        i++;
    }
    return get;
}
```

---

### DP 练习

#### 1：国王和金矿

> 有一个国家发现了 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。**每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。**要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？
>
> 金矿信息：
>
> |              | 1 金矿 | 2 金矿 | 3 金矿 | 4 金矿 | 5 金矿 |
> | :----------: | :----: | :----: | :----: | :----: | :----: |
> |   **储金**   |  400   |  500   |  200   |  300   |  350   |
> | **需要工人** |   5    |   5    |   3    |   4    |   3    |

下至上分析用备忘录法去分析：

我们用**W 代表所用的工人数**，**M 代表所考虑的金矿前几座的座数**，**每格代表用这么多工人考虑这么多座矿所能获得的最大金量 G**，首先我们要明确`G(m)={400, 500, 200, 300, 350}`，且每个**G**都要付出相应的**W**

比如第一格代表考虑前 1 座金矿，只用一个工人，于是第一行的数据我们很容易得出：

|         | w=1 | w=2 | w=3 | w=4 |    w=5    | w=6 | w=7 | w=8 | w=9 |   w=10    |
| :-----: | :-: | :-: | :-: | :-: | :-------: | :-: | :-: | :-: | :-: | :-------: |
| **m=1** |  0  |  0  |  0  |  0  |    400    | 400 | 400 | 400 | 400 |    400    |
| **m=2** |  0  |  0  |  0  |  0  | 500:star: | 500 | 500 | 500 | 500 | 900:star: |
| **m=3** |  0  |  0  | 200 | 200 |    500    | 500 | 500 | 700 | 700 |    900    |
| **m=4** |  0  |  0  | 200 | 300 |    500    | 500 | 500 | 700 | 800 |    900    |
| **m=5** |  0  |  0  | 350 | 350 |    500    | 550 | 650 | 850 | 850 |    900    |

到了 w=5，m=2 的时候，我们就需要考虑一下了：

1. 当我只有 5 个人的时候，我有 2 座矿可以挖，一个挖 400 一个挖 500，不做考虑**肯定**挖 500，那这个考虑是怎么做的呢？这会还看不出，总之这里就有

   `F（m=2，w=5）=Max（G（m=1，w=5），G（m=2，w=5）+G（m=1，w=5-5））=Max（400，500+0）=500`

2. w=6，n=2 的时候，这时候可以出 5 个人挖 500，剩下一个人去算的话，就是 n=1，w=1，即是 0 金，所以 w=6，n=2 也是 500，这里有

   `F（m=2，w=6）=Max（G（m=1，w=6），G（m=2，w=5）+G（m=1，w=6-5））=Max（400，500+0）=500`

3. 最后我们看到 w=10，n=2 这块，首先 5 人去挖 500，剩下还有 5 人，可以考虑 w=5，n=1，挖 400，这 500 和 400 肯定是加起来了得 900，所以有

   `F（m=2，w=10）=Max（G（m=1，w=10），G（m=2，w=5）+G（m=1，w=10-5））=Max（400，500+400）=900`

于是我们可以看出，Max 中的前半部分代表着**我不挖现在考虑到的这座矿，w 人全部去挖考虑之前的矿能挖到的**，后半部分代表**我出本矿所需要的人挖本矿，剩下的 W-Wn 人去挖之前的矿能挖到的**

于是我们尝试推算一下**最优子结构：**

`F（m=5，w=10）=Max（G（m=4，w=10），G（m=5，w=3）+G（m=4，w=10-3））`

我们的**边界：**

`F（m=1，w={1，10}）={0，0，0，0，400，400，400，400，400，400}`

就是第一行的结果，然后很容易得出**状态转移公式：**

`F（m，w）=Max（G（m -1 ，w），G（m，Wm）+G（m - 1，w-Wm））`其中 m 为当前考虑的前几座金矿数，w 为当前分配的工人数，Wm 为挖 m 需要的刚好的人数，w-Wm 就是剩下的人数了；

不难发现，下一行的结果都是前一行推导出来的，所以我们每次只需要记录前一行的内容就好了，并不需要将整个二维表记录下来，于是地痞该出场了：

```java
@Test
public void testDig(){
    int[] g = {400, 500, 200, 300, 350};
    int[] gw = {5, 5, 3, 4, 3};
    dig(g, gw, 10);
}

private void dig(int[] g, int[] gw, int w){
    int[] preResult = new int[w];
    // 准备第一行的数据
    for (int useWorker = 1; useWorker <= w; useWorker++) {
        preResult[useWorker - 1] = useWorker >= gw[0] ? g[0] : 0;
    }
    int[] nowResult = new int[w];
    // 从第二座矿开始算
    for (int m = 1; m < g.length; m++){
        System.out.println(Arrays.toString(preResult));
        // 从第一个工人开始算
        for (int useWorker = 1; useWorker <= w; useWorker++) {
            // 如果当前的工人数不能挖当前的矿，那么就挖之前的矿
            if (useWorker < gw[m]) {
                nowResult[useWorker - 1] = preResult[useWorker - 1];
            } else {
                // 在：1.挖当前的矿，剩余的人挖之前的矿；2.当前可用的工人挖之前的矿；中选一个最多金量的
                nowResult[useWorker - 1] =
                    Math.max(preResult[useWorker - 1],
                             (useWorker - gw[m] - 1 > 0 ?
                              preResult[useWorker - gw[m] - 1] : 0) + g[m]);
            }
        }
        System.arraycopy(nowResult, 0, preResult, 0, w);
    }
    System.out.println(Arrays.toString(nowResult));
}
```

```java
[0, 0, 0, 0, 400, 400, 400, 400, 400, 400]
[0, 0, 0, 0, 500, 500, 500, 500, 500, 900]
[0, 0, 200, 200, 500, 500, 500, 700, 700, 900]
[0, 0, 200, 300, 500, 500, 500, 700, 800, 900]
[0, 0, 350, 350, 500, 550, 650, 850, 850, 900]
```

输出的结果和我们用备忘录推算的结果一致，但是在实现的时候要注意 2 点：

1. 工人数（useWorker）使用的是自然数 1-10，而记录数组的下标却是 0-9，我们使用自然数的原因是为了更好地和 gw（每个矿需要多少人挖）做差运算；
2. 第 26 行的 preResult 和 nowResult 的结果替换，并不能直接`preResult=nowResult`，Java 毕竟是直接引用，所以还是老老实实地一个个复制过去；有的实现是直接赋值，估计是 c 的代码，指针机制不一样；

分解实现：

```java
private void dig2(int[] g, int[] gw, int w){
    int[] preResult = new int[w];
    // 准备第一行的数据
    for (int useWorker = 1; useWorker <= w; useWorker++) {
        preResult[useWorker - 1] = useWorker >= gw[0] ? g[0] : 0;
    }
    int[] nowResult = new int[w];
    // 从第二座矿开始算
    for (int m = 1; m < g.length; m++){
        System.out.println(Arrays.toString(preResult));
        // 从第一个工人开始算
        for (int useWorker = 1; useWorker <= w; useWorker++) {
            // 前矿
            int front = preResult[useWorker - 1];
            // 当前工人能不能挖当前这个矿 能就耗费wm人 不能就耗费0个人
            int wm = useWorker >= gw[m] ? gw[m] : 0;
            // 剩下多少人
            int left = useWorker - wm;
            // 后矿：如果挖不了当前的矿，就挖前矿；如果能挖，剩下的人去挖前矿剩下的人能挖的
            int back = wm == 0 ?
                preResult[useWorker - 1] :
            	g[m] + (left > 0 ? preResult[left - 1] : 0);
            // 前矿后矿谁大挖谁
            nowResult[useWorker - 1] = front > back ? front : back;
        }
        System.arraycopy(nowResult, 0, preResult, 0, w);
    }
    System.out.println(Arrays.toString(nowResult));
}
```

##### 从金矿再分析一下 DP

别高兴太早，我们做出了 DP 确实很开心，但是你有没有想过 DP 是否合适同一道题的所有情况？

我们做 DP，时间复杂度**O(m\*w)**，也就是**矿数（m）**和**工人数（w）**之积，空间复杂度**O(w)**

而如果使用递归法的话，时间复杂度就为**O(2^m)**，**空间复杂度 O(m)（递归深度）**

如果有这样的场景，1000 个工人，每个矿工人用量如下：

> |              | 1 金矿 | 2 金矿 | 3 金矿 | 4 金矿 | 5 金矿 |
> | :----------: | :----: | :----: | :----: | :----: | :----: |
> |   **储金**   |  400   |  500   |  200   |  300   |  350   |
> | **需要工人** |  430   |  450   |  320   |  420   |  350   |

那我们用 DP 去算的话效率为：**O(5000)/O(1000)**

用递归去算的话效率为：**O(2^5)/O(5)**

其实这只是一道简单的数学问题，DP 和 w 的数量成正比，递归只和 m 有关

所以一种算法并不是完美适合一道题，要根据场景去选择算法

###### 递归实现

```java
// dig3(g, gw, 1000, 4);
private int[] dig3(int[] g, int[] gw, int w, int m) {
    int[] nowResult = new int[w];
    if (m == 0) {
        nowResult = new int[]{0,0,0,0,400,400,400,400,400,400};
    } else {
        int[] preResult = dig3(g, gw, w, m - 1);
        for (int useWorker = 1; useWorker <= w; useWorker++) {
            if (useWorker < gw[m]) {
                nowResult[useWorker - 1] = preResult[useWorker - 1];
            } else {
                nowResult[useWorker - 1] =
                    Math.max(preResult[useWorker - 1],
                             (useWorker - gw[m] - 1 > 0 ?
                              	preResult[useWorker - gw[m] - 1] : 0) + g[m]);
            }
        }
    }
    System.out.println(Arrays.toString(nowResult));
    return nowResult;
}
```

#### 2：最大子序列和

> leetcode:https://leetcode-cn.com/problems/maximum-subarray/description/
>
> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **示例:**
>
> ```
> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
> ```
>
> **进阶:**
>
> 如果你已经实现复杂度为 O(_n_) 的解法，尝试使用更为精妙的分治法求解。

这是一道既简单又复杂的 DP，因为这道题咋一眼看去，实在是不好分析 DP 的 3 要素，边界无法确定，谁都有可能是边界，最优子结构无法确定，多长多短都不清楚，有可能解是在序列的前半部分，有可能在后半部分，有可能是在中间，子结构都没出来，更别说状态转移方程了

##### 暴力解 O(n^2)

带着诸多考虑，无论如何都无法独立想出 DP 来，尽管如此，我们先做暴力解，枚举出所有可能的序列和：

```java
private int ms(int[] nums) {
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < nums.length; i++) {
        int rSum = 0;
        for (int j = i; j < nums.length; j++) {
            rSum += nums[j];
            max = max > rSum ? max : rSum;
        }
    }
    return max;
}
```

其中 max 一开始就是 int 的最小值，这里不能用 0，万一序列全是负数的话，最后求出的序列 max 就是 0；

从 i 开始遍历序列，每次 i 里面又从`j=i`开始往后遍历，从`j=i`到`j=nums.length`的每个可能的序列和都求出来，取最大的那个 rSum，每次 i 遍历完第二个 for 循环之后，比较 rSum 和 max 谁大，取大的为 max；

这是一种什么思路？拿[-2,1,-3,4,-1,2,1,-5,4]来举例：

从`i=0，num[i]=-2`开始考虑，然后第二层 for 循环就是计算（-2+1）、（-2+1+-3）、（-2+1+-3+4）....即以-2 开头的子序列和都算过一次了，然后将以-2 开头的所有子序列和中最大的那个当作当前 i 循环轮次最大的 rSum，然后取最大的 rSum 为 max

也就是说，这是一种从序列**开头**往后考虑的暴力解，时间复杂度为**O(n^2)**

##### 看似简单

先前的 3 例 DP，我们都是从递归去入手，然后分析备忘录，然后精简备忘录为 DP，每到题都可以很直接的以一种递归的思想去求解问题，因为这些题都有一个共同的鲜明的特点：**解答一定在问题规模的最后**

但是这道题根本无从下手递归，因为我固化了思维：**解答不一定是在最后，可以在任何地方，所以不知道从哪开始递**，所以我不能代入递归的思想去求解

但是我们先不看答案可能在哪里，本质上说，我们处理序列的过程依然是一个从一端到另一端，**这也是一个传递的过程！**至于答案在哪，我们在边传递的时候，**就边比较边记录就好了！**

##### 转变思维到可传递

所以我们隐约看出，貌似有一种可传递的求解过程，如果我们将序列从头到尾传递求解的话，不难想出，这个**“递归”**的**边界**就是序列的第一个元素，而我们递到最后一个元素，则是**最优子序列**

现在还剩最重要的问题——**状态转移方程的求解**，我们再从传递过程的角度来深入分析一下，假如边界是`nums[0]`，则可以直接从`nums[1]`开始，且此时 rMax=-2：

1. 当前考虑`[-2， 1]`，程序从-2 传递到 1，那么在 1 这里我要进行什么样的选择呢？我得考虑（-2+1）和（1）谁更大，而且既然考虑到 1 了，那么我们每次的考虑都得包含 1，因为题目要求的是连续子序列；考虑完的结果是当前最大的 rMax 是（1）=1；往下传递；
2. 当前考虑`[-2，1，-3]`，有（-2+1+-3）、（1+-3）、（-3），如何进行选择呢？首先（-2+1+-3）可以不用考虑，为什么？因为（-2+1）在上一轮已经被否定掉了，所以我们直接拿上一轮的 rMax 和-3 一起考虑，因为必须是连续的子序列，所以就在（rMax）+（-3）和（-3）当作选择，选出的这轮选择的 rMax=（rMax）+（-3）=（1+-3）=-2
3. 当前考虑`[-2，1，-3，4]`，前面的就不用再多考虑了，直接对比（rMax）+（4）和（4），选中 rMax=（4）=4
4. 当前考虑`[-2，1，-3，4，-1]`，rMax=Max（（rMax）+（-1），（-1））=（4，-1）=3
5. 当前考虑`[-2，1，-3，4，-1，2]`，rMax=Max（（rMax）+（2），（2））=（4，-1，2）=5
6. 当前考虑`[-2，1，-3，4，-1，2，1]`，rMax=Max（（rMax）+（1），（1））=（4，-1，2，1）=6
7. 当前考虑`[-2，1，-3，4，-1，2，1，-5]`，rMax=Max（（rMax）+（-5），（-5））=（4，-1，2，1，-5）=-1
8. 当前考虑`[-2，1，-3，4，-1，2，1，-5，4]`，rMax=Max（（rMax）+（4），（4））=（4，-1，2，1，-5，4）=3

传递完毕，我们每一轮都将当前的`nums[i]`当作最大子序列和的**结尾**去考虑的话，这样就只需要在循环一次的情况下从后往前考虑到每一个序列了，于是我们可以推算出**状态转移方程：rMax=Max（rMax+nums[i]，nums[i]）**

且与此同时我们可以顺便筛选出 max，每次 rMax 求出之后就可以放到 max 中去（如果比上一次的 max 大的话）

```java
private int ms3(int[] nums) {
    int max = nums[0];
    int rMax  = nums[0];
    for (int i = 1; i < nums.length; i++) {
        rMax = Math.max(nums[i], rMax + nums[i]);
        max = Math.max(max, rMax);
    }
    return max;
}
```

##### 递归？

这道题也有一种递归的解法，基本思想就是，答案的位置只有 3 种可能性：序列的前半部分、序列的后半部分、前半部分的后面一点加上后半部分的前面一点，我们递归左右两部分然后再算中间；

这种实现最后可以做出证明，效率是**O(nlogn)**，但是实现比较难理解

##### 题目变种

###### 2.1：挑菜问题

> 2018 年 9 月 10 日，快手校招笔试
>
> n 个菜，每个菜有好吃程度，求出一个连续吃到的好吃程度最多的菜，可以选多次，但是每道菜只吃一次，比如 7 道菜选 2 次，菜好吃程度依次为 1 2 3 -2 3 -10 3，则可以选出[1,2,3,-2,3]，剩下-10，3 还可以再选一次[3]，总的好吃程度是 10；也可以不选菜，比如 7 道菜选 4 次，1 2 3 -2 3 -10 3 中可以选[1,2,3]是一次[3]是一次[3]又是一次，最后一次不选任何菜，因为只剩下-10 和-2，总的好吃程度是 12。
>
> 输入
>
> 7 2
>
> 1 2 3 -2 3 -10 3
>
> 输出
>
> 10
>
> 解释
>
> [1,2,3,-2,3] -10 [3]
>
> 输入
>
> 7 4
>
> 1 2 3 -2 3 -10 3
>
> 输出
>
> 12
>
> 解释
>
> [1,2,3] -2 [3] -10 [3]

这题还不止是简单的最大子序列和，还涉及到选择分界的问题，比如 72 的 case，pick one 为什么可以包含-2，然后 74 的 case 中，为什么又可以避开负数

时隔许久又看到这道题，一时半会没想出解，等洗个澡回来的功夫，就想到了解题思路

我们使用变治法，问题是有选择地求最大子序列和，变为二分求最小某段区域的最小子序列和，这个最小子序列和必然将当前段分为最大子序列的两部分：

- 比如 72 的 case 中整段的最小子序列和为-10，它将整段分为两部分，这两部分就是解；
- 比如 74 的 case 中又 72case 递归而来的话，左边又求最小子序列，求得-2，又分为两部分；

再更新，不解了这道题，这是道傻逼题；

#### 3：机器人走方格

> newcoder:https://www.nowcoder.com/questionTerminal/e8bb8e68434e42acbcdff0341f2a32c5
>
> 有一个 XxY 的网格，一个机器人只能走格点且只能向右或向下走，要从左上角走到右下角。请设计一个算法，计算机器人有多少种走法。
>
> 给定两个正整数 int **x**,int **y**，请返回机器人的走法数目。保证 x ＋ y 小于等于 12。
>
> 测试样例：
>
> ```
> 2,2
> 返回：2
> ```

刚开始可能不清楚怎么用 DP，直到我看到**“只能向右或向下走”**，这句话心想，嘿，最后一格有多少种走法，不就是要么从上面下来的走法，要么从左边过来的么走法么，这俩的走法加起来就是最后一格的走法，于是马上得出：`F(2，2)=F（1，2）+F（2，1）`，这是**最优子结构**

然后一切的事情都迎刃而解了，**边界**：

1. `F（0，0）=0`
2. 当 x=0 || y=0 时`F（x，y）=1`

**状态转移方程：**`F(x，y)=F（x，y - 1）+F（x - 1，y）`

接下来不多 BB 了，DP 三连：

```java
private int countWays(int x, int y) {
    if (x == 0 || y == 0) {
        return 0;
    } else if (x == 1 || y == 1) {
        return 1;
    }
    return countWays(x - 1, y) + countWays(x, y - 1);
}
```

这是递归

```java
private int countWaysMemo(int x, int y) {
    int[][] memo = new int[x][y];
    for (int i = 0; i < x; i++) {
        for (int j = 0; j < y; j++) {
            if (i == 0 && j == 0) {
                memo[i][j] = 0;
            } else if (i == 0 || j == 0) {
                memo[i][j] = 1;
            } else {
                memo[i][j] = memo[i - 1][j] + memo[i][j - 1];
            }
        }
    }
    return memo[x - 1][y - 1];
}
```

这是备忘录

```java
private int countWaysDp(int x, int y) {
    int[] pre = new int[x];
    int[] now = new int[x];
    for (int i = 1; i < x; i++) {
        pre[i] = 1;
    }
    for (int i = 1; i < y; i++) {
        for (int j = 0; j < x; j++) {
            if (j == 0) {
                now[j] = 1;
            } else {
                now[j] = now[j - 1] + pre[j];
            }
        }
        System.arraycopy(now, 0, pre, 0, x);
    }
    return now[x - 1];
}
```

DP

这道题是我第一道按照经典的 DP 三连的方法独立做出来的，稍微和头 3 例不同点，但是模式几乎一模一样，但是因为有 2 个输入，所以递归法的时间复杂度暂时先不好推，但是 DP 的时间复杂度是**O(xy)**，空间是**O(2x)**

#### 4：币值最大化问题

> 来源：紫皮书
>
> 给定一排 n 个硬币，其面值均为正数 c1，c2，...，cn，这些整数不一定两两不同。请问如何选择硬币，使得在其原始位置互不相邻的情况下，所选的硬币币值之和最大。

分析：

题目里面有一句很关键的话：**“使得在其原始位置互不相邻的情况下”**，那我从递归的角度去看：最后一个硬币和 F（n），可能的值只有 F（n-1）和 F（n-2）+cn，这里又有一点不同了，这里是递归选最大值，那么状态转移方程也比较明显了：**F（n）=Max（F（n-1），F（n-2）+cn）**

来，试着一步到位：

```java
private static int coinRowDp(int[] coins) {
    int n = 2;
    int f2 = 0;
    int f1 = coins[0];
    int fn = 0;
    while (n < coins.length + 1) {
        fn = Math.max(f1, f2 + coins[n - 1]);
        f2 = f1;
        f1 = fn;
        n += 1;
    }
    return fn;
}
```

这里稍微有一点点绕，我们先解释一下`F（n）=Max（F（n-1），F（n-2）+cn）`，他代表的是我如果要拿第 n 个选择可能是什么，它可能是拿第 n 个硬币+第 n-2 个硬币，有可能是，不拿第 n 个硬币，拿 n-1 个，我们来演算一遍，假设有硬币`[5，1，2，10，6，2]`：

1. `F(0)`：一个硬币也不拿，币值`c0=0`；
2. `F(1)`：考虑前 1 个硬币，拿或者不拿的最大币值，当然是拿了：`c1=coins[0]`，5
3. `F(2)`：考虑前 2 个硬币，拿或者不拿第 2 个硬币，这个选择相当于：选`F(1)`，或者`c2+F(0)`，5
4. `F(3)`：考虑前 3 个硬币，拿或者不拿第 3 个硬币，这个选择相当于：选`F(2)`，或者`F(1)+c3`，5+2
5. `F(4)`：考虑前 4 个硬币，那或者不拿第 4 个硬币，这个选择相当于：选`F(3)`，或者`F(2)+c4`，5+10
6. `F(5)`：考虑前 5 个硬币，那或者不拿第 5 个硬币，这个选择相当于：选`F(4)`，或者`F(3)+c5`，5+10
7. `F(6)`：考虑前 6 个硬币，那或者不拿第 6 个硬币，这个选择相当于：选`F(5)`，或者`F(4)+c6`，5+10+2

这么来说的话，一目了然了吧？其中 f1 代表的是 F(n-1)，f2 代表 F(n-2)

#### 5：硬币找零问题

> 有硬币 d1-dj，且 d1 < d2 < d3 < ... < dj，其中 d1=1
>
> ，需要找零 n，求最少的硬币数；
>
> 比如有硬币 1，3，4；找零 6，输出 2（两个 3 硬币）

这道题还是递归考虑，定义`F(n)`为找 n 需要的最少硬币数，那么`F(6)`那么我最后一颗硬币有 3 种取法：

1. 我可以取 1，那么`F(6)=F(6-1)+1`，也就是找零 5 的时候所需最少硬币数+1
2. 我可以取 3，那么`F(6)=F(6-3)+1`，
3. 我可以取 4，那么`F(6)=F(6-4)+1`，

这几种取法取最小的硬币数，再比如`F(3)`有如下取法：`F(3)=F(3-1)+1`或者`F(3)=F(3-3)+1`，在这里我们可以触摸到**边界**，`F(0)=0`，顺便补上`F(1)=1`（因为 d1=1），于是最优子结构出来了，用单一的式子可能难以描述：`F(n)=min{F(n-dj)}+1`，**其中 j 从 1 开始，一直到 dj<=n**

为什么我会提它？它有两点值得我们注意：

1. 你发现他即使到了 F(6)，也还是会用到 F(2)，所以这个 DP 可不能简化掉备忘录，备忘录是必须的；
2. 申请备忘录的技巧，数组的下标和问题中的自然数总是会引起严重的逻辑偏差问题，所以申请备忘录的时候，还是严格对齐自然数吧，详细的我们贴了代码再说；

```java
private static int changeMaking(int[] coins, int n) {
    int[] fn = new int[n + 1];
    fn[0] = 0;
    fn[1] = 1;
    for (int i = 2; i < n + 1; i++) {
        int temp = n;
        int coinIndex = 0;
        while (coinIndex < coins.length && i >= coins[coinIndex]) {
            temp = Math.min(fn[i - coins[coinIndex]], temp);
            coinIndex++;
        }
        fn[i] = temp + 1;
    }
    return fn[n];
}
```

可以看到，我们的 fn 是申请的 n+1 个空间，为什么？因为我们要严格对齐自然数和题意，防止逻辑错乱，比如说你真的不能偷懒去用`fn[0]`去代表`F(1)`

#### 6：硬币收集问题

> 在 n\*m 格木板中放有一些硬币，每格的硬币数目最多为 1 个。机器人从木板左上方走到右下方，只能往下走或者往右走一格，求机器人可能收集到的最大硬币数。
>
> 输入：一个 n\*m 的二维数组，元素值为 1 代表有硬币，0 代表没有；
>
> 输出：最大硬币数

```java
public static void main(String[] args) {
    int[][] coinMap = {{0,0,0,0,1,0},{0,1,0,1,0,0},{0,0,0,1,0,1},{0,0,1,0,0,1},{1,0,0,0,1,0}};
    System.out.println(collectionMemo(coinMap));
    System.out.println(collectionDp(coinMap));
}

private static int collectionMemo(int[][] coinMap) {
    int[][] fn = new int[coinMap.length][coinMap[0].length];
    fn[0][0] = coinMap[0][0];
    for (int i = 0; i < coinMap.length; i++) {
        for (int j = 0; j < coinMap[0].length; j++) {
            int n1 = 0;
            int m1 = 0;
            if (i != 0) {
                n1 = fn[i - 1][j];
            }
            if (j != 0) {
                m1 = fn[i][j - 1];
            }
            fn[i][j] = Math.max(n1, m1) + coinMap[i][j];
        }
    }
    return fn[coinMap.length - 1][coinMap[0].length - 1];
}

private static int collectionDp(int[][] coinMap) {
    int[] preFn = new int[coinMap[0].length];
    preFn[0] = coinMap[0][0];
    for (int i = 1; i < preFn.length; i++) {
        preFn[i] = preFn[i - 1] + coinMap[0][i];
    }
    int m1;
    int fn = 0;
    for (int i = 1; i < coinMap.length; i++) {
        m1 = preFn[0];
        for (int j = 1; j < coinMap[0].length; j++) {
            fn = Math.max(m1, preFn[j]) + coinMap[i][j];
            m1 = fn;
            preFn[j] = fn;
        }
    }
    return fn;
}
```

#### 7： 背包问题

> 给定 n 个重量为 W1,W2,W3...Wn 且价值为 V1,V2,V3...Vn 的物品，现有一个称重为 W 的背包，求背包能装下物品的最大价值
>
> 具体解析参考紫皮书，把状态转移公式写出来了就没什么问题了

```java
public int mostValuableLoading(int[] iw, int[] iv, int w) {
    int[] tmp = new int[w + 1];
    int[] next = new int[w + 1];
    tmp[0] = 0;
    for (int i = 1; i < tmp.length; i++) {
        if (i >= iw[0]) {
            tmp[i] = iv[0];
        }
    }
    // F (i, j) = / max(F(i - 1, j), Vi + F(i - 1, j - Wi))    j - Wi >= 0
    //            \ F(i - i, j)                                j - Wi < 0
    // i represent as item number
    // j represent as weight
    for (int i = 1; i < iw.length; i++) {
        for (int j = 0; j < next.length; j++) {
            if (j - iw[i] < 0) {
                next[j] = tmp[j];
            } else {
                next[j] = Math.max(tmp[j], iv[i] + tmp[j - iw[i]]);
            }
        }
        System.arraycopy(next, 0, tmp, 0, w + 1);
    }
    return next[w];
}
```

### 参考：

> [1]DP 到金矿的参考
>
> https://www.sohu.com/a/153858619_466939
> 《算法设计与分析基础》（紫皮书）
>
> [2]Maximum-SubArray 的参考
>
> https://blog.csdn.net/zwzsdy/article/details/80029796 > https://www.cnblogs.com/coderJiebao/p/Algorithmofnotes27.html
